{
    "id": "50313094f488b340",
    "type": "function",
    "z": "14580213f897af9a",
    "g": "108057c6b0820334",
    "name": "完整處理器 (All Devices)",
    "func": "// 完整版處理器：支援 Single/Dual/Relay 燈光、Cover、Scene\n\n// Debug 控制 (透過 global context 設定)\nconst debugConfig = global.get('debug_config') || {\n    topic: true,        // 顯示收到的 Topic\n    cache: true,        // 顯示快取操作\n    modbus: true,       // 顯示 Modbus 指令詳情\n    mqtt: true,         // 顯示 MQTT 狀態回報\n    scene: true,        // 顯示 Scene 處理\n    query: true         // 顯示 Query 查詢\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nconst DEFAULT_BRIGHTNESS = 100;\nconst DEFAULT_COLORTEMP = 250;\nconst MIN_MIRED = 167;\nconst MAX_MIRED = 333;\nconst BRIGHTNESS_TIME = 0x05;\nconst CHANNEL_REGISTER_MAP = {\n    \"1\": 0x082A,\n    \"2\": 0x082B,\n    \"3\": 0x082C,\n    \"4\": 0x082D,\n    \"a\": [0x082A, 0x082B],\n    \"b\": [0x082C, 0x082D]\n};\nconst CHANNEL_COIL_MAP = {\n    \"1\": 0x0000,\n    \"2\": 0x0001,\n    \"3\": 0x0002,\n    \"4\": 0x0003\n};\n\nfunction generalCommandBuild(frame) {\n    function crc16(buf) {\n        let crc = 0xFFFF;\n        for (const b of buf) {\n            crc ^= b;\n            for (let i = 0; i < 8; i++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        return crc;\n    }\n    const crc = crc16(frame);\n    return Buffer.concat([frame, Buffer.from([crc & 0xFF, (crc >> 8) & 0xFF])]);\n}\n\nfunction clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\n\nfunction buildCommand(moduleId, reg, value, speed = 0x05) {\n    const hi = (reg >> 8) & 0xFF;\n    const lo = reg & 0xFF;\n    const cmd = Buffer.from([moduleId, 0x06, hi, lo, speed, value]);\n    return generalCommandBuild(cmd);\n}\n\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light, cover\nconst subType = parts[2];        // single, dual, relay, scene, general\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\ndebugLog('topic', `=== 收到訊息 ===`);\ndebugLog('topic', `Topic: ${msg.topic}`);\ndebugLog('topic', `Payload: ${msg.payload}`);\ndebugLog('topic', `Device: ${deviceType}, SubType: ${subType}, Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\n\n// ========== LIGHT DEVICE ==========\nif (deviceType === \"light\") {\n    const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n\n    // 處理 set/brightness 和 set/colortemp\n    if (parts.length >= 7 && parts[5] === \"set\") {\n        const attribute = parts[6];\n        // Scene 的 key 格式不同：scene_single_12-3--12-4_brightness\n        let key;\n        if (subType === \"scene\") {\n            key = `scene_${parts[3]}_${parts[4]}_${attribute}`;\n        } else {\n            key = `${subType}_${moduleId}_${channel}_${attribute}`;\n        }\n        const val = Number(msg.payload);\n\n        if (!isNaN(val)) {\n            flow.set(key, val);\n            debugLog('cache', `儲存 ${key} = ${val}`);\n        }\n\n        if (attribute === \"brightness\" || attribute === \"colortemp\") {\n            // 對於 dual 燈光的色溫調整，只發送色溫指令，不觸發完整控制流程\n            if (subType === \"dual\" && attribute === \"colortemp\") {\n                const regs = CHANNEL_REGISTER_MAP[channel];\n                if (!regs) {\n                    debugLog('modbus', `找不到通道 ${channel} 的寄存器`);\n                    return null;\n                }\n                \n                let colortemp = val;\n                colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n                const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n                \n                const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n                \n                debugLog('modbus', `=== Modbus 指令 (Dual Colortemp Only) ===`);\n                debugLog('modbus', `色溫: ${cmdColortemp.toString('hex')}`);\n                \n                modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, colortemp });\n                \n                node.status({\n                    fill: \"yellow\",\n                    shape: \"dot\",\n                    text: `${moduleId}-${channel}: Colortemp ${colortemp}K`\n                });\n                \n                return [modbusMessages, []];\n            }\n            \n            // 亮度或色溫變更時，保持當前開關狀態不變\n            // 0% 不會自動變成 OFF，需要明確發送 OFF 指令才會關閉\n            const stateKey = `${subType}_${moduleId}_${channel}_state`;\n            const state = flow.get(stateKey) || \"ON\";\n            msg.topic = `homeassistant/light/${subType}/${moduleId}/${channel}/set`;\n            msg.payload = state;\n        } else {\n            return null;\n        }\n    }\n\n    // ===== RELAY =====\n    if (subType === \"relay\") {\n        const addr = CHANNEL_COIL_MAP[channel];\n        if (addr === undefined) {\n            debugLog('modbus', `找不到 Relay 通道 ${channel}`);\n            return null;\n        }\n\n        const state = (msg.payload === \"ON\") ? \"ON\" : \"OFF\";\n        const valHi = (msg.payload === \"ON\") ? 0xFF : 0x00;\n        const valLo = 0x00;\n        const hi = (addr >> 8) & 0xFF;\n        const lo = addr & 0xFF;\n        const frame = Buffer.from([moduleId, 0x05, hi, lo, valHi, valLo]);\n        const cmd = generalCommandBuild(frame);\n\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        debugLog('modbus', `=== Modbus 指令 (Relay) ===`);\n        debugLog('modbus', `Coil 地址: 0x${addr.toString(16).padStart(4, '0')}`);\n        debugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n\n    // ===== SINGLE =====\n    else if (subType === \"single\") {\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('modbus', `找不到通道 ${channel} 的寄存器`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const speed = (state === \"OFF\") ? 0x00 : BRIGHTNESS_TIME;\n        const cmd = buildCommand(moduleId, reg, brValue, speed);\n\n        debugLog('modbus', `=== Modbus 指令 (Single) ===`);\n        debugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state, brightness });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n\n    // ===== DUAL =====\n    else if (subType === \"dual\") {\n        const regs = CHANNEL_REGISTER_MAP[channel];\n        if (!regs) {\n            debugLog('modbus', `找不到通道 ${channel} 的寄存器`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        let colortemp = flow.get(`${subType}_${moduleId}_${channel}_colortemp`);\n        if (typeof colortemp !== \"number\") colortemp = DEFAULT_COLORTEMP;\n        colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n        const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const cmdBrightness = buildCommand(moduleId, regs[0], brValue);\n        const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n        debugLog('modbus', `=== Modbus 指令 (Dual) ===`);\n        debugLog('modbus', `亮度: ${cmdBrightness.toString('hex')}`);\n        debugLog('modbus', `色溫: ${cmdColortemp.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmdBrightness, subType, moduleId, channel, state, brightness, colortemp });\n        modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, state, brightness, colortemp });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}% ${colortemp}K`\n        });\n    }\n\n    // ===== SCENE =====\n    else if (subType === \"scene\") {\n        const sceneType = parts[3];  // single, dual\n        const lights = parts[4].split(\"--\");  // 12-1--12-2\n        const state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        \n        // Scene 快取 key 格式: scene_single_12-3--12-4_brightness\n        const groupBrightnessKey = `scene_${sceneType}_${parts[4]}_brightness`;\n        const groupColortempKey = `scene_${sceneType}_${parts[4]}_colortemp`;\n        const groupBrightness = flow.get(groupBrightnessKey);\n        const groupColortemp = flow.get(groupColortempKey);\n\n        debugLog('scene', `=== Scene 控制 ===`);\n        debugLog('scene', `場景類型: ${sceneType}`);\n        debugLog('scene', `燈光列表: ${lights.join(\", \")}`);\n        debugLog('scene', `狀態: ${state}`);\n\n        // 發送指令到每個燈光\n        for (let light of lights) {\n            const [lightId, lightChannel] = light.split(\"-\");\n            \n            // 先直接更新個別燈光的快取（不透過 MQTT）\n            if (state === \"ON\" && groupBrightness !== undefined) {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_brightness`, groupBrightness);\n                debugLog('scene', `更新快取: ${sceneType}_${lightId}_${lightChannel}_brightness = ${groupBrightness}`);\n            }\n            if (state === \"ON\" && groupColortemp !== undefined && sceneType === \"dual\") {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_colortemp`, groupColortemp);\n                debugLog('scene', `更新快取: ${sceneType}_${lightId}_${lightChannel}_colortemp = ${groupColortemp}`);\n            }\n            \n            // 然後發送開關指令（會使用剛更新的快取）\n            const lightTopic = `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/set`;\n            mqttMessages.push({ topic: lightTopic, payload: state });\n        }\n\n        // 更新場景本身的狀態\n        mqttMessages.push({ topic: `homeassistant/light/scene/${sceneType}/${parts[4]}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"yellow\" : \"grey\",\n            shape: \"ring\",\n            text: `Scene: ${lights.length} 燈 ${state}`\n        });\n    }\n}\n\n// ========== COVER DEVICE ==========\nelse if (deviceType === \"cover\") {\n    // 格式: homeassistant/cover/general/12/set\n    // payload: \"1_2/3\" 表示開啟 relay 1 和 2，關閉 relay 3\n    \n    const relays = msg.payload.split(\"/\");\n    const on_relays = relays[0] ? relays[0].split(\"_\").map(Number) : [];\n    const off_relays = (relays[1] && relays[1].length > 0) ? relays[1].split(\"_\").map(Number) : [];\n\n    let output = 0x00;\n    for (let relay of on_relays) {\n        output |= (1 << (relay - 1));\n    }\n    for (let relay of off_relays) {\n        output &= ~(1 << (relay - 1));\n    }\n\n    const frame = Buffer.from([moduleId, 0x06, 0x01, 0x9b, 0x10, output]);\n    const cmd = generalCommandBuild(frame);\n\n    debugLog('modbus', `=== Modbus 指令 (Cover) ===`);\n    debugLog('modbus', `開啟 Relay: ${on_relays.join(\", \")}`);\n    debugLog('modbus', `關閉 Relay: ${off_relays.join(\", \")}`);\n    debugLog('modbus', `Bit Mask: 0b${output.toString(2).padStart(8, '0')} (0x${output.toString(16).padStart(2, '0')})`);\n    debugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\n    modbusMessages.push({ payload: cmd, deviceType, moduleId, on_relays, off_relays });\n\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `Cover: ON[${on_relays}] OFF[${off_relays}]`\n    });\n}\n\n\n// ========== QUERY DEVICE (查詢) ==========\nelse if (deviceType === \"query\") {\n    // 格式: homeassistant/query/{subType}/{moduleId}/{channel}\n    // subType: single, dual, relay\n    \n    const querySubType = subType;  // single, dual, relay\n    \n    debugLog('query', `=== Query 查詢 ===`);\n    debugLog('query', `類型: ${querySubType}, 模組: ${moduleId}, 通道: ${channel}`);\n    \n    let frame;\n    \n    if (querySubType === \"single\" || querySubType === \"dual\") {\n        // 查詢 Single/Dual Light: Read Holding Registers (0x03)\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('query', `找不到通道 ${channel} 的寄存器`);\n            return null;\n        }\n        \n        const startReg = Array.isArray(reg) ? reg[0] : reg;  // dual 取第一個寄存器\n        const quantity = Array.isArray(reg) ? 2 : 1;  // dual 讀 2 個，single 讀 1 個\n        \n        const regHi = (startReg >> 8) & 0xFF;\n        const regLo = startReg & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n        \n        frame = Buffer.from([moduleId, 0x03, regHi, regLo, qtyHi, qtyLo]);\n        \n        debugLog('query', `讀取寄存器: 0x${startReg.toString(16).padStart(4, '0')}, 數量: ${quantity}`);\n    }\n    else if (querySubType === \"relay\") {\n        // 查詢 Relay: Read Coils (0x01)\n        const addr = CHANNEL_COIL_MAP[channel] || 0x0000;\n        const quantity = 4;  // 讀取 4 個 coils\n        \n        const addrHi = (addr >> 8) & 0xFF;\n        const addrLo = addr & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n        \n        frame = Buffer.from([moduleId, 0x01, addrHi, addrLo, qtyHi, qtyLo]);\n        \n        debugLog('query', `讀取線圈: 0x${addr.toString(16).padStart(4, '0')}, 數量: ${quantity}`);\n    }\n    else {\n        debugLog('query', `不支援的查詢類型: ${querySubType}`);\n        return null;\n    }\n    \n    const cmd = generalCommandBuild(frame);\n    \n    debugLog('modbus', `=== Modbus 查詢指令 ===`);\n    debugLog('modbus', `指令: ${cmd.toString('hex')}`);\n    \n    // 將查詢資訊附加到每個訊息中，供 Feedback 使用\n    const queryMsg = { \n        payload: cmd, \n        deviceType: \"query\", \n        subType: querySubType, \n        moduleId, \n        channel,\n        queryInfo: { type: querySubType, channel: channel }\n    };\n    modbusMessages.push(queryMsg);\n    \n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query ${querySubType} ${moduleId}-${channel}`\n    });\n}\n\n\nelse {\n    debugLog('topic', `不支援的設備類型: ${deviceType}`);\n    return null;\n}\n\n// 返回: [Modbus 指令, MQTT 狀態]\nreturn [modbusMessages, mqttMessages];",
    "outputs": 2,
    "timeout": 0,
    "noerr": 0,
    "initialize": "node.warn(\"=== 初始化完整測試系統 ===\");",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 2100,
    "wires": [
        [
            "d59a4d2f00fac520",
            "4f08be38e8e5a989"
        ],
        [
            "91359a179be62f4c",
            "e67cfaa863dbcbf7"
        ]
    ]
}