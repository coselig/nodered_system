{
    "id": "50313094f488b340",
    "type": "function",
    "z": "14580213f897af9a",
    "g": "108057c6b0820334",
    "name": "å®Œæ•´è™•ç†å™¨ (All Devices)",
    "func": "// å®Œæ•´ç‰ˆè™•ç†å™¨ï¼šæ”¯æ´ Single/Dual/Relay ç‡ˆå…‰ã€Coverã€Scene\n\n// Debug æ§åˆ¶ (é€é global context è¨­å®š)\nconst debugConfig = global.get('debug_config') || {\n    topic: true,        // é¡¯ç¤ºæ”¶åˆ°çš„ Topic\n    cache: true,        // é¡¯ç¤ºå¿«å–æ“ä½œ\n    modbus: true,       // é¡¯ç¤º Modbus æŒ‡ä»¤è©³æƒ…\n    mqtt: true,         // é¡¯ç¤º MQTT ç‹€æ…‹å›å ±\n    scene: true,        // é¡¯ç¤º Scene è™•ç†\n    query: true         // é¡¯ç¤º Query æŸ¥è©¢\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nconst DEFAULT_BRIGHTNESS = 100;\nconst DEFAULT_COLORTEMP = 250;\nconst MIN_MIRED = 167;\nconst MAX_MIRED = 333;\nconst BRIGHTNESS_TIME = 0x05;\nconst CHANNEL_REGISTER_MAP = {\n    \"1\": 0x082A,\n    \"2\": 0x082B,\n    \"3\": 0x082C,\n    \"4\": 0x082D,\n    \"a\": [0x082A, 0x082B],\n    \"b\": [0x082C, 0x082D]\n};\nconst CHANNEL_COIL_MAP = {\n    \"1\": 0x0000,\n    \"2\": 0x0001,\n    \"3\": 0x0002,\n    \"4\": 0x0003\n};\n\nfunction generalCommandBuild(frame) {\n    function crc16(buf) {\n        let crc = 0xFFFF;\n        for (const b of buf) {\n            crc ^= b;\n            for (let i = 0; i < 8; i++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        return crc;\n    }\n    const crc = crc16(frame);\n    return Buffer.concat([frame, Buffer.from([crc & 0xFF, (crc >> 8) & 0xFF])]);\n}\n\nfunction clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\n\nfunction buildCommand(moduleId, reg, value, speed = 0x05) {\n    const hi = (reg >> 8) & 0xFF;\n    const lo = reg & 0xFF;\n    const cmd = Buffer.from([moduleId, 0x06, hi, lo, speed, value]);\n    return generalCommandBuild(cmd);\n}\n\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light, cover, memory\nconst subType = parts[2];        // single, dual, relay, scene, general\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\ndebugLog('topic', `=== æ”¶åˆ°è¨Šæ¯ ===`);\ndebugLog('topic', `Topic: ${msg.topic}`);\ndebugLog('topic', `Payload: ${msg.payload}`);\ndebugLog('topic', `Device: ${deviceType}, SubType: ${subType}, Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\n\n// ========== MEMORY DEVICE (è¨˜æ†¶åŠŸèƒ½ + æŸ¥è©¢) ==========\nif (deviceType === \"memory\") {\n    const sceneId = parts[2];      // 0x02, 0x03, query, etc.\n    const operation = parts[3];    // 0x01 (ON), 0x02 (OFF), all\n    const action = parts[4];       // save, execute, get\n\n    // ===== MEMORY QUERY (æŸ¥è©¢æ‰€æœ‰è¨˜æ†¶) =====\n    if (sceneId === \"query\" && operation === \"all\") {\n        // æ ¼å¼: homeassistant/memory/query/all\n        debugLog('cache', `=== æŸ¥è©¢æ‰€æœ‰è¨˜æ†¶ç‹€æ…‹ ===`);\n\n        const SCENE_NAMES = {\n            \"0x02\": \"æœƒè­°å®¤\",\n            \"0x03\": \"å…¬å…±å€\",\n            \"0x04\": \"æˆ¶å¤–\",\n            \"0x05\": \"H40äºŒæ¨“\"\n        };\n\n        const OPERATION_NAMES = {\n            \"0x01\": \"ON\",\n            \"0x02\": \"OFF\"\n        };\n\n        let allMemories = [];\n        let totalCount = 0;\n\n        // æª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„è¨˜æ†¶çµ„åˆ\n        for (const sceneId of Object.keys(SCENE_NAMES)) {\n            for (const operation of Object.keys(OPERATION_NAMES)) {\n                const memoryKey = `memory_${sceneId}_${operation}`;\n                const memoryRecord = flow.get(memoryKey);\n\n                if (memoryRecord) {\n                    const deviceCount = Object.keys(memoryRecord.devices || {}).length;\n                    const sceneName = SCENE_NAMES[sceneId];\n                    const opName = OPERATION_NAMES[operation];\n\n                    allMemories.push({\n                        key: memoryKey,\n                        scene_id: sceneId,\n                        operation: operation,\n                        scene_name: memoryRecord.scene_name,\n                        display_name: `${sceneName}_${opName}`,\n                        device_count: deviceCount,\n                        timestamp: memoryRecord.timestamp,\n                        devices: memoryRecord.devices\n                    });\n\n                    totalCount++;\n\n                    debugLog('cache', `âœ… ${memoryKey}: ${memoryRecord.scene_name} (${deviceCount}å€‹è¨­å‚™) - ${memoryRecord.timestamp}`);\n                }\n            }\n        }\n\n        if (totalCount === 0) {\n            debugLog('cache', `âš ï¸ æ²’æœ‰æ‰¾åˆ°ä»»ä½•è¨˜æ†¶`);\n        } else {\n            debugLog('cache', `ğŸ“Š ç¸½å…±æ‰¾åˆ° ${totalCount} çµ„è¨˜æ†¶`);\n        }\n\n        // è¼¸å‡ºè¨˜æ†¶æ‘˜è¦\n        const summary = {\n            total_count: totalCount,\n            memories: allMemories.map(m => ({\n                key: m.key,\n                display_name: m.display_name,\n                device_count: m.device_count,\n                timestamp: m.timestamp\n            })),\n            timestamp: new Date().toISOString()\n        };\n\n        node.status({\n            fill: \"blue\",\n            shape: \"ring\",\n            text: `è¨˜æ†¶æŸ¥è©¢: ${totalCount} çµ„`\n        });\n\n        // è¿”å›å®Œæ•´çš„è¨˜æ†¶è³‡æ–™ä¾› Debug æª¢è¦–\n        return [[{\n            payload: summary,\n            allMemories: allMemories  // å®Œæ•´è³‡æ–™ï¼ˆåŒ…å«è¨­å‚™è©³æƒ…ï¼‰\n        }], []];\n    }\n\n    // ===== MEMORY SAVE (å„²å­˜è¨˜æ†¶) =====\n    if (action === \"save\") {\n        // æ ¼å¼: homeassistant/memory/{sceneId}/{operation}/save/set\n        // payload: JSON { scene_name, devices, timestamp }\n        \n        // å„²å­˜è¨˜æ†¶ï¼šè®€å–æ‰€æœ‰è¨­å‚™ç•¶å‰ç‹€æ…‹ä¸¦å„²å­˜\n        let memoryData;\n        try {\n            memoryData = JSON.parse(msg.payload);\n        } catch (e) {\n            debugLog('topic', `è¨˜æ†¶æŒ‡ä»¤ JSON è§£æå¤±æ•—: ${e.message}`);\n            return null;\n        }\n\n        const devices = memoryData.devices || [];\n        const memoryKey = `memory_${sceneId}_${operation}`;\n        const savedStates = {};\n\n        debugLog('cache', `=== å„²å­˜è¨˜æ†¶ ${memoryKey} ===`);\n        debugLog('cache', `å ´æ™¯åç¨±: ${memoryData.scene_name}`);\n        debugLog('cache', `è¨­å‚™æ•¸é‡: ${devices.length}`);\n\n        // è®€å–æ¯å€‹è¨­å‚™çš„ç•¶å‰ç‹€æ…‹\n        for (const deviceTopic of devices) {\n            const deviceParts = deviceTopic.split(\"/\");\n            const devType = deviceParts[1];        // light\n            const devSubType = deviceParts[2];     // single, dual\n            const devModuleId = deviceParts[3];    // 13, 14\n            const devChannel = deviceParts[4];     // 1, a, b\n\n            if (devType === \"light\") {\n                const stateKey = `${devSubType}_${devModuleId}_${devChannel}_state`;\n                const brightnessKey = `${devSubType}_${devModuleId}_${devChannel}_brightness`;\n                const colortempKey = `${devSubType}_${devModuleId}_${devChannel}_colortemp`;\n\n                const state = flow.get(stateKey) || \"OFF\";\n                const brightness = flow.get(brightnessKey) || DEFAULT_BRIGHTNESS;\n                const colortemp = flow.get(colortempKey) || DEFAULT_COLORTEMP;\n\n                savedStates[deviceTopic] = {\n                    state,\n                    brightness,\n                    colortemp: devSubType === \"dual\" ? colortemp : undefined\n                };\n\n                debugLog('cache', `  ${deviceTopic}: ${state} ${brightness}%${devSubType === 'dual' ? ` ${colortemp}K` : ''}`);\n            }\n        }\n\n        // å„²å­˜è¨˜æ†¶è³‡æ–™\n        const memoryRecord = {\n            scene_name: memoryData.scene_name,\n            timestamp: memoryData.timestamp || new Date().toISOString(),\n            devices: savedStates\n        };\n\n        flow.set(memoryKey, memoryRecord);\n        debugLog('cache', `âœ… è¨˜æ†¶å·²å„²å­˜: ${memoryKey}`);\n\n        node.status({\n            fill: \"blue\",\n            shape: \"dot\",\n            text: `è¨˜æ†¶: ${memoryData.scene_name} (${devices.length}å€‹è¨­å‚™)`\n        });\n\n        return null;\n    }\n}\n\n// ========== SCENE DEVICE (å ´æ™¯åŸ·è¡Œï¼ŒåŒ…å«è¨˜æ†¶åŸ·è¡Œ) ==========\nif (deviceType === \"scene\") {\n    // æ ¼å¼: homeassistant/scene/{sceneId}/{operation}/execute/set\n    const sceneId = parts[2];      // 0x02, 0x03, etc.\n    const operation = parts[3];    // 0x01 (ON), 0x02 (OFF)\n    const action = parts[4];       // execute\n\n    if (action === \"execute\") {\n        // åŸ·è¡Œè¨˜æ†¶å ´æ™¯\n        const memoryKey = `memory_${sceneId}_${operation}`;\n        const memoryRecord = flow.get(memoryKey);\n\n        if (!memoryRecord) {\n            debugLog('scene', `âš ï¸ æ‰¾ä¸åˆ°è¨˜æ†¶: ${memoryKey}`);\n            return null;\n        }\n\n        debugLog('scene', `=== åŸ·è¡Œè¨˜æ†¶å ´æ™¯ ${memoryKey} ===`);\n        debugLog('scene', `å ´æ™¯åç¨±: ${memoryRecord.scene_name}`);\n        debugLog('scene', `å„²å­˜æ™‚é–“: ${memoryRecord.timestamp}`);\n\n        const devices = memoryRecord.devices || {};\n        const deviceTopics = Object.keys(devices);\n\n        // å°æ¯å€‹è¨­å‚™ç™¼é€ MQTT æŒ‡ä»¤\n        for (const deviceTopic of deviceTopics) {\n            const savedState = devices[deviceTopic];\n            const deviceParts = deviceTopic.split(\"/\");\n            const devSubType = deviceParts[2];     // single, dual\n            const devModuleId = deviceParts[3];\n            const devChannel = deviceParts[4];\n\n            // å…ˆæ›´æ–°å¿«å–\n            const stateKey = `${devSubType}_${devModuleId}_${devChannel}_state`;\n            const brightnessKey = `${devSubType}_${devModuleId}_${devChannel}_brightness`;\n\n            flow.set(stateKey, savedState.state);\n            flow.set(brightnessKey, savedState.brightness);\n\n            if (devSubType === \"dual\" && savedState.colortemp !== undefined) {\n                const colortempKey = `${devSubType}_${devModuleId}_${devChannel}_colortemp`;\n                flow.set(colortempKey, savedState.colortemp);\n            }\n\n            debugLog('scene', `  ${deviceTopic}: ${savedState.state} ${savedState.brightness}%${savedState.colortemp ? ` ${savedState.colortemp}K` : ''}`);\n\n            // ç™¼é€æ§åˆ¶æŒ‡ä»¤\n            mqttMessages.push({\n                topic: `${deviceTopic}/set`,\n                payload: savedState.state\n            });\n        }\n\n        node.status({\n            fill: \"yellow\",\n            shape: \"ring\",\n            text: `åŸ·è¡Œè¨˜æ†¶: ${memoryRecord.scene_name} (${deviceTopics.length}å€‹è¨­å‚™)`\n        });\n\n        // ç›´æ¥è¿”å› MQTT è¨Šæ¯ï¼Œä¸éœ€è¦ Modbus\n        return [[], mqttMessages];\n    }\n}\n\n// ========== LIGHT DEVICE ==========\nif (deviceType === \"light\") {\n    const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n\n    // è™•ç† set/brightness å’Œ set/colortemp\n    if (parts.length >= 7 && parts[5] === \"set\") {\n        const attribute = parts[6];\n        // Scene çš„ key æ ¼å¼ä¸åŒï¼šscene_single_12-3--12-4_brightness\n        let key;\n        if (subType === \"scene\") {\n            key = `scene_${parts[3]}_${parts[4]}_${attribute}`;\n        } else {\n            key = `${subType}_${moduleId}_${channel}_${attribute}`;\n        }\n        const val = Number(msg.payload);\n\n        if (!isNaN(val)) {\n            flow.set(key, val);\n            debugLog('cache', `å„²å­˜ ${key} = ${val}`);\n        }\n\n        if (attribute === \"brightness\" || attribute === \"colortemp\") {\n            // å°æ–¼ dual ç‡ˆå…‰çš„è‰²æº«èª¿æ•´ï¼Œåªç™¼é€è‰²æº«æŒ‡ä»¤ï¼Œä¸è§¸ç™¼å®Œæ•´æ§åˆ¶æµç¨‹\n            if (subType === \"dual\" && attribute === \"colortemp\") {\n                const regs = CHANNEL_REGISTER_MAP[channel];\n                if (!regs) {\n                    debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n                    return null;\n                }\n                \n                let colortemp = val;\n                colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n                const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n                \n                const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n                \n                debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Dual Colortemp Only) ===`);\n                debugLog('modbus', `è‰²æº«: ${cmdColortemp.toString('hex')}`);\n                \n                modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, colortemp });\n                \n                node.status({\n                    fill: \"yellow\",\n                    shape: \"dot\",\n                    text: `${moduleId}-${channel}: Colortemp ${colortemp}K`\n                });\n                \n                return [modbusMessages, []];\n            }\n            \n            // äº®åº¦æˆ–è‰²æº«è®Šæ›´æ™‚ï¼Œä¿æŒç•¶å‰é–‹é—œç‹€æ…‹ä¸è®Š\n            // 0% ä¸æœƒè‡ªå‹•è®Šæˆ OFFï¼Œéœ€è¦æ˜ç¢ºç™¼é€ OFF æŒ‡ä»¤æ‰æœƒé—œé–‰\n            const stateKey = `${subType}_${moduleId}_${channel}_state`;\n            const state = flow.get(stateKey) || \"ON\";\n            msg.topic = `homeassistant/light/${subType}/${moduleId}/${channel}/set`;\n            msg.payload = state;\n        } else {\n            return null;\n        }\n    }\n\n    // ===== RELAY =====\n    if (subType === \"relay\") {\n        const addr = CHANNEL_COIL_MAP[channel];\n        if (addr === undefined) {\n            debugLog('modbus', `æ‰¾ä¸åˆ° Relay é€šé“ ${channel}`);\n            return null;\n        }\n\n        const state = (msg.payload === \"ON\") ? \"ON\" : \"OFF\";\n        const valHi = (msg.payload === \"ON\") ? 0xFF : 0x00;\n        const valLo = 0x00;\n        const hi = (addr >> 8) & 0xFF;\n        const lo = addr & 0xFF;\n        const frame = Buffer.from([moduleId, 0x05, hi, lo, valHi, valLo]);\n        const cmd = generalCommandBuild(frame);\n\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Relay) ===`);\n        debugLog('modbus', `Coil åœ°å€: 0x${addr.toString(16).padStart(4, '0')}`);\n        debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n\n    // ===== SINGLE =====\n    else if (subType === \"single\") {\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const speed = (state === \"OFF\") ? 0x00 : BRIGHTNESS_TIME;\n        const cmd = buildCommand(moduleId, reg, brValue, speed);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Single) ===`);\n        debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state, brightness });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n\n    // ===== DUAL =====\n    else if (subType === \"dual\") {\n        const regs = CHANNEL_REGISTER_MAP[channel];\n        if (!regs) {\n            debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        let colortemp = flow.get(`${subType}_${moduleId}_${channel}_colortemp`);\n        if (typeof colortemp !== \"number\") colortemp = DEFAULT_COLORTEMP;\n        colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n        const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const cmdBrightness = buildCommand(moduleId, regs[0], brValue);\n        const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Dual) ===`);\n        debugLog('modbus', `äº®åº¦: ${cmdBrightness.toString('hex')}`);\n        debugLog('modbus', `è‰²æº«: ${cmdColortemp.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmdBrightness, subType, moduleId, channel, state, brightness, colortemp });\n        modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, state, brightness, colortemp });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}% ${colortemp}K`\n        });\n    }\n\n    // ===== SCENE =====\n    else if (subType === \"scene\") {\n        const sceneType = parts[3];  // single, dual\n        const lights = parts[4].split(\"--\");  // 12-1--12-2\n        const state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        \n        // Scene å¿«å– key æ ¼å¼: scene_single_12-3--12-4_brightness\n        const groupBrightnessKey = `scene_${sceneType}_${parts[4]}_brightness`;\n        const groupColortempKey = `scene_${sceneType}_${parts[4]}_colortemp`;\n        const groupBrightness = flow.get(groupBrightnessKey);\n        const groupColortemp = flow.get(groupColortempKey);\n\n        debugLog('scene', `=== Scene æ§åˆ¶ ===`);\n        debugLog('scene', `å ´æ™¯é¡å‹: ${sceneType}`);\n        debugLog('scene', `ç‡ˆå…‰åˆ—è¡¨: ${lights.join(\", \")}`);\n        debugLog('scene', `ç‹€æ…‹: ${state}`);\n\n        // ç™¼é€æŒ‡ä»¤åˆ°æ¯å€‹ç‡ˆå…‰\n        for (let light of lights) {\n            const [lightId, lightChannel] = light.split(\"-\");\n            \n            // å…ˆç›´æ¥æ›´æ–°å€‹åˆ¥ç‡ˆå…‰çš„å¿«å–ï¼ˆä¸é€é MQTTï¼‰\n            if (state === \"ON\" && groupBrightness !== undefined) {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_brightness`, groupBrightness);\n                debugLog('scene', `æ›´æ–°å¿«å–: ${sceneType}_${lightId}_${lightChannel}_brightness = ${groupBrightness}`);\n            }\n            if (state === \"ON\" && groupColortemp !== undefined && sceneType === \"dual\") {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_colortemp`, groupColortemp);\n                debugLog('scene', `æ›´æ–°å¿«å–: ${sceneType}_${lightId}_${lightChannel}_colortemp = ${groupColortemp}`);\n            }\n            \n            // ç„¶å¾Œç™¼é€é–‹é—œæŒ‡ä»¤ï¼ˆæœƒä½¿ç”¨å‰›æ›´æ–°çš„å¿«å–ï¼‰\n            const lightTopic = `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/set`;\n            mqttMessages.push({ topic: lightTopic, payload: state });\n        }\n\n        // æ›´æ–°å ´æ™¯æœ¬èº«çš„ç‹€æ…‹\n        mqttMessages.push({ topic: `homeassistant/light/scene/${sceneType}/${parts[4]}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"yellow\" : \"grey\",\n            shape: \"ring\",\n            text: `Scene: ${lights.length} ç‡ˆ ${state}`\n        });\n    }\n}\n\n// ========== COVER DEVICE ==========\nelse if (deviceType === \"cover\") {\n    // æ ¼å¼: homeassistant/cover/general/12/set\n    // payload: \"1_2/3\" è¡¨ç¤ºé–‹å•Ÿ relay 1 å’Œ 2ï¼Œé—œé–‰ relay 3\n    \n    const relays = msg.payload.split(\"/\");\n    const on_relays = relays[0] ? relays[0].split(\"_\").map(Number) : [];\n    const off_relays = (relays[1] && relays[1].length > 0) ? relays[1].split(\"_\").map(Number) : [];\n\n    let output = 0x00;\n    for (let relay of on_relays) {\n        output |= (1 << (relay - 1));\n    }\n    for (let relay of off_relays) {\n        output &= ~(1 << (relay - 1));\n    }\n\n    const frame = Buffer.from([moduleId, 0x06, 0x01, 0x9b, 0x10, output]);\n    const cmd = generalCommandBuild(frame);\n\n    debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Cover) ===`);\n    debugLog('modbus', `é–‹å•Ÿ Relay: ${on_relays.join(\", \")}`);\n    debugLog('modbus', `é—œé–‰ Relay: ${off_relays.join(\", \")}`);\n    debugLog('modbus', `Bit Mask: 0b${output.toString(2).padStart(8, '0')} (0x${output.toString(16).padStart(2, '0')})`);\n    debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n    modbusMessages.push({ payload: cmd, deviceType, moduleId, on_relays, off_relays });\n\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `Cover: ON[${on_relays}] OFF[${off_relays}]`\n    });\n}\n\n\n// ========== QUERY DEVICE (æŸ¥è©¢) ==========\nelse if (deviceType === \"query\") {\n    // æ ¼å¼: homeassistant/query/{subType}/{moduleId}/{channel}\n    // subType: single, dual, relay\n    \n    const querySubType = subType;  // single, dual, relay\n    \n    debugLog('query', `=== Query æŸ¥è©¢ ===`);\n    debugLog('query', `é¡å‹: ${querySubType}, æ¨¡çµ„: ${moduleId}, é€šé“: ${channel}`);\n    \n    let frame;\n    \n    if (querySubType === \"single\" || querySubType === \"dual\") {\n        // æŸ¥è©¢ Single/Dual Light: Read Holding Registers (0x03)\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('query', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n        \n        const startReg = Array.isArray(reg) ? reg[0] : reg;  // dual å–ç¬¬ä¸€å€‹å¯„å­˜å™¨\n        const quantity = Array.isArray(reg) ? 2 : 1;  // dual è®€ 2 å€‹ï¼Œsingle è®€ 1 å€‹\n        \n        const regHi = (startReg >> 8) & 0xFF;\n        const regLo = startReg & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n        \n        frame = Buffer.from([moduleId, 0x03, regHi, regLo, qtyHi, qtyLo]);\n        \n        debugLog('query', `è®€å–å¯„å­˜å™¨: 0x${startReg.toString(16).padStart(4, '0')}, æ•¸é‡: ${quantity}`);\n    }\n    else if (querySubType === \"relay\") {\n        // æŸ¥è©¢ Relay: Read Coils (0x01)\n        const addr = CHANNEL_COIL_MAP[channel] || 0x0000;\n        const quantity = 4;  // è®€å– 4 å€‹ coils\n        \n        const addrHi = (addr >> 8) & 0xFF;\n        const addrLo = addr & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n        \n        frame = Buffer.from([moduleId, 0x01, addrHi, addrLo, qtyHi, qtyLo]);\n        \n        debugLog('query', `è®€å–ç·šåœˆ: 0x${addr.toString(16).padStart(4, '0')}, æ•¸é‡: ${quantity}`);\n    }\n    else {\n        debugLog('query', `ä¸æ”¯æ´çš„æŸ¥è©¢é¡å‹: ${querySubType}`);\n        return null;\n    }\n    \n    const cmd = generalCommandBuild(frame);\n    \n    debugLog('modbus', `=== Modbus æŸ¥è©¢æŒ‡ä»¤ ===`);\n    debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n    \n    // å°‡æŸ¥è©¢è³‡è¨Šé™„åŠ åˆ°æ¯å€‹è¨Šæ¯ä¸­ï¼Œä¾› Feedback ä½¿ç”¨\n    const queryMsg = { \n        payload: cmd, \n        deviceType: \"query\", \n        subType: querySubType, \n        moduleId, \n        channel,\n        queryInfo: { type: querySubType, channel: channel }\n    };\n    modbusMessages.push(queryMsg);\n    \n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query ${querySubType} ${moduleId}-${channel}`\n    });\n}\n\n\nelse {\n    debugLog('topic', `ä¸æ”¯æ´çš„è¨­å‚™é¡å‹: ${deviceType}`);\n    return null;\n}\n\n// è¿”å›: [Modbus æŒ‡ä»¤, MQTT ç‹€æ…‹]\nreturn [modbusMessages, mqttMessages];",
    "outputs": 2,
    "timeout": 0,
    "noerr": 0,
    "initialize": "node.warn(\"=== åˆå§‹åŒ–å®Œæ•´æ¸¬è©¦ç³»çµ± ===\");",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 2100,
    "wires": [
        [
            "d59a4d2f00fac520",
            "4f08be38e8e5a989"
        ],
        [
            "91359a179be62f4c",
            "e67cfaa863dbcbf7"
        ]
    ]
}