[
    {
        "id": "4083c014c4036df7",
        "type": "group",
        "z": "2489f740882ffd1e",
        "name": "å®Œæ•´æ•´åˆæ¸¬è©¦ï¼šLight (Single/Dual/Relay) + Cover + Scene",
        "style": {
            "label": true,
            "stroke": "#7c3aed",
            "fill": "#f3e8ff",
            "fill-opacity": "0.5"
        },
        "nodes": [
            "7b84182b40c2408a",
            "27bd656af41458c7",
            "c3642e1b2e281419",
            "7fdc77cd054beb5f",
            "eb35a4f1a8369e28",
            "3405944690501c27",
            "1301b4bfabe6d00e",
            "a2388fae33290227",
            "8ff2c6df0c7984f0",
            "2361f69cb0630c2d",
            "9506b0dd9dfd9d8c",
            "f3fd3b3a44906912",
            "cc06f2f568357a28",
            "8a1dcb4d8fb68e37",
            "a96e5c88474cb10a",
            "4e57977080ea5596",
            "8128d24c1e30c31b",
            "bfa31e824ef82cb0",
            "5c78efdf4cc08cdc",
            "748cd437883e26c9",
            "9adead2839ee4cf5",
            "9508d90a31f87e7d",
            "109a527e86772924",
            "2f06524972ea7ed5",
            "0b1b39be9f383857",
            "d1a4a99a2680edb7",
            "14ec3164167b547e"
        ],
        "x": 14,
        "y": -21,
        "w": 1292,
        "h": 648
    },
    {
        "id": "7b84182b40c2408a",
        "type": "mqtt in",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "",
        "topic": "homeassistant/+/+/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 160,
        "y": 200,
        "wires": [
            [
                "27bd656af41458c7"
            ]
        ]
    },
    {
        "id": "27bd656af41458c7",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "å®Œæ•´è™•ç†å™¨ (All Devices)",
        "func": "/**\n * å®Œæ•´è™•ç†å™¨ - æ”¯æ´æ‰€æœ‰è¨­å‚™é¡å‹\n * \n * Node ID: 50313094f488b340\n * Node Type: function\n * \n * è¼¸å‡ºï¼š\n *   Output 1: Modbus æŒ‡ä»¤ â†’ é€£æ¥åˆ° modbus_queue.jsï¼ˆå…¥éšŠï¼‰\n *   Output 2: MQTT ç‹€æ…‹   â†’ é€£æ¥åˆ° MQTT out\n * \n * æµç¨‹ï¼š\n *   MQTT In â†’ full_processor â†’ modbus_queue â†’ Serial Out\n *                                    â†‘\n *   Serial In â†’ feedback_processor â”€â”€â”˜ (dequeue)\n */\n\n// å®Œæ•´ç‰ˆè™•ç†å™¨ï¼šæ”¯æ´ Single/Dual/Relay ç‡ˆå…‰ã€Coverã€Scene\n\n// Debug æ§åˆ¶ (é€é global context è¨­å®š)\nconst debugConfig = global.get('debug_config') || {\n    topic: true,        // é¡¯ç¤ºæ”¶åˆ°çš„ Topic\n    cache: true,        // é¡¯ç¤ºå¿«å–æ“ä½œ\n    modbus: true,       // é¡¯ç¤º Modbus æŒ‡ä»¤è©³æƒ…\n    mqtt: true,         // é¡¯ç¤º MQTT ç‹€æ…‹å›å ±\n    scene: true,        // é¡¯ç¤º Scene è™•ç†\n    query: true         // é¡¯ç¤º Query æŸ¥è©¢\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nconst DEFAULT_BRIGHTNESS = 100;\nconst DEFAULT_COLORTEMP = 250;\nconst MIN_MIRED = 167;\nconst MAX_MIRED = 333;\nconst BRIGHTNESS_TIME = 0x05;\nconst CHANNEL_REGISTER_MAP = {\n    \"1\": 0x082A,\n    \"2\": 0x082B,\n    \"3\": 0x082C,\n    \"4\": 0x082D,\n    \"a\": [0x082A, 0x082B],\n    \"b\": [0x082C, 0x082D]\n};\nconst CHANNEL_COIL_MAP = {\n    \"1\": 0x0000,\n    \"2\": 0x0001,\n    \"3\": 0x0002,\n    \"4\": 0x0003\n};\n\nfunction generalCommandBuild(frame) {\n    function crc16(buf) {\n        let crc = 0xFFFF;\n        for (const b of buf) {\n            crc ^= b;\n            for (let i = 0; i < 8; i++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        return crc;\n    }\n    const crc = crc16(frame);\n    return Buffer.concat([frame, Buffer.from([crc & 0xFF, (crc >> 8) & 0xFF])]);\n}\n\nfunction clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\n\nfunction buildCommand(moduleId, reg, value, speed = 0x05) {\n    const hi = (reg >> 8) & 0xFF;\n    const lo = reg & 0xFF;\n    const cmd = Buffer.from([moduleId, 0x06, hi, lo, speed, value]);\n    return generalCommandBuild(cmd);\n}\n\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light, cover, memory\nconst subType = parts[2];        // single, dual, relay, scene, general\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\ndebugLog('topic', `=== æ”¶åˆ°è¨Šæ¯ ===`);\ndebugLog('topic', `Topic: ${msg.topic}`);\ndebugLog('topic', `Payload: ${msg.payload}`);\ndebugLog('topic', `Device: ${deviceType}, SubType: ${subType}, Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\n\n// ========== MEMORY DEVICE (è¨˜æ†¶åŠŸèƒ½ + æŸ¥è©¢) ==========\nif (deviceType === \"memory\") {\n    const sceneId = parts[2];      // 0x02, 0x03, query, etc.\n    const operation = parts[3];    // 0x01 (ON), 0x02 (OFF), all\n    const action = parts[4];       // save, execute, get\n\n    // ===== MEMORY QUERY (æŸ¥è©¢æ‰€æœ‰è¨˜æ†¶) =====\n    if (sceneId === \"query\" && operation === \"all\") {\n        // æ ¼å¼: homeassistant/memory/query/all\n        debugLog('cache', `=== æŸ¥è©¢æ‰€æœ‰è¨˜æ†¶ç‹€æ…‹ ===`);\n\n        const SCENE_NAMES = {\n            \"0x02\": \"æœƒè­°å®¤\",\n            \"0x03\": \"å…¬å…±å€\",\n            \"0x04\": \"æˆ¶å¤–\",\n            \"0x05\": \"H40äºŒæ¨“\"\n        };\n\n        const OPERATION_NAMES = {\n            \"0x01\": \"ON\",\n            \"0x02\": \"OFF\"\n        };\n\n        let allMemories = [];\n        let totalCount = 0;\n\n        // æª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„è¨˜æ†¶çµ„åˆ\n        for (const sceneId of Object.keys(SCENE_NAMES)) {\n            for (const operation of Object.keys(OPERATION_NAMES)) {\n                const memoryKey = `memory_${sceneId}_${operation}`;\n                const memoryRecord = flow.get(memoryKey);\n\n                if (memoryRecord) {\n                    const deviceCount = Object.keys(memoryRecord.devices || {}).length;\n                    const sceneName = SCENE_NAMES[sceneId];\n                    const opName = OPERATION_NAMES[operation];\n\n                    allMemories.push({\n                        key: memoryKey,\n                        scene_id: sceneId,\n                        operation: operation,\n                        scene_name: memoryRecord.scene_name,\n                        display_name: `${sceneName}_${opName}`,\n                        device_count: deviceCount,\n                        timestamp: memoryRecord.timestamp,\n                        devices: memoryRecord.devices\n                    });\n\n                    totalCount++;\n\n                    debugLog('cache', `âœ… ${memoryKey}: ${memoryRecord.scene_name} (${deviceCount}å€‹è¨­å‚™) - ${memoryRecord.timestamp}`);\n                }\n            }\n        }\n\n        if (totalCount === 0) {\n            debugLog('cache', `âš ï¸ æ²’æœ‰æ‰¾åˆ°ä»»ä½•è¨˜æ†¶`);\n        } else {\n            debugLog('cache', `ğŸ“Š ç¸½å…±æ‰¾åˆ° ${totalCount} çµ„è¨˜æ†¶`);\n        }\n\n        // è¼¸å‡ºè¨˜æ†¶æ‘˜è¦\n        const summary = {\n            total_count: totalCount,\n            memories: allMemories.map(m => ({\n                key: m.key,\n                display_name: m.display_name,\n                device_count: m.device_count,\n                timestamp: m.timestamp\n            })),\n            timestamp: new Date().toISOString()\n        };\n\n        node.status({\n            fill: \"blue\",\n            shape: \"ring\",\n            text: `è¨˜æ†¶æŸ¥è©¢: ${totalCount} çµ„`\n        });\n\n        // è¿”å›å®Œæ•´çš„è¨˜æ†¶è³‡æ–™ä¾› Debug æª¢è¦–\n        return [[{\n            payload: summary,\n            allMemories: allMemories  // å®Œæ•´è³‡æ–™ï¼ˆåŒ…å«è¨­å‚™è©³æƒ…ï¼‰\n        }], []];\n    }\n\n    // ===== MEMORY SAVE (å„²å­˜è¨˜æ†¶) =====\n    if (action === \"save\") {\n        // æ ¼å¼: homeassistant/memory/{sceneId}/{operation}/save/set\n        // payload: JSON { scene_name, devices, timestamp }\n\n        // å„²å­˜è¨˜æ†¶ï¼šè®€å–æ‰€æœ‰è¨­å‚™ç•¶å‰ç‹€æ…‹ä¸¦å„²å­˜\n        let memoryData;\n        try {\n            // å¦‚æœ payload å·²ç¶“æ˜¯ objectï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦å‰‡è§£æ JSON\n            if (typeof msg.payload === 'object' && msg.payload !== null) {\n                memoryData = msg.payload;\n            } else {\n                memoryData = JSON.parse(msg.payload);\n            }\n        } catch (e) {\n            debugLog('topic', `è¨˜æ†¶æŒ‡ä»¤ JSON è§£æå¤±æ•—: ${e.message}`);\n            return null;\n        }\n\n        const devices = memoryData.devices || [];\n        const memoryKey = `memory_${sceneId}_${operation}`;\n        const savedStates = {};\n\n        debugLog('cache', `=== å„²å­˜è¨˜æ†¶ ${memoryKey} ===`);\n        debugLog('cache', `å ´æ™¯åç¨±: ${memoryData.scene_name}`);\n        debugLog('cache', `è¨­å‚™æ•¸é‡: ${devices.length}`);\n\n        // è®€å–æ¯å€‹è¨­å‚™çš„ç•¶å‰ç‹€æ…‹\n        for (const deviceTopic of devices) {\n            const deviceParts = deviceTopic.split(\"/\");\n            const devType = deviceParts[1];        // light\n            const devSubType = deviceParts[2];     // single, dual\n            const devModuleId = deviceParts[3];    // 13, 14\n            const devChannel = deviceParts[4];     // 1, a, b\n\n            if (devType === \"light\") {\n                const stateKey = `${devSubType}_${devModuleId}_${devChannel}_state`;\n                const brightnessKey = `${devSubType}_${devModuleId}_${devChannel}_brightness`;\n                const colortempKey = `${devSubType}_${devModuleId}_${devChannel}_colortemp`;\n\n                const state = flow.get(stateKey) || \"OFF\";\n                const brightness = flow.get(brightnessKey) || DEFAULT_BRIGHTNESS;\n                const colortemp = flow.get(colortempKey) || DEFAULT_COLORTEMP;\n\n                savedStates[deviceTopic] = {\n                    state,\n                    brightness,\n                    colortemp: devSubType === \"dual\" ? colortemp : undefined\n                };\n\n                debugLog('cache', `  ${deviceTopic}: ${state} ${brightness}%${devSubType === 'dual' ? ` ${colortemp}K` : ''}`);\n            }\n        }\n\n        // å„²å­˜è¨˜æ†¶è³‡æ–™\n        const memoryRecord = {\n            scene_name: memoryData.scene_name,\n            timestamp: memoryData.timestamp || new Date().toISOString(),\n            devices: savedStates\n        };\n\n        flow.set(memoryKey, memoryRecord);\n        debugLog('cache', `âœ… è¨˜æ†¶å·²å„²å­˜: ${memoryKey}`);\n\n        node.status({\n            fill: \"blue\",\n            shape: \"dot\",\n            text: `è¨˜æ†¶: ${memoryData.scene_name} (${devices.length}å€‹è¨­å‚™)`\n        });\n\n        return null;\n    }\n}\n\n// ========== SCENE DEVICE (å ´æ™¯åŸ·è¡Œï¼ŒåŒ…å«è¨˜æ†¶åŸ·è¡Œ) ==========\nif (deviceType === \"scene\") {\n    // æ ¼å¼: homeassistant/scene/{sceneId}/{operation}/execute/set\n    const sceneId = parts[2];      // 0x02, 0x03, etc.\n    const operation = parts[3];    // 0x01 (ON), 0x02 (OFF)\n    const action = parts[4];       // execute\n\n    if (action === \"execute\") {\n        // åŸ·è¡Œè¨˜æ†¶å ´æ™¯\n        const memoryKey = `memory_${sceneId}_${operation}`;\n        const memoryRecord = flow.get(memoryKey);\n\n        if (!memoryRecord) {\n            debugLog('scene', `âš ï¸ æ‰¾ä¸åˆ°è¨˜æ†¶: ${memoryKey}`);\n            return null;\n        }\n\n        debugLog('scene', `=== åŸ·è¡Œè¨˜æ†¶å ´æ™¯ ${memoryKey} ===`);\n        debugLog('scene', `å ´æ™¯åç¨±: ${memoryRecord.scene_name}`);\n        debugLog('scene', `å„²å­˜æ™‚é–“: ${memoryRecord.timestamp}`);\n\n        const devices = memoryRecord.devices || {};\n        const deviceTopics = Object.keys(devices);\n\n        // å°æ¯å€‹è¨­å‚™ç™¼é€ MQTT æŒ‡ä»¤\n        for (const deviceTopic of deviceTopics) {\n            const savedState = devices[deviceTopic];\n            const deviceParts = deviceTopic.split(\"/\");\n            const devSubType = deviceParts[2];     // single, dual\n            const devModuleId = deviceParts[3];\n            const devChannel = deviceParts[4];\n\n            // å…ˆæ›´æ–°å¿«å–\n            const stateKey = `${devSubType}_${devModuleId}_${devChannel}_state`;\n            const brightnessKey = `${devSubType}_${devModuleId}_${devChannel}_brightness`;\n\n            flow.set(stateKey, savedState.state);\n            flow.set(brightnessKey, savedState.brightness);\n\n            if (devSubType === \"dual\" && savedState.colortemp !== undefined) {\n                const colortempKey = `${devSubType}_${devModuleId}_${devChannel}_colortemp`;\n                flow.set(colortempKey, savedState.colortemp);\n            }\n\n            debugLog('scene', `  ${deviceTopic}: ${savedState.state} ${savedState.brightness}%${savedState.colortemp ? ` ${savedState.colortemp}K` : ''}`);\n\n            // ç™¼é€æ§åˆ¶æŒ‡ä»¤\n            mqttMessages.push({\n                topic: `${deviceTopic}/set`,\n                payload: savedState.state\n            });\n        }\n\n        node.status({\n            fill: \"yellow\",\n            shape: \"ring\",\n            text: `åŸ·è¡Œè¨˜æ†¶: ${memoryRecord.scene_name} (${deviceTopics.length}å€‹è¨­å‚™)`\n        });\n\n        // ç›´æ¥è¿”å› MQTT è¨Šæ¯ï¼Œä¸éœ€è¦ Modbus\n        return [[], mqttMessages];\n    }\n}\n\n// ========== LIGHT DEVICE ==========\nif (deviceType === \"light\") {\n    const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n\n    // è™•ç† set/brightness å’Œ set/colortemp\n    if (parts.length >= 7 && parts[5] === \"set\") {\n        const attribute = parts[6];\n        // Scene çš„ key æ ¼å¼ä¸åŒï¼šscene_single_12-3--12-4_brightness\n        let key;\n        if (subType === \"scene\") {\n            key = `scene_${parts[3]}_${parts[4]}_${attribute}`;\n        } else {\n            key = `${subType}_${moduleId}_${channel}_${attribute}`;\n        }\n        const val = Number(msg.payload);\n\n        if (!isNaN(val)) {\n            flow.set(key, val);\n            debugLog('cache', `å„²å­˜ ${key} = ${val}`);\n        }\n\n        if (attribute === \"brightness\" || attribute === \"colortemp\") {\n            // å°æ–¼ dual ç‡ˆå…‰çš„è‰²æº«èª¿æ•´ï¼Œåªç™¼é€è‰²æº«æŒ‡ä»¤ï¼Œä¸è§¸ç™¼å®Œæ•´æ§åˆ¶æµç¨‹\n            if (subType === \"dual\" && attribute === \"colortemp\") {\n                const regs = CHANNEL_REGISTER_MAP[channel];\n                if (!regs) {\n                    debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n                    return null;\n                }\n\n                let colortemp = val;\n                colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n                const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\n                const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n                debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Dual Colortemp Only) ===`);\n                debugLog('modbus', `è‰²æº«: ${cmdColortemp.toString('hex')}`);\n\n                modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, colortemp });\n\n                node.status({\n                    fill: \"yellow\",\n                    shape: \"dot\",\n                    text: `${moduleId}-${channel}: Colortemp ${colortemp}K`\n                });\n\n                return [modbusMessages, []];\n            }\n\n            // äº®åº¦æˆ–è‰²æº«è®Šæ›´æ™‚ï¼Œä¿æŒç•¶å‰é–‹é—œç‹€æ…‹ä¸è®Š\n            // 0% ä¸æœƒè‡ªå‹•è®Šæˆ OFFï¼Œéœ€è¦æ˜ç¢ºç™¼é€ OFF æŒ‡ä»¤æ‰æœƒé—œé–‰\n            const stateKey = `${subType}_${moduleId}_${channel}_state`;\n            const state = flow.get(stateKey) || \"ON\";\n            msg.topic = `homeassistant/light/${subType}/${moduleId}/${channel}/set`;\n            msg.payload = state;\n        } else {\n            return null;\n        }\n    }\n\n    // ===== RELAY =====\n    if (subType === \"relay\") {\n        const addr = CHANNEL_COIL_MAP[channel];\n        if (addr === undefined) {\n            debugLog('modbus', `æ‰¾ä¸åˆ° Relay é€šé“ ${channel}`);\n            return null;\n        }\n\n        const state = (msg.payload === \"ON\") ? \"ON\" : \"OFF\";\n        const valHi = (msg.payload === \"ON\") ? 0xFF : 0x00;\n        const valLo = 0x00;\n        const hi = (addr >> 8) & 0xFF;\n        const lo = addr & 0xFF;\n        const frame = Buffer.from([moduleId, 0x05, hi, lo, valHi, valLo]);\n        const cmd = generalCommandBuild(frame);\n\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Relay) ===`);\n        debugLog('modbus', `Coil åœ°å€: 0x${addr.toString(16).padStart(4, '0')}`);\n        debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n\n    // ===== SINGLE =====\n    else if (subType === \"single\") {\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const speed = (state === \"OFF\") ? 0x00 : BRIGHTNESS_TIME;\n        const cmd = buildCommand(moduleId, reg, brValue, speed);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Single) ===`);\n        debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state, brightness });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n\n    // ===== DUAL =====\n    else if (subType === \"dual\") {\n        const regs = CHANNEL_REGISTER_MAP[channel];\n        if (!regs) {\n            debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        let colortemp = flow.get(`${subType}_${moduleId}_${channel}_colortemp`);\n        if (typeof colortemp !== \"number\") colortemp = DEFAULT_COLORTEMP;\n        colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n        const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const cmdBrightness = buildCommand(moduleId, regs[0], brValue);\n        const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Dual) ===`);\n        debugLog('modbus', `äº®åº¦: ${cmdBrightness.toString('hex')}`);\n        debugLog('modbus', `è‰²æº«: ${cmdColortemp.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmdBrightness, subType, moduleId, channel, state, brightness, colortemp });\n        modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, state, brightness, colortemp });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}% ${colortemp}K`\n        });\n    }\n\n    // ===== SCENE =====\n    else if (subType === \"scene\") {\n        const sceneType = parts[3];  // single, dual\n        const lights = parts[4].split(\"--\");  // 12-1--12-2\n        const state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n\n        // Scene å¿«å– key æ ¼å¼: scene_single_12-3--12-4_brightness\n        const groupBrightnessKey = `scene_${sceneType}_${parts[4]}_brightness`;\n        const groupColortempKey = `scene_${sceneType}_${parts[4]}_colortemp`;\n        const groupBrightness = flow.get(groupBrightnessKey);\n        const groupColortemp = flow.get(groupColortempKey);\n\n        debugLog('scene', `=== Scene æ§åˆ¶ ===`);\n        debugLog('scene', `å ´æ™¯é¡å‹: ${sceneType}`);\n        debugLog('scene', `ç‡ˆå…‰åˆ—è¡¨: ${lights.join(\", \")}`);\n        debugLog('scene', `ç‹€æ…‹: ${state}`);\n\n        // ç™¼é€æŒ‡ä»¤åˆ°æ¯å€‹ç‡ˆå…‰\n        for (let light of lights) {\n            const [lightId, lightChannel] = light.split(\"-\");\n\n            // å…ˆç›´æ¥æ›´æ–°å€‹åˆ¥ç‡ˆå…‰çš„å¿«å–ï¼ˆä¸é€é MQTTï¼‰\n            if (state === \"ON\" && groupBrightness !== undefined) {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_brightness`, groupBrightness);\n                debugLog('scene', `æ›´æ–°å¿«å–: ${sceneType}_${lightId}_${lightChannel}_brightness = ${groupBrightness}`);\n            }\n            if (state === \"ON\" && groupColortemp !== undefined && sceneType === \"dual\") {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_colortemp`, groupColortemp);\n                debugLog('scene', `æ›´æ–°å¿«å–: ${sceneType}_${lightId}_${lightChannel}_colortemp = ${groupColortemp}`);\n            }\n\n            // ç„¶å¾Œç™¼é€é–‹é—œæŒ‡ä»¤ï¼ˆæœƒä½¿ç”¨å‰›æ›´æ–°çš„å¿«å–ï¼‰\n            const lightTopic = `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/set`;\n            mqttMessages.push({ topic: lightTopic, payload: state });\n        }\n\n        // æ›´æ–°å ´æ™¯æœ¬èº«çš„ç‹€æ…‹\n        mqttMessages.push({ topic: `homeassistant/light/scene/${sceneType}/${parts[4]}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"yellow\" : \"grey\",\n            shape: \"ring\",\n            text: `Scene: ${lights.length} ç‡ˆ ${state}`\n        });\n    }\n}\n\n// ========== COVER DEVICE ==========\nelse if (deviceType === \"cover\") {\n    // æ ¼å¼: homeassistant/cover/general/12/set\n    // payload: \"1_2/3\" è¡¨ç¤ºé–‹å•Ÿ relay 1 å’Œ 2ï¼Œé—œé–‰ relay 3\n\n    const relays = msg.payload.split(\"/\");\n    const on_relays = relays[0] ? relays[0].split(\"_\").map(Number) : [];\n    const off_relays = (relays[1] && relays[1].length > 0) ? relays[1].split(\"_\").map(Number) : [];\n\n    let output = 0x00;\n    for (let relay of on_relays) {\n        output |= (1 << (relay - 1));\n    }\n    for (let relay of off_relays) {\n        output &= ~(1 << (relay - 1));\n    }\n\n    const frame = Buffer.from([moduleId, 0x06, 0x01, 0x9b, 0x10, output]);\n    const cmd = generalCommandBuild(frame);\n\n    debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Cover) ===`);\n    debugLog('modbus', `é–‹å•Ÿ Relay: ${on_relays.join(\", \")}`);\n    debugLog('modbus', `é—œé–‰ Relay: ${off_relays.join(\", \")}`);\n    debugLog('modbus', `Bit Mask: 0b${output.toString(2).padStart(8, '0')} (0x${output.toString(16).padStart(2, '0')})`);\n    debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n    modbusMessages.push({ payload: cmd, deviceType, moduleId, on_relays, off_relays });\n\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `Cover: ON[${on_relays}] OFF[${off_relays}]`\n    });\n}\n\n// ========== HVAC DEVICE (ç©ºèª¿æ§åˆ¶) ==========\nelse if (deviceType === \"hvac\") {\n    // æ ¼å¼: homeassistant/hvac/{s200Id}/{hvacId}/{action}/set\n    // ç¯„ä¾‹: homeassistant/hvac/200/1/mode/set (payload: \"cool\")\n    //       homeassistant/hvac/200/1/temperature/set (payload: 25)\n    //       homeassistant/hvac/200/1/fan/set (payload: \"auto\")\n\n    const s200Id = parseInt(parts[2]);      // S200 æ¨¡çµ„ ID (é€šå¸¸æ˜¯ 200)\n    const hvacId = parseInt(parts[3]);      // HVAC è¨­å‚™ ID (1, 2, 3...)\n    const hvacAction = parts[4];            // mode, fan, temperature\n    const payload = msg.payload;\n\n    const baseAddress = 0x100;\n    const speed = 0x00; // HVAC çµ±ä¸€ä½¿ç”¨ 0x00 (ç«‹å³åŸ·è¡Œ)\n\n    const modeMap = {\n        \"cool\": 0,\n        \"heat\": 1,\n        \"dry\": 2,\n        \"fan_only\": 3,\n        \"off\": 4\n    };\n\n    const fanModeMap = {\n        \"auto\": 0,\n        \"low\": 1,\n        \"medium\": 2,\n        \"high\": 3\n    };\n\n    let register, value;\n\n    debugLog('topic', `=== HVAC æ§åˆ¶ ===`);\n    debugLog('topic', `S200 ID: ${s200Id}, HVAC ID: ${hvacId}, å‹•ä½œ: ${hvacAction}, å€¼: ${payload}`);\n\n    switch (hvacAction) {\n        case \"mode\":\n            register = baseAddress + hvacId * 8 + 1;\n            value = modeMap[payload];\n            debugLog('modbus', `æ¨¡å¼è¨­å®š: ${payload} -> ${value}`);\n            break;\n\n        case \"fan\":\n            register = baseAddress + hvacId * 8 + 2;\n            value = fanModeMap[payload];\n            debugLog('modbus', `é¢¨é€Ÿè¨­å®š: ${payload} -> ${value}`);\n            break;\n\n        case \"temperature\":\n            register = baseAddress + hvacId * 8 + 3;\n            value = parseFloat(payload);\n            debugLog('modbus', `æº«åº¦è¨­å®š: ${value}Â°C`);\n            break;\n\n        default:\n            debugLog('topic', `æœªçŸ¥çš„ HVAC å‹•ä½œ: ${hvacAction}`);\n            return null;\n    }\n\n    if (value === undefined || value === null) {\n        debugLog('topic', `ç„¡æ•ˆçš„ HVAC å€¼: ${payload}`);\n        return null;\n    }\n\n    const regHi = (register >> 8) & 0xFF;\n    const regLo = register & 0xFF;\n\n    // s200Id, 0x06, regHi, regLo, speed, value\n    const frame = Buffer.from([\n        s200Id,\n        0x06,\n        regHi,\n        regLo,\n        speed,\n        value\n    ]);\n\n    const cmd = generalCommandBuild(frame);\n\n    debugLog('modbus', `=== Modbus æŒ‡ä»¤ (HVAC) ===`);\n    debugLog('modbus', `å¯„å­˜å™¨: 0x${register.toString(16).padStart(4, '0')}`);\n    debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n    modbusMessages.push({ payload: cmd, deviceType, s200Id, hvacId, hvacAction, value });\n\n    node.status({\n        fill: \"orange\",\n        shape: \"dot\",\n        text: `HVAC ${hvacId}: ${hvacAction}=${payload}`\n    });\n}\n\n\n// ========== QUERY DEVICE (æŸ¥è©¢) ==========\nelse if (deviceType === \"query\") {\n    // æ ¼å¼: homeassistant/query/{subType}/{moduleId}/{channel}\n    // subType: single, dual, relay\n\n    const querySubType = subType;  // single, dual, relay\n\n    debugLog('query', `=== Query æŸ¥è©¢ ===`);\n    debugLog('query', `é¡å‹: ${querySubType}, æ¨¡çµ„: ${moduleId}, é€šé“: ${channel}`);\n\n    let frame;\n\n    if (querySubType === \"single\" || querySubType === \"dual\") {\n        // æŸ¥è©¢ Single/Dual Light: Read Holding Registers (0x03)\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('query', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n\n        const startReg = Array.isArray(reg) ? reg[0] : reg;  // dual å–ç¬¬ä¸€å€‹å¯„å­˜å™¨\n        const quantity = Array.isArray(reg) ? 2 : 1;  // dual è®€ 2 å€‹ï¼Œsingle è®€ 1 å€‹\n\n        const regHi = (startReg >> 8) & 0xFF;\n        const regLo = startReg & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n\n        frame = Buffer.from([moduleId, 0x03, regHi, regLo, qtyHi, qtyLo]);\n\n        debugLog('query', `è®€å–å¯„å­˜å™¨: 0x${startReg.toString(16).padStart(4, '0')}, æ•¸é‡: ${quantity}`);\n    }\n    else if (querySubType === \"relay\") {\n        // æŸ¥è©¢ Relay: Read Coils (0x01)\n        const addr = CHANNEL_COIL_MAP[channel] || 0x0000;\n        const quantity = 4;  // è®€å– 4 å€‹ coils\n\n        const addrHi = (addr >> 8) & 0xFF;\n        const addrLo = addr & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n\n        frame = Buffer.from([moduleId, 0x01, addrHi, addrLo, qtyHi, qtyLo]);\n\n        debugLog('query', `è®€å–ç·šåœˆ: 0x${addr.toString(16).padStart(4, '0')}, æ•¸é‡: ${quantity}`);\n    }\n    else {\n        debugLog('query', `ä¸æ”¯æ´çš„æŸ¥è©¢é¡å‹: ${querySubType}`);\n        return null;\n    }\n\n    const cmd = generalCommandBuild(frame);\n\n    debugLog('modbus', `=== Modbus æŸ¥è©¢æŒ‡ä»¤ ===`);\n    debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n    // å°‡æŸ¥è©¢è³‡è¨Šé™„åŠ åˆ°æ¯å€‹è¨Šæ¯ä¸­ï¼Œä¾› Feedback ä½¿ç”¨\n    const queryMsg = {\n        payload: cmd,\n        deviceType: \"query\",\n        subType: querySubType,\n        moduleId,\n        channel,\n        queryInfo: { type: querySubType, channel: channel }\n    };\n    modbusMessages.push(queryMsg);\n\n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query ${querySubType} ${moduleId}-${channel}`\n    });\n}\n\n\nelse {\n    debugLog('topic', `ä¸æ”¯æ´çš„è¨­å‚™é¡å‹: ${deviceType}`);\n    return null;\n}\n\n// è¿”å›: [Modbus æŒ‡ä»¤, MQTT ç‹€æ…‹]\nreturn [modbusMessages, mqttMessages];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "node.warn(\"=== åˆå§‹åŒ–å®Œæ•´æ¸¬è©¦ç³»çµ± ===\");",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 140,
        "wires": [
            [
                "c3642e1b2e281419",
                "4e57977080ea5596",
                "d1a4a99a2680edb7"
            ],
            [
                "a2388fae33290227",
                "1301b4bfabe6d00e"
            ],
            []
        ]
    },
    {
        "id": "c3642e1b2e281419",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "Modbus æŒ‡ä»¤",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 60,
        "wires": []
    },
    {
        "id": "7fdc77cd054beb5f",
        "type": "tcp request",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "TCP â†’ Modbus",
        "server": "192.168.1.229",
        "port": "1030",
        "out": "time",
        "ret": "buffer",
        "splitc": "0",
        "newline": "",
        "trim": false,
        "tls": "",
        "x": 900,
        "y": 100,
        "wires": [
            [
                "eb35a4f1a8369e28"
            ]
        ]
    },
    {
        "id": "eb35a4f1a8369e28",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "Feedback è™•ç†å™¨ + ç‹€æ…‹è§£æ",
        "func": "// å®Œæ•´ Feedback è™•ç†å™¨ï¼šè§£æ Modbus å›æ‡‰ä¸¦ç™¼å¸ƒ MQTT ç‹€æ…‹\n\n// Debug æ§åˆ¶\nconst debugConfig = global.get('debug_config') || {\n    topic: true,\n    cache: true,\n    modbus: true,\n    mqtt: true,\n    scene: true,\n    query: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nfunction verifyCRC(buf) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buf.length - 2; i++) {\n        crc ^= buf[i];\n        for (let j = 0; j < 8; j++) {\n            crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n        }\n    }\n    const lo = crc & 0xFF;\n    const hi = (crc >> 8) & 0xFF;\n    return lo === buf[buf.length - 2] && hi === buf[buf.length - 1];\n}\n\n// ç”¢ç”Ÿ dequeue è¨Šæ¯çš„è¼”åŠ©å‡½æ•¸\nfunction makeDequeueMsg() {\n    return { topic: \"modbus/queue/dequeue\", payload: \"next\" };\n}\n\nconst buf = msg.payload;\n\nif (!Buffer.isBuffer(buf) || buf.length < 5) {\n    debugLog('modbus', \"å›æ‡‰æ ¼å¼éŒ¯èª¤\");\n    return null;  // ä¸æ˜¯æœ‰æ•ˆçš„ Modbus è³‡æ–™ï¼Œä¸è§¸ç™¼ dequeue\n}\n\n// éæ¿¾ HMI è³‡æ–™ (é–‹é ­æ˜¯ 0xEE)\nif (buf[0] === 0xEE) {\n    debugLog('modbus', \"ç•¥é HMI è³‡æ–™ (0xEE é–‹é ­)\");\n    return null;  // HMI è³‡æ–™ï¼Œä¸è§¸ç™¼ dequeue\n}\n\nif (!verifyCRC(buf)) {\n    debugLog('modbus', \"CRC é©—è­‰å¤±æ•—ï¼Œè§¸ç™¼ä¸‹ä¸€å€‹æŒ‡ä»¤\");\n    debugLog('modbus', `è³‡æ–™: ${buf.toString('hex')}`);\n    // CRC å¤±æ•—ä»è§¸ç™¼ dequeueï¼Œé¿å…ä½‡åˆ—å¡ä½\n    return [null, null, makeDequeueMsg()];\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\n\ndebugLog('modbus', `=== Modbus å›æ‡‰ ===`);\ndebugLog('modbus', `æ¨¡çµ„ID: ${moduleId}`);\ndebugLog('modbus', `åŠŸèƒ½ç¢¼: 0x${funcCode.toString(16).padStart(2, '0')}`);\n\nconst CHANNEL_REGISTER_MAP = {\n    0x082A: { type: \"single\", channel: \"1\" },\n    0x082B: { type: \"single\", channel: \"2\" },\n    0x082C: { type: \"single\", channel: \"3\" },\n    0x082D: { type: \"single\", channel: \"4\" }\n};\n\nconst DUAL_REGISTER_MAP = {\n    0x082A: { type: \"dual\", channel: \"a\", attribute: \"brightness\" },\n    0x082B: { type: \"dual\", channel: \"a\", attribute: \"colortemp\" },\n    0x082C: { type: \"dual\", channel: \"b\", attribute: \"brightness\" },\n    0x082D: { type: \"dual\", channel: \"b\", attribute: \"colortemp\" }\n};\n\nconst RELAY_COIL_MAP = {\n    0x0000: { channel: \"1\" },\n    0x0001: { channel: \"2\" },\n    0x0002: { channel: \"3\" },\n    0x0003: { channel: \"4\" }\n};\n\nlet mqttMessages = [];\n\n// ===== 0x06 Write Single Register (Single/Dual Light) =====\nif (funcCode === 0x06) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const speedOrCoil = buf[4];\n    const valueOrCoil = buf[5];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `å¯„å­˜å™¨: 0x${register.toString(16).padStart(4, '0')}, æ•¸å€¼: ${valueOrCoil}`);\n    \n    const registerInfo = CHANNEL_REGISTER_MAP[register] || DUAL_REGISTER_MAP[register];\n    \n    if (registerInfo) {\n        const { type, channel, attribute } = registerInfo;\n        const brightness = valueOrCoil;  // æœ€å¾Œä¸€å€‹ byte æ˜¯äº®åº¦å€¼\n        const state = brightness > 0 ? \"ON\" : \"OFF\";\n        \n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `=== è§£æ ${type.toUpperCase()} ç‡ˆå…‰ ===`);\n        debugLog('modbus', `é€šé“: ${channel}, ç‹€æ…‹: ${state}, äº®åº¦: ${brightness}`);\n        \n        if (type === \"single\") {\n            // Single Light: ç™¼å¸ƒç‹€æ…‹å’Œäº®åº¦\n            mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n            if (state === \"ON\") {\n                mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            }\n            \n            // æ›´æ–°å¿«å–ï¼šOFF æ™‚ä¸æ›´æ–°äº®åº¦å¿«å–ï¼Œä¿ç•™ä¸Šæ¬¡çš„äº®åº¦å€¼\n            flow.set(`single_${moduleId}_${channel}_state`, state);\n            if (brightness > 0) {\n                flow.set(`single_${moduleId}_${channel}_brightness`, brightness);\n                debugLog('cache', `æ›´æ–°äº®åº¦å¿«å–: single_${moduleId}_${channel}_brightness = ${brightness}`);\n            } else {\n                debugLog('cache', `äº®åº¦ç‚º 0ï¼Œä¿ç•™åŸå¿«å–å€¼: ${flow.get(`single_${moduleId}_${channel}_brightness`)}`);\n            }\n            \n            debugLog('mqtt', `ç™¼å¸ƒç‹€æ…‹: ${baseTopic}/state = ${state}`);\n            if (state === \"ON\") {\n                debugLog('mqtt', `ç™¼å¸ƒäº®åº¦: ${baseTopic}/brightness = ${brightness}`);\n            }\n        } else if (type === \"dual\") {\n            // Dual Light: åˆ†åˆ¥è™•ç†äº®åº¦å’Œè‰²æº«\n            if (attribute === \"brightness\") {\n                mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n                if (state === \"ON\") {\n                    mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n                }\n                flow.set(`dual_${moduleId}_${channel}_state`, state);\n                // OFF æ™‚ä¸æ›´æ–°äº®åº¦å¿«å–ï¼Œä¿ç•™ä¸Šæ¬¡çš„äº®åº¦å€¼\n                if (brightness > 0) {\n                    flow.set(`dual_${moduleId}_${channel}_brightness`, brightness);\n                    debugLog('cache', `æ›´æ–°äº®åº¦å¿«å–: dual_${moduleId}_${channel}_brightness = ${brightness}`);\n                } else {\n                    debugLog('cache', `äº®åº¦ç‚º 0ï¼Œä¿ç•™åŸå¿«å–å€¼: ${flow.get(`dual_${moduleId}_${channel}_brightness`)}`);\n                }\n                \n                debugLog('mqtt', `ç™¼å¸ƒç‹€æ…‹: ${baseTopic}/state = ${state}`);\n            } else if (attribute === \"colortemp\") {\n                // è‰²æº«ç™¾åˆ†æ¯”è½‰å› mired\n                const ctPercent = valueOrCoil;\n                const MIN_MIRED = 167;\n                const MAX_MIRED = 333;\n                const colortemp = Math.round(MAX_MIRED - (ctPercent / 100) * (MAX_MIRED - MIN_MIRED));\n                \n                mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n                flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n                \n                debugLog('mqtt', `ç™¼å¸ƒè‰²æº«: ${baseTopic}/colortemp = ${colortemp} mired (${ctPercent}%)`);\n            }\n        }\n        \n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${type} ${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n}\n\n// ===== 0x05 Write Single Coil (Relay) =====\nelse if (funcCode === 0x05) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const speedOrCoil = buf[4];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `Coil: 0x${register.toString(16).padStart(4, '0')}`);\n    \n    const coilInfo = RELAY_COIL_MAP[register];\n    \n    if (coilInfo) {\n        const { channel } = coilInfo;\n        const state = speedOrCoil === 0xFF ? \"ON\" : \"OFF\";  // 0xFF00 = ON, 0x0000 = OFF\n        \n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `=== è§£æ RELAY ===`);\n        debugLog('modbus', `é€šé“: ${channel}, ç‹€æ…‹: ${state}`);\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        debugLog('mqtt', `ç™¼å¸ƒç‹€æ…‹: ${baseTopic}/state = ${state}`);\n        \n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"ring\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n}\n\n// ===== HVAC å›æ‡‰è™•ç† (S200 ç©ºèª¿æ¨¡çµ„ï¼Œæ”¯æ´å‹•æ…‹æ¨¡çµ„ ID 0-255) =====\n// æ ¼å¼: [Module_ID] [0x03] [ByteCount] [Power Hi] [Power Lo] [Mode Hi] [Mode Lo] [Fan Hi] [Fan Lo] [Temp Hi] [Temp Lo] [CurrTemp Hi] [CurrTemp Lo] [0x00] [HVAC_ID*8] [CRC Lo] [CRC Hi]\n// âš ï¸ å¿…é ˆåœ¨ç‡ˆå…‰æŸ¥è©¢ä¹‹å‰æª¢æŸ¥ï¼Œå› ç‚ºéƒ½æ˜¯ 0x03 åŠŸèƒ½ç¢¼\nelse if (funcCode === 0x03 && buf.length === 17) {\n    // HVAC å›æ‡‰ç‰¹å¾µ: åŠŸèƒ½ç¢¼ 0x03, é•·åº¦ 17 bytes\n    debugLog('modbus', `=== HVAC å›æ‡‰ (æ¨¡çµ„ ID: ${moduleId}) ===`);\n\n    const len = buf[2];\n    const power_state = buf.readUInt16BE(3);\n    const mode_state = buf.readUInt16BE(5);\n    const fan_mode_state = buf.readUInt16BE(7);\n    const temperature_state = buf.readUInt16BE(9);\n    const current_temperature_state = buf.readUInt16BE(11);\n    const hvac_id = buf.readUInt8(14) / 8;\n\n    debugLog('modbus', `æ¨¡çµ„ ID: ${moduleId}, HVAC ID: ${hvac_id}`);\n    debugLog('modbus', `é›»æº: ${power_state}, æ¨¡å¼: ${mode_state}, é¢¨é€Ÿ: ${fan_mode_state}`);\n    debugLog('modbus', `è¨­å®šæº«åº¦: ${temperature_state}Â°C, ç•¶å‰æº«åº¦: ${current_temperature_state}Â°C`);\n\n    // æ¨¡å¼æ˜ å°„\n    const modeMap = {\n        0: \"cool\",\n        1: \"heat\",\n        2: \"dry\",\n        3: \"fan_only\",\n        4: \"off\"\n    };\n\n    const fanModeMap = {\n        0: \"auto\",\n        1: \"low\",\n        2: \"medium\",\n        3: \"high\"\n    };\n\n    // ç•¶ power_state ç‚º 0 æ™‚ï¼Œå°‡ mode_state è¨­ç‚º \"off\"\n    const mode_state_str = (power_state === 0) ? \"off\" : modeMap[mode_state];\n    const fan_mode_state_str = fanModeMap[fan_mode_state];\n\n    debugLog('modbus', `æ¨¡å¼å­—ä¸²: ${mode_state_str}, é¢¨é€Ÿå­—ä¸²: ${fan_mode_state_str}`);\n\n    // ç™¼å¸ƒ MQTT ç‹€æ…‹ï¼ˆä½¿ç”¨å‹•æ…‹æ¨¡çµ„ IDï¼‰\n    const baseTopic = `homeassistant/hvac/${moduleId}/${hvac_id}`;\n\n    mqttMessages.push({ topic: `${baseTopic}/mode/state`, payload: mode_state_str });\n    mqttMessages.push({ topic: `${baseTopic}/fan_mode/state`, payload: fan_mode_state_str });\n    mqttMessages.push({ topic: `${baseTopic}/temperature/state`, payload: temperature_state });\n    mqttMessages.push({ topic: `${baseTopic}/current_temperature`, payload: current_temperature_state });\n\n    // æ›´æ–°å¿«å–ï¼ˆä½¿ç”¨å‹•æ…‹æ¨¡çµ„ IDï¼‰\n    flow.set(`hvac_${moduleId}_${hvac_id}_mode`, mode_state_str);\n    flow.set(`hvac_${moduleId}_${hvac_id}_fan_mode`, fan_mode_state_str);\n    flow.set(`hvac_${moduleId}_${hvac_id}_temperature`, temperature_state);\n    flow.set(`hvac_${moduleId}_${hvac_id}_current_temperature`, current_temperature_state);\n\n    debugLog('mqtt', `ç™¼å¸ƒ HVAC ç‹€æ…‹: ${baseTopic}`);\n    debugLog('mqtt', `  æ¨¡å¼: ${mode_state_str}, é¢¨é€Ÿ: ${fan_mode_state_str}`);\n    debugLog('mqtt', `  è¨­å®šæº«åº¦: ${temperature_state}Â°C, ç•¶å‰æº«åº¦: ${current_temperature_state}Â°C`);\n\n    node.status({\n        fill: \"orange\",\n        shape: \"dot\",\n        text: `HVAC ${moduleId}-${hvac_id}: ${mode_state_str} ${temperature_state}Â°C (${current_temperature_state}Â°C)`\n    });\n}\n\n    // ===== 0x03 Read Holding Registers (ç‡ˆå…‰æŸ¥è©¢å›æ‡‰) =====\nelse if (funcCode === 0x03) {\n    const byteCount = buf[2];  // å›å‚³çš„ byte æ•¸é‡\n    \n    debugLog('modbus', `=== æŸ¥è©¢å›æ‡‰ (0x03 Read Holding Registers) ===`);\n    debugLog('modbus', `æ¨¡çµ„ID: ${moduleId}, Byte Count: ${byteCount}`);\n    \n    // è§£æå¯„å­˜å™¨æ•¸æ“š (æ ¼å¼: [æ¨¡çµ„ID] [0x03] [Byte Count] [Reg1 Hi] [Reg1 Lo] [Reg2 Hi] [Reg2 Lo] ... [CRC])\n    if (byteCount >= 2) {\n        const reg1Hi = buf[3];\n        const reg1Lo = buf[4];\n        const reg1Value = (reg1Hi << 8) | reg1Lo;\n        const brightness = reg1Lo;  // ä½ä½å…ƒçµ„æ˜¯äº®åº¦å€¼\n        const state = brightness > 0 ? \"ON\" : \"OFF\";\n        \n        debugLog('modbus', `ç¬¬ä¸€å€‹å¯„å­˜å™¨å€¼: 0x${reg1Value.toString(16).padStart(4, '0')} (äº®åº¦: ${brightness})`);\n        \n        // å¾ flow context å–å¾—ç•¶å‰æŸ¥è©¢è³‡è¨Šï¼ˆå› ç‚º TCP Request æœƒè¦†è“‹ msg å±¬æ€§ï¼‰\n        const currentQuery = flow.get('modbus_current_query') || {};\n        const queryInfo = msg.queryInfo || currentQuery.queryInfo || {};\n        \n        // å„ªå…ˆä½¿ç”¨ flow context çš„è³‡è¨Šï¼Œå› ç‚ºå›æ‡‰çš„ moduleId æ˜¯å¯é çš„\n        // ä½† channel éœ€è¦å¾ queryInfo æˆ– flow context å–å¾—\n        const type = queryInfo.type || currentQuery.subType || \"single\";\n        const channel = queryInfo.channel || currentQuery.channel || \"1\";\n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `æŸ¥è©¢çµæœ: ${type} ç‡ˆå…‰, æ¨¡çµ„ ${moduleId}, é€šé“ ${channel}`);\n        debugLog('modbus', `ç‹€æ…‹: ${state}, äº®åº¦: ${brightness}`);\n        \n        // ç™¼å¸ƒæŸ¥è©¢åˆ°çš„ç‹€æ…‹\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n        \n        // æ›´æ–°å¿«å–ï¼šæŸ¥è©¢æ™‚å¦‚æœäº®åº¦ç‚º 0ï¼Œä¹Ÿä¸æ›´æ–°äº®åº¦å¿«å–\n        flow.set(`${type}_${moduleId}_${channel}_state`, state);\n        if (brightness > 0) {\n            flow.set(`${type}_${moduleId}_${channel}_brightness`, brightness);\n            debugLog('cache', `æŸ¥è©¢æ›´æ–°äº®åº¦å¿«å–: ${type}_${moduleId}_${channel}_brightness = ${brightness}`);\n        } else {\n            debugLog('cache', `æŸ¥è©¢äº®åº¦ç‚º 0ï¼Œä¿ç•™åŸå¿«å–å€¼: ${flow.get(`${type}_${moduleId}_${channel}_brightness`)}`);\n        }\n        \n        debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒ: ${baseTopic}/state = ${state}`);\n        if (state === \"ON\") {\n            debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒäº®åº¦: ${baseTopic}/brightness = ${brightness}`);\n        }\n        \n        // å¦‚æœæœ‰ç¬¬äºŒå€‹å¯„å­˜å™¨ (Dual Light è‰²æº«)\n        if (byteCount >= 4) {\n            const reg2Hi = buf[5];\n            const reg2Lo = buf[6];\n            const reg2Value = (reg2Hi << 8) | reg2Lo;\n            const ctPercent = reg2Lo;\n            \n            debugLog('modbus', `ç¬¬äºŒå€‹å¯„å­˜å™¨å€¼: 0x${reg2Value.toString(16).padStart(4, '0')} (è‰²æº«%: ${ctPercent})`);\n            \n            const MIN_MIRED = 167;\n            const MAX_MIRED = 333;\n            const colortemp = Math.round(MAX_MIRED - (ctPercent / 100) * (MAX_MIRED - MIN_MIRED));\n            \n            // å¦‚æœæ˜¯ dual lightï¼Œç™¼å¸ƒè‰²æº«\n            if (type === \"dual\") {\n                mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n                flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n                debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒè‰²æº«: ${baseTopic}/colortemp = ${colortemp} mired`);\n            }\n        }\n        \n        node.status({\n            fill: state === \"ON\" ? \"cyan\" : \"grey\",\n            shape: \"ring\",\n            text: `Query: ${type} ${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n}\n\n// ===== 0x01 Read Coils (Relay æŸ¥è©¢å›æ‡‰) =====\nelse if (funcCode === 0x01) {\n    const byteCount = buf[2];\n    const coilStatus = buf[3];  // Coil ç‹€æ…‹ (bit mask)\n    \n    debugLog('modbus', `=== æŸ¥è©¢å›æ‡‰ (0x01 Read Coils) ===`);\n    debugLog('modbus', `æ¨¡çµ„ID: ${moduleId}, Coil ç‹€æ…‹: 0b${coilStatus.toString(2).padStart(8, '0')}`);\n    \n    // è§£ææ¯å€‹ Relay çš„ç‹€æ…‹\n    for (let i = 0; i < 4; i++) {\n        const channel = String(i + 1);\n        const state = (coilStatus & (1 << i)) ? \"ON\" : \"OFF\";\n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒ Relay: ${baseTopic}/state = ${state}`);\n    }\n    \n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query: Relay ${moduleId} (1-4)`\n    });\n}\n\n// ===== æœªçŸ¥çš„åŠŸèƒ½ç¢¼ =====\nelse {\n    debugLog('modbus', `=== æœªè™•ç†çš„å›æ‡‰ ===`);\n    debugLog('modbus', `åŠŸèƒ½ç¢¼: 0x${funcCode.toString(16).padStart(2, '0')}, é•·åº¦: ${buf.length}`);\n    debugLog('modbus', `åŸå§‹è³‡æ–™: ${buf.toString('hex')}`);\n\n    const len = buf[2];\n    const power_state = buf.readUInt16BE(3);\n    const mode_state = buf.readUInt16BE(5);\n    const fan_mode_state = buf.readUInt16BE(7);\n    const temperature_state = buf.readUInt16BE(9);\n    const current_temperature_state = buf.readUInt16BE(11);\n    const hvac_id = buf.readUInt8(14) / 8;\n\n    debugLog('modbus', `æ¨¡çµ„ ID: ${moduleId}, HVAC ID: ${hvac_id}`);\n    debugLog('modbus', `é›»æº: ${power_state}, æ¨¡å¼: ${mode_state}, é¢¨é€Ÿ: ${fan_mode_state}`);\n    debugLog('modbus', `è¨­å®šæº«åº¦: ${temperature_state}Â°C, ç•¶å‰æº«åº¦: ${current_temperature_state}Â°C`);\n\n    // æ¨¡å¼æ˜ å°„\n    const modeMap = {\n        0: \"cool\",\n        1: \"heat\",\n        2: \"dry\",\n        3: \"fan_only\",\n        4: \"off\"\n    };\n\n    const fanModeMap = {\n        0: \"auto\",\n        1: \"low\",\n        2: \"medium\",\n        3: \"high\"\n    };\n\n    // ç•¶ power_state ç‚º 0 æ™‚ï¼Œå°‡ mode_state è¨­ç‚º \"off\"\n    const mode_state_str = (power_state === 0) ? \"off\" : modeMap[mode_state];\n    const fan_mode_state_str = fanModeMap[fan_mode_state];\n\n    debugLog('modbus', `æ¨¡å¼å­—ä¸²: ${mode_state_str}, é¢¨é€Ÿå­—ä¸²: ${fan_mode_state_str}`);\n\n    // ç™¼å¸ƒ MQTT ç‹€æ…‹ï¼ˆä½¿ç”¨å‹•æ…‹æ¨¡çµ„ IDï¼‰\n    const baseTopic = `homeassistant / hvac / ${moduleId} / ${hvac_id}`;\n\n    mqttMessages.push({ topic: `${baseTopic} / mode / state`, payload: mode_state_str });\n    mqttMessages.push({ topic: `${baseTopic} / fan_mode / state`, payload: fan_mode_state_str });\n    mqttMessages.push({ topic: `${baseTopic} / temperature / state`, payload: temperature_state });\n    mqttMessages.push({ topic: `${baseTopic} / current_temperature`, payload: current_temperature_state });\n\n    // æ›´æ–°å¿«å–ï¼ˆä½¿ç”¨å‹•æ…‹æ¨¡çµ„ IDï¼‰\n    flow.set(`hvac_${moduleId}_${hvac_id}_mode`, mode_state_str);\n    flow.set(`hvac_${moduleId}_${hvac_id}_fan_mode`, fan_mode_state_str);\n    flow.set(`hvac_${moduleId}_${hvac_id}_temperature`, temperature_state);\n    flow.set(`hvac_${moduleId}_${hvac_id}_current_temperature`, current_temperature_state);\n\n    debugLog('mqtt', `ç™¼å¸ƒ HVAC ç‹€æ…‹: ${baseTopic}`);\n    debugLog('mqtt', `  æ¨¡å¼: ${mode_state_str}, é¢¨é€Ÿ: ${fan_mode_state_str}`);\n    debugLog('mqtt', `  è¨­å®šæº«åº¦: ${temperature_state}Â°C, ç•¶å‰æº«åº¦: ${current_temperature_state}Â°C`);\n\n    node.status({\n        fill: \"orange\",\n        shape: \"dot\",\n        text: `HVAC ${moduleId} - ${hvac_id}: ${mode_state_str} ${temperature_state}Â°C(${current_temperature_state}Â°C)`\n    });\n}\n\nmsg.feedback = {\n    moduleId,\n    funcCode,\n    raw: buf.toString('hex')\n};\n\n// è§¸ç™¼ Modbus Queue ç™¼é€ä¸‹ä¸€å€‹æŒ‡ä»¤\nconst dequeueMsg = { topic: \"modbus/queue/dequeue\", payload: \"next\" };\n\n// è¿”å›: [Feedback è³‡è¨Š, MQTT ç‹€æ…‹, Queue Dequeue]\nreturn [msg, mqttMessages, dequeueMsg];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 180,
        "wires": [
            [
                "3405944690501c27"
            ],
            [
                "1301b4bfabe6d00e",
                "a2388fae33290227"
            ],
            [
                "d1a4a99a2680edb7"
            ]
        ]
    },
    {
        "id": "3405944690501c27",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "Feedback è§£æ",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "feedback",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 140,
        "wires": []
    },
    {
        "id": "1301b4bfabe6d00e",
        "type": "mqtt out",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "MQTT ç™¼å¸ƒç‹€æ…‹",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 840,
        "y": 300,
        "wires": []
    },
    {
        "id": "a2388fae33290227",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "MQTT ç‹€æ…‹å›å ±",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 280,
        "wires": []
    },
    {
        "id": "8ff2c6df0c7984f0",
        "type": "comment",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "å®Œæ•´æ¸¬è©¦ï¼šæ‰€æœ‰è¨­å‚™é¡å‹ (Light: Single/Dual/Relay, Cover, Scene)",
        "info": "æ”¯æ´çš„è¨­å‚™é¡å‹ï¼š\n\nğŸ”† **Light - Single**\n   - Topic: homeassistant/light/single/{module}/{channel}/set\n   - å–®è‰²ç‡ˆæ§åˆ¶ (äº®åº¦)\n\nğŸ”† **Light - Dual**\n   - Topic: homeassistant/light/dual/{module}/{channel}/set\n   - é›™è‰²æº«ç‡ˆæ§åˆ¶ (äº®åº¦ + è‰²æº«)\n\nğŸ”† **Light - Relay**\n   - Topic: homeassistant/light/relay/{module}/{channel}/set\n   - ç¹¼é›»å™¨é–‹é—œ (ON/OFF)\n\nğŸ¬ **Light - Scene**\n   - Topic: homeassistant/light/scene/{type}/{lights}/set\n   - å ´æ™¯æ§åˆ¶ (æ‰¹æ¬¡æ§åˆ¶å¤šå€‹ç‡ˆ)\n   - ä¾‹å¦‚: scene/single/12-1--12-2/set\n\nğŸªŸ **Cover**\n   - Topic: homeassistant/cover/general/{module}/set\n   - Payload: \"1_2/3\" (é–‹å•Ÿ 1,2 é—œé–‰ 3)\n   - çª—ç°¾æ§åˆ¶ (Bit Mask)\n\nâœ… å®Œæ•´æµç¨‹ï¼š\n   MQTT In â†’ è™•ç†å™¨ â†’ Modbus â†’ Feedback â†’ MQTT Out\n\nâŒ ç„¡ Queue ç³»çµ± (ç›´æ¥ç™¼é€)",
        "x": 270,
        "y": 40,
        "wires": []
    },
    {
        "id": "2361f69cb0630c2d",
        "type": "group",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "",
        "style": {
            "label": true
        },
        "nodes": [
            "4c37d4814250e9da",
            "c00d5d9f4f7ca28e",
            "1019794d8762e773",
            "35de024eb5ccfbf6",
            "bf0fc3175525663f",
            "51a56d0fdf8a2c8b"
        ],
        "x": 74,
        "y": 393,
        "w": 898,
        "h": 208
    },
    {
        "id": "4c37d4814250e9da",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "Debug å…¨é–‹",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":true,\"cache\":true,\"modbus\":true,\"mqtt\":true,\"scene\":true,\"query\":true,\"hmi\":true}",
        "payloadType": "json",
        "x": 190,
        "y": 480,
        "wires": [
            [
                "35de024eb5ccfbf6"
            ]
        ]
    },
    {
        "id": "c00d5d9f4f7ca28e",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "Debug å…¨é—œ",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":false,\"cache\":false,\"modbus\":false,\"mqtt\":false,\"scene\":false,\"query\":false,\"hmi\":false}",
        "payloadType": "json",
        "x": 190,
        "y": 520,
        "wires": [
            [
                "35de024eb5ccfbf6"
            ]
        ]
    },
    {
        "id": "1019794d8762e773",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "åªçœ‹ Modbus",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":false,\"cache\":false,\"modbus\":true,\"mqtt\":false,\"scene\":false,\"query\":false,\"hmi\":false}",
        "payloadType": "json",
        "x": 190,
        "y": 560,
        "wires": [
            [
                "35de024eb5ccfbf6"
            ]
        ]
    },
    {
        "id": "35de024eb5ccfbf6",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "è¨­å®š Debug é…ç½®",
        "func": "const config = msg.payload;\nglobal.set('debug_config', config);\n\nnode.warn('=== Debug é…ç½®å·²æ›´æ–° ===');\nnode.warn(`Topic: ${config.topic ? 'ON' : 'OFF'}`);\nnode.warn(`Cache: ${config.cache ? 'ON' : 'OFF'}`);\nnode.warn(`Modbus: ${config.modbus ? 'ON' : 'OFF'}`);\nnode.warn(`MQTT: ${config.mqtt ? 'ON' : 'OFF'}`);\nnode.warn(`Scene: ${config.scene ? 'ON' : 'OFF'}`);\nnode.warn(`Query: ${config.query ? 'ON' : 'OFF'}`);\nnode.warn(`HMI: ${config.hmi ? 'ON' : 'OFF'}`);\n\nnode.status({\n    fill: 'green',\n    shape: 'dot',\n    text: `å·²æ›´æ–° Debug é…ç½®`\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "bf0fc3175525663f",
        "type": "comment",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "Debug æ§åˆ¶ï¼šå‹•æ…‹åˆ‡æ› debug è¨Šæ¯é¡¯ç¤º",
        "info": "é€é global.debug_config æ§åˆ¶è¦é¡¯ç¤ºå“ªäº› debug è¨Šæ¯\n\nå¯æ§åˆ¶çš„é¡åˆ¥ï¼š\n- topic: é¡¯ç¤ºæ”¶åˆ°çš„ Topic å’Œ Payload\n- cache: é¡¯ç¤ºå¿«å–æ“ä½œ\n- modbus: é¡¯ç¤º Modbus æŒ‡ä»¤è©³æƒ…\n- mqtt: é¡¯ç¤º MQTT ç‹€æ…‹å›å ±\n- scene: é¡¯ç¤º Scene è™•ç†\n\nå¿«é€Ÿåˆ‡æ›ï¼š\n- å…¨é–‹ï¼šæ‰€æœ‰ debug è¨Šæ¯\n- å…¨é—œï¼šé—œé–‰æ‰€æœ‰ debug è¨Šæ¯\n- åªçœ‹ Modbusï¼šåªé¡¯ç¤º Modbus æŒ‡ä»¤",
        "x": 250,
        "y": 440,
        "wires": []
    },
    {
        "id": "51a56d0fdf8a2c8b",
        "type": "group",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "542bd36f97c1d4d4",
            "f8b978725dc2372b",
            "4c41b8ab0cd9ced1",
            "22eb6fe245fdde0f"
        ],
        "x": 534,
        "y": 419,
        "w": 412,
        "h": 142
    },
    {
        "id": "542bd36f97c1d4d4",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "æ¸…é™¤å¿«å–",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 640,
        "y": 460,
        "wires": [
            [
                "f8b978725dc2372b"
            ]
        ]
    },
    {
        "id": "f8b978725dc2372b",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "æ¸…é™¤æ‰€æœ‰å¿«å–",
        "func": "const keys = flow.keys();\nlet count = 0;\nkeys.forEach(k => {\n    if (k.startsWith('single_') || k.startsWith('dual_') || k.startsWith('relay_') || k.startsWith('scene_')) {\n        flow.set(k, undefined);\n        node.warn(`æ¸…é™¤: ${k}`);\n        count++;\n    }\n});\nnode.warn(`=== å·²æ¸…é™¤ ${count} ç­†å¿«å– ===`);\nnode.status({\n    fill: \"blue\",\n    shape: \"ring\",\n    text: `å·²æ¸…é™¤ ${count} ç­†`\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "4c41b8ab0cd9ced1",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "é¡¯ç¤ºå¿«å–",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 640,
        "y": 520,
        "wires": [
            [
                "22eb6fe245fdde0f"
            ]
        ]
    },
    {
        "id": "22eb6fe245fdde0f",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "é¡¯ç¤ºæ‰€æœ‰å¿«å–",
        "func": "node.warn(\"=== Flow Context å…§å®¹ ===\");\nconst keys = flow.keys();\nconst filtered = keys.filter(k => \n    k.startsWith('single_') || \n    k.startsWith('dual_') || \n    k.startsWith('relay_') || \n    k.startsWith('scene_')\n);\n\nif (filtered.length === 0) {\n    node.warn(\"ç›®å‰æ²’æœ‰ä»»ä½•å¿«å–è³‡æ–™\");\n} else {\n    // åˆ†é¡é¡¯ç¤º\n    const groups = {\n        single: [],\n        dual: [],\n        relay: [],\n        scene: []\n    };\n    \n    filtered.forEach(k => {\n        const value = flow.get(k);\n        if (k.startsWith('single_')) groups.single.push(`${k}: ${value}`);\n        else if (k.startsWith('dual_')) groups.dual.push(`${k}: ${value}`);\n        else if (k.startsWith('relay_')) groups.relay.push(`${k}: ${value}`);\n        else if (k.startsWith('scene_')) groups.scene.push(`${k}: ${value}`);\n    });\n    \n    if (groups.single.length > 0) {\n        node.warn(\"--- Single ---\");\n        groups.single.forEach(s => node.warn(s));\n    }\n    if (groups.dual.length > 0) {\n        node.warn(\"--- Dual ---\");\n        groups.dual.forEach(s => node.warn(s));\n    }\n    if (groups.relay.length > 0) {\n        node.warn(\"--- Relay ---\");\n        groups.relay.forEach(s => node.warn(s));\n    }\n    if (groups.scene.length > 0) {\n        node.warn(\"--- Scene ---\");\n        groups.scene.forEach(s => node.warn(s));\n    }\n    \n    node.warn(`=== å…± ${filtered.length} ç­†å¿«å– ===`);\n}\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "9506b0dd9dfd9d8c",
        "type": "tcp in",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI è¼¸å…¥ (TCP)",
        "server": "client",
        "host": "192.168.1.229",
        "port": "1030",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 160,
        "y": 260,
        "wires": [
            [
                "f3fd3b3a44906912"
            ]
        ]
    },
    {
        "id": "f3fd3b3a44906912",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI è™•ç†å™¨",
        "func": "/**\n * HMI è™•ç†å™¨ - è§¸æ§è¢å¹•æŒ‡ä»¤è§£æ\n * \n * Node ID: hmi_processor\n * Node Type: function\n * \n * æ­¤æª”æ¡ˆå¾ test_full_integrated.json è‡ªå‹•æå–\n */\n\nconst MIN_MIRED = 167, MAX_MIRED = 333;\n\n// Debug æ§åˆ¶\nconst debugConfig = global.get('debug_config') || {\n    topic: true,\n    cache: true,\n    modbus: true,\n    mqtt: true,\n    scene: true,\n    query: true,\n    hmi: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nconst HMI_pattern = [\n    // çª—ç°¾/éµæ²é–€æ§åˆ¶ - è§¸ç™¼ HA æŸ¥è©¢æ¨¡å¼ï¼ˆHMI ç›´æ¥æ§åˆ¶è¨­å‚™ï¼Œç™¼é€ query è®“ HA æ›´æ–°ç‹€æ…‹ï¼‰\n    {\n        name: \"curtain_control\",\n        pattern: [null, 0x06, 0x01, 0x9b, 0x00, null, null, null],\n        parse: (input) => {\n            const curtainId = input[0];\n            const action = input[5];\n\n            const CURTAIN_MAP = {\n                0x15: { topic: \"homeassistant/cover/curtain/21/query\" },  // éµæ²é–€\n                0x16: { topic: \"homeassistant/cover/curtain/22/query\" },  // æœƒè­°å®¤æ²ç°¾\n                0x17: { topic: \"homeassistant/cover/curtain/23/query\" }   // å¤šçµ„çª—ç°¾\n            };\n\n            const config = CURTAIN_MAP[curtainId];\n            if (!config) return null;\n\n            debugLog('hmi', `HMIçª—ç°¾æ“ä½œ: curtainId=0x${curtainId.toString(16).toUpperCase()} action=0x${action.toString(16).toUpperCase()} â†’ ç™¼é€query`);\n            return [{ topic: config.topic, payload: \"query\" }];\n        }\n    },\n    // å ´æ™¯æ§åˆ¶ï¼ˆå«æ¸¬è©¦æŒ‰éˆ•ï¼‰- ä¸»å‹•ç™¼é€æŸ¥è©¢åºåˆ—\n    {\n        name: \"scene_unified\",\n        pattern: [0xfe, 0x06, 0x08, 0x20, null, null, null, null],\n        parse: (input) => {\n            const operation = input[4];\n            const sceneId = input[5];\n\n            // å ´æ™¯å°æ‡‰çš„è¨­å‚™æŸ¥è©¢åˆ—è¡¨\n            const SCENE_QUERY_MAP = {\n                0x02: {\n                    name: \"æœƒè­°å®¤\",\n                    queries: [\n                        { topic: \"homeassistant/query/single/13/1\", payload: \"query\" },  // æœƒè­°é–“ç…§\n                        { topic: \"homeassistant/query/single/13/2\", payload: \"query\" },  // å†·æ°£é–“ç…§\n                        { topic: \"homeassistant/query/single/13/3\", payload: \"query\" },  // æœƒè­°å´ç‡ˆ\n                        { topic: \"homeassistant/query/dual/14/a\", payload: \"query\" },    // æœƒè­°å®¤é›™è‰²æº«A\n                        { topic: \"homeassistant/query/dual/14/b\", payload: \"query\" }     // æœƒè­°å®¤é›™è‰²æº«B\n                    ]\n                },\n                0x03: {\n                    name: \"å…¬å…±å€\",\n                    queries: [\n                        { topic: \"homeassistant/query/single/11/1\", payload: \"query\" },  // èµ°å»Šé–“ç…§\n                        { topic: \"homeassistant/query/single/11/2\", payload: \"query\" },  // èµ°å»Šé–“ç…§\n                        { topic: \"homeassistant/query/single/12/1\", payload: \"query\" },  // æ³¡èŒ¶å€\n                        { topic: \"homeassistant/query/single/12/2\", payload: \"query\" },  // èµ°é“å´ç‡ˆ\n                        { topic: \"homeassistant/query/single/12/3\", payload: \"query\" },  // å±•ç¤ºæ«ƒ\n                        { topic: \"homeassistant/query/single/12/4\", payload: \"query\" }   // å±•ç¤ºæ«ƒ\n                    ]\n                },\n                0x04: {\n                    name: \"æˆ¶å¤–\",\n                    queries: [\n                        { topic: \"homeassistant/query/single/18/1\", payload: \"query\" },  // 1Få£ç‡ˆ\n                        { topic: \"homeassistant/query/single/18/2\", payload: \"query\" },  // 1Fåœ°ç‡ˆ\n                        { topic: \"homeassistant/query/single/19/1\", payload: \"query\" },  // 2Få£ç‡ˆ\n                        { topic: \"homeassistant/query/single/19/2\", payload: \"query\" }   // 2Fåœ°ç‡ˆ\n                    ]\n                },\n                0x05: {\n                    name: \"H40äºŒæ¨“\",\n                    queries: [\n                        { topic: \"homeassistant/query/single/15/1\", payload: \"query\" },  // å®¢å»³å‰\n                        { topic: \"homeassistant/query/single/15/2\", payload: \"query\" },  // å®¢å»³å¾Œ\n                        { topic: \"homeassistant/query/single/16/1\", payload: \"query\" },  // èµ°é“é–“ç…§\n                        { topic: \"homeassistant/query/single/16/2\", payload: \"query\" },  // èµ°é“é–“ç…§\n                        { topic: \"homeassistant/query/single/17/1\", payload: \"query\" },  // å»šæˆ¿\n                        { topic: \"homeassistant/query/single/17/2\", payload: \"query\" },  // å»šæˆ¿\n                        { topic: \"homeassistant/query/single/18/1\", payload: \"query\" },  // 1Få£ç‡ˆ\n                        { topic: \"homeassistant/query/single/18/2\", payload: \"query\" },  // 1Fåœ°ç‡ˆ\n                        { topic: \"homeassistant/query/single/19/1\", payload: \"query\" },  // 2Få£ç‡ˆ\n                        { topic: \"homeassistant/query/single/19/2\", payload: \"query\" }   // 2Fåœ°ç‡ˆ\n                    ]\n                }\n            };\n\n            const sceneConfig = SCENE_QUERY_MAP[sceneId];\n\n            if (sceneConfig) {\n                debugLog('hmi', `HMIå ´æ™¯æŒ‰éˆ•: ${sceneConfig.name}(0x${sceneId.toString(16).padStart(2, '0').toUpperCase()}) æ“ä½œ0x${operation.toString(16).padStart(2, '0').toUpperCase()} â†’ ç™¼é€${sceneConfig.queries.length}å€‹æŸ¥è©¢`);\n                return sceneConfig.queries;\n            }\n\n            // æœªçŸ¥å ´æ™¯ï¼šfallback åˆ°è§¸ç™¼å…¨éƒ¨è¼ªè©¢\n            debugLog('hmi', `HMIå ´æ™¯æŒ‰éˆ•: æœªçŸ¥å ´æ™¯0x${sceneId.toString(16).padStart(2, '0').toUpperCase()} æ“ä½œ0x${operation.toString(16).padStart(2, '0').toUpperCase()} â†’ è§¸ç™¼å…¨éƒ¨è¼ªè©¢`);\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n        }\n    },\n    // ç‡ˆå…‰æ§åˆ¶ - è§¸ç™¼è¼ªè©¢æŸ¥è©¢æ¨¡å¼\n    {\n        name: \"light_control_unified\",\n        pattern: [0xEE, 0xB1, 0x11, 0x00, null, 0x00, null, 0x13, 0x00, 0x00, null, null, 0xFF, 0xFC, 0xFF, 0xFF],\n        parse: (input) => {\n            const sceneId = input[4];\n            const functionId = input[6];\n            const valueHigh = input[10];\n            const valueLow = input[11];\n            const raw = (valueHigh << 8) + valueLow;\n\n            let value = Math.round((raw / 1000) * 100);\n            value = value < 0 ? 0 : value > 100 ? 100 : value;\n\n            debugLog('hmi', `HMIç‡ˆå…‰æ§åˆ¶(èˆŠæ ¼å¼): å ´æ™¯0x${sceneId.toString(16).toUpperCase()} åŠŸèƒ½0x${functionId.toString(16).toUpperCase()} æ•¸å€¼=${value}% â†’ è§¸ç™¼è¼ªè©¢`);\n\n            // è§¸ç™¼è¼ªè©¢æŸ¥è©¢\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n\n            /* å·²åœç”¨ç‹€æ…‹åŒæ­¥\n\n            const LIGHT_MAP = {\n                \"0x1E-0x0B\": { topic: \"homeassistant/light/scene/single/11-1--11-2\", type: \"brightness\" },\n                \"0x1E-0x0D\": { topic: \"homeassistant/light/scene/single/12-1\", type: \"brightness\" },\n                \"0x1E-0x0F\": { topic: \"homeassistant/light/scene/single/12-2\", type: \"brightness\" },\n                \"0x1E-0x11\": { topic: \"homeassistant/light/scene/single/12-3--12-4\", type: \"brightness\" },\n                \"0x1F-0x0B\": { topic: \"homeassistant/light/dual/14/a\", type: \"brightness\" },\n                \"0x1F-0x0D\": { topic: \"homeassistant/light/dual/14/a\", type: \"colortemp\" },\n                \"0x1F-0x0F\": { topic: \"homeassistant/light/dual/14/b\", type: \"brightness\" },\n                \"0x1F-0x11\": { topic: \"homeassistant/light/dual/14/b\", type: \"colortemp\" }\n            };\n\n            const key = `0x${sceneId.toString(16).toUpperCase()}-0x${functionId.toString(16).toUpperCase()}`;\n            const config = LIGHT_MAP[key];\n            if (!config) return null;\n\n            const baseTopic = config.topic;\n\n            if (config.type === \"brightness\") {\n                debugLog('hmi', `HMIç‡ˆå…‰ç‹€æ…‹: ${baseTopic} äº®åº¦=${value}%`);\n                return [\n                    { topic: `${baseTopic}/state`, payload: state },\n                    { topic: `${baseTopic}/brightness`, payload: value }\n                ];\n            } else if (config.type === \"colortemp\") {\n                const colortemp = Math.round(MAX_MIRED - ((MAX_MIRED - MIN_MIRED) * value / 100));\n                debugLog('hmi', `HMIç‡ˆå…‰ç‹€æ…‹: ${baseTopic} è‰²æº«=${colortemp} mired`);\n                return [\n                    { topic: `${baseTopic}/colortemp`, payload: colortemp }\n                ];\n            }\n            return null;\n            */\n        }\n    },\n    // é›™è‰²æº«ç‡ˆæ§åˆ¶ - æ–°æ ¼å¼ 0x11 å¸¶æ•¸å€¼(ç‹€æ…‹åŒæ­¥) âš ï¸ å¿…é ˆæ”¾åœ¨ single_light_control ä¹‹å‰!\n    {\n        name: \"dual_light\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, 0x1F, 0x00, null, 0x13, 0x00, 0x00, null, null, 0xFF, 0xFC, 0xFF, 0xFF],\n        parse: (input) => {\n            const functionId = input[8];   // byte[8]: åŠŸèƒ½ID (0x0B=äº®åº¦, 0x0D=è‰²æº«)\n            const valueHigh = input[12];   // byte[12-13]: æ•¸å€¼ 0-1000\n            const valueLow = input[13];\n            const raw = (valueHigh << 8) + valueLow;\n\n            // æ˜ å°„: 0x0B=Aäº®åº¦, 0x0D=Aè‰²æº«, 0x0F=Bäº®åº¦, 0x11=Bè‰²æº«\n            const DUAL_MAP = {\n                0x0B: { topic: \"homeassistant/light/dual/14/a\", type: \"brightness\" },\n                0x0D: { topic: \"homeassistant/light/dual/14/a\", type: \"colortemp\" },\n                0x0F: { topic: \"homeassistant/light/dual/14/b\", type: \"brightness\" },\n                0x11: { topic: \"homeassistant/light/dual/14/b\", type: \"colortemp\" }\n            };\n\n            const config = DUAL_MAP[functionId];\n            if (!config) return null;\n\n            const baseTopic = config.topic;\n\n            if (config.type === \"brightness\") {\n                const brightness = Math.round((raw / 1000) * 100);\n                const state = brightness > 0 ? \"ON\" : \"OFF\";\n                debugLog('hmi', `HMIé›™è‰²æº«ç‡ˆäº®åº¦: ${baseTopic} äº®åº¦=${brightness}%`);\n                return [\n                    { topic: `${baseTopic}/state`, payload: state },\n                    { topic: `${baseTopic}/brightness`, payload: brightness }\n                ];\n            } else if (config.type === \"colortemp\") {\n                const percentage = Math.round((raw / 1000) * 100);\n                const colortemp = Math.round(MAX_MIRED - ((MAX_MIRED - MIN_MIRED) * percentage / 100));\n                debugLog('hmi', `HMIé›™è‰²æº«ç‡ˆè‰²æº«: ${baseTopic} è‰²æº«=${colortemp} mired (${percentage}%)`);\n                return [\n                    { topic: `${baseTopic}/colortemp`, payload: colortemp }\n                ];\n            }\n\n            return null;\n        }\n    },\n    // å–®è‰²ç‡ˆå¸¶æ•¸å€¼æ§åˆ¶ - æ–°æ ¼å¼ 0x11 å¸¶æ•¸å€¼(ç‹€æ…‹åŒæ­¥) âš ï¸ å¿…é ˆæ”¾åœ¨ single_light_control ä¹‹å‰!\n    {\n        name: \"single_light_with_value\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, null, 0x00, null, 0x13, 0x00, 0x00, null, null, 0xFF, 0xFC, 0xFF, 0xFF],\n        parse: (input) => {\n            const sceneId = input[6];      // byte[6]: å ´æ™¯ID\n            const functionId = input[8];   // byte[8]: åŠŸèƒ½ID\n            const valueHigh = input[12];   // byte[12-13]: æ•¸å€¼ 0-1000\n            const valueLow = input[13];\n            const raw = (valueHigh << 8) + valueLow;\n\n            // æ˜ å°„è¡¨: è§¸ç™¼æŸ¥è©¢æ¨¡å¼ (å› ç‚º HMI ç›´æ¥æ§åˆ¶è¨­å‚™,åŒä¸€æŒ‡ä»¤å¯èƒ½å°æ‡‰å¤šå€‹ç‡ˆå…‰)\n            const SINGLE_MAP = {\n                // Scene 0x1E - èµ°å»Šå€åŸŸ + äºŒæ¨“å€åŸŸ (æœƒè¡çª,éœ€è¦æŸ¥è©¢å¤šå€‹è¨­å‚™)\n                \"0x1E-0x0B\": {\n                    topic: \"homeassistant/light/single/11/1\",\n                    name: \"èµ°å»Šé–“ç…§+å®¢å»³å¾Œ\",\n                    queryTopics: [\n                        \"homeassistant/query/single/11/1\",\n                        \"homeassistant/query/single/15/2\"\n                    ]\n                },\n                \"0x1E-0x0D\": {\n                    topic: \"homeassistant/light/single/12/1\",\n                    name: \"æ³¡èŒ¶å€\",\n                    queryTopics: [\"homeassistant/query/single/12/1\"]\n                },\n                \"0x1E-0x0F\": {\n                    topic: \"homeassistant/light/single/12/2\",\n                    name: \"èµ°é“å´ç‡ˆ\",\n                    queryTopics: [\"homeassistant/query/single/12/2\"]\n                },\n                \"0x1E-0x11\": {\n                    topic: \"homeassistant/light/single/12/3\",\n                    name: \"å±•ç¤ºæ«ƒ\",\n                    queryTopics: [\"homeassistant/query/single/12/3\"]\n                },\n                // Scene 0x20 - æœƒè­°å®¤å€åŸŸ\n                \"0x20-0x0B\": {\n                    topic: \"homeassistant/light/single/13/1\",\n                    name: \"æœƒè­°é–“ç…§\",\n                    queryTopics: [\"homeassistant/query/single/13/1\"]\n                },\n                \"0x20-0x0D\": {\n                    topic: \"homeassistant/light/single/13/2\",\n                    name: \"å†·æ°£é–“ç…§\",\n                    queryTopics: [\"homeassistant/query/single/13/2\"]\n                },\n                \"0x20-0x0F\": {\n                    topic: \"homeassistant/light/single/13/3\",\n                    name: \"æœƒè­°å´ç‡ˆ\",\n                    queryTopics: [\"homeassistant/query/single/13/3\"]\n                }\n            };\n\n            const key = `0x${sceneId.toString(16).toUpperCase().padStart(2, '0')}-0x${functionId.toString(16).toUpperCase().padStart(2, '0')}`;\n            const config = SINGLE_MAP[key];\n            if (!config) {\n                debugLog('hmi', `HMIå–®è‰²ç‡ˆæœªåŒ¹é…: key=\"${key}\" sceneId=${sceneId}(0x${sceneId.toString(16).toUpperCase()}) functionId=${functionId}(0x${functionId.toString(16).toUpperCase()})`);\n                return null;\n            }\n\n            const brightness = Math.round((raw / 1000) * 100);\n            const state = brightness > 0 ? \"ON\" : \"OFF\";\n\n            debugLog('hmi', `HMIå–®è‰²ç‡ˆèª¿æ•´: ${config.name} â†’ è§¸ç™¼æŸ¥è©¢`);\n\n            // HMI ç›´æ¥æ§åˆ¶è¨­å‚™,é€™è£¡ç™¼é€ query è§¸ç™¼ç‹€æ…‹æŸ¥è©¢\n            const commands = [];\n\n            // æŸ¥è©¢æ‰€æœ‰å¯èƒ½å—å½±éŸ¿çš„ç‡ˆå…‰\n            if (config.queryTopics && Array.isArray(config.queryTopics)) {\n                for (const queryTopic of config.queryTopics) {\n                    commands.push({ topic: queryTopic, payload: \"query\" });\n                }\n            } else {\n                // å¦‚æœæ²’æœ‰æŒ‡å®š queryTopics,å‰‡æŸ¥è©¢å–®å€‹è¨­å‚™\n                const parts = config.topic.split(\"/\");\n                const queryTopic = `homeassistant/query/${parts[2]}/${parts[3]}/${parts[4]}`;\n                commands.push({ topic: queryTopic, payload: \"query\" });\n            }\n\n            return commands;\n        }\n    },\n    // å–®è‰²ç‡ˆæ§åˆ¶ - æ–°æ ¼å¼ 0x11 æ§åˆ¶æŒ‡ä»¤(è§¸ç™¼è¼ªè©¢)\n    {\n        name: \"single_light_control\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, null, 0x00, null, 0x13, 0x00, 0x00],\n        parse: (input) => {\n            const sceneId = input[6];      // byte[6]: å ´æ™¯ID (ä¾‹å¦‚ 0x1E)\n            const functionId = input[8];   // byte[8]: åŠŸèƒ½ID (ä¾‹å¦‚ 0x0B)\n\n            debugLog('hmi', `HMIå–®è‰²ç‡ˆæ§åˆ¶: å ´æ™¯0x${sceneId.toString(16).toUpperCase()} åŠŸèƒ½0x${functionId.toString(16).toUpperCase()} â†’ è§¸ç™¼è¼ªè©¢`);\n\n            // è§¸ç™¼è¼ªè©¢æŸ¥è©¢\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n        }\n    },\n    // å–®è‰²ç‡ˆè¨­å®šå€¼ - æ–°æ ¼å¼ 0x12 ASCII å­—ä¸²(è§¸ç™¼è¼ªè©¢)\n    {\n        name: \"single_light_value\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x12, 0x00, null, 0x00, null, 0x00, null],\n        parse: (input) => {\n            const sceneId = input[6];      // byte[6]: å ´æ™¯ID (ä¾‹å¦‚ 0x1E)\n            const functionId = input[8];   // byte[8]: åŠŸèƒ½ID (ä¾‹å¦‚ 0x15)\n            const length = input[10];      // byte[10]: ASCII å­—ä¸²é•·åº¦\n\n            // æå– ASCII æ•¸å€¼ï¼ˆäº®åº¦ç™¾åˆ†æ¯”ï¼‰\n            let brightness = null;\n            if (length > 0 && input.length >= 11 + length) {\n                let valueStr = '';\n                for (let i = 0; i < length; i++) {\n                    valueStr += String.fromCharCode(input[11 + i]);\n                }\n                brightness = parseInt(valueStr);\n            }\n\n            debugLog('hmi', `HMIå–®è‰²ç‡ˆäº®åº¦(ASCII): å ´æ™¯0x${sceneId.toString(16).toUpperCase()} åŠŸèƒ½0x${functionId.toString(16).toUpperCase()} æ•¸å€¼=${brightness}% â†’ è§¸ç™¼è¼ªè©¢`);\n\n            // è§¸ç™¼è¼ªè©¢æŸ¥è©¢\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n        }\n    },\n    // ç©ºèª¿æ§åˆ¶ï¼ˆç‹€æ…‹åŒæ­¥æ¨¡å¼ï¼šHMI ç›´æ¥æ§åˆ¶è¨­å‚™ï¼Œé€™è£¡åªæ›´æ–° HA ç‹€æ…‹ï¼‰\n    // âš ï¸ æ³¨æ„ï¼šé€™äº›æ˜¯èˆŠæ ¼å¼ï¼Œå¯èƒ½ä¸å†ä½¿ç”¨\n    {\n        name: \"hvac_power_mode\",\n        pattern: [0x01, 0x31, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const powerValue = input[2];\n            const hvacId = input[5];\n            const mode = powerValue === 0x01 ? \"auto\" : \"off\";\n            debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹(èˆŠ): ${hvacId} æ¨¡å¼=${mode}`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/state`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_temperature\",\n        pattern: [0x01, 0x32, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const tempValue = input[2];\n            const hvacId = input[5];\n            debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹: ${hvacId} æº«åº¦=${tempValue}Â°C`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/temperature/state`, payload: String(tempValue) }];\n        }\n    },\n    {\n        name: \"hvac_mode\",\n        pattern: [0x01, 0x33, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const modeValue = input[2];\n            const hvacId = input[5];\n            const MODE_MAP = {\n                0x00: \"cool\",\n                0x01: \"dry\",\n                0x02: \"fan_only\",\n                0x04: \"heat\"\n            };\n            const mode = MODE_MAP[modeValue];\n            if (!mode) return null;\n            debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹: ${hvacId} æ¨¡å¼=${mode}`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/state`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_fan_speed\",\n        pattern: [0x01, 0x34, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const fanValue = input[2];\n            const hvacId = input[5];\n            const FAN_MAP = {\n                0x03: \"medium\",\n                0x04: \"high\",\n                0x05: \"auto\",\n                0x07: \"low\"\n            };\n            const fan = FAN_MAP[fanValue];\n            if (!fan) return null;\n            debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹(èˆŠ): ${hvacId} é¢¨é‡=${fan}`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/fan/state`, payload: fan }];\n        }\n    },\n    // HMI å¯¦éš›æ ¼å¼ - æº«åº¦æ§åˆ¶ï¼ˆASCII å­—ä¸²æ ¼å¼ï¼‰\n    // æ ¼å¼: [0xEE, 0x00, 0x00, 0xB1, 0x12, 0x00, 0x2C, 0x00, 0x1F, 0x00, 0x02, '3', '1', ...]\n    {\n        name: \"hvac_temperature_ascii\",\n        pattern: [0xEE, 0x00, 0x00, 0xB1, 0x12, 0x00, 0x2C, 0x00, 0x1F, 0x00, null],\n        parse: (input) => {\n            // input[10] æ˜¯é•·åº¦ï¼Œå¾Œé¢æ˜¯ ASCII æº«åº¦å­—ä¸²\n            const length = input[10];\n            if (length < 1 || input.length < 11 + length) return null;\n\n            // æå– ASCII æº«åº¦å­—ä¸²ä¸¦è½‰æ›\n            let tempStr = '';\n            for (let i = 0; i < length; i++) {\n                tempStr += String.fromCharCode(input[11 + i]);\n            }\n\n            const temperature = parseInt(tempStr);\n            if (isNaN(temperature)) return null;\n\n            // å‡è¨­ HVAC ID = 1ï¼ˆå¯èƒ½éœ€è¦å¾å…¶ä»–åœ°æ–¹åˆ¤æ–·ï¼‰\n            const hvacId = 1;\n\n            debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹: ${hvacId} æº«åº¦=${temperature}Â°C (ASCII: \"${tempStr}\")`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/temperature/state`, payload: String(temperature) }];\n        }\n    },\n    // HMI å¯¦éš›æ ¼å¼ - æ¨¡å¼/é¢¨é€Ÿæ§åˆ¶\n    // æ ¼å¼: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, 0x2C, 0x00, byte8, 0x10, 0x01, 0x01, ...]\n    // byte8 æ±ºå®šæ¨¡å¼æˆ–é¢¨é€Ÿ\n    {\n        name: \"hvac_mode_fanspeed\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, 0x2C, 0x00, null, null, null, null],\n        parse: (input) => {\n            const byte8 = input[8];   // é—œéµä½ç½®ï¼šæ±ºå®šæ¨¡å¼æˆ–é¢¨é€Ÿ\n            const byte9 = input[9];   // é€šå¸¸æ˜¯ 0x10\n            const byte10 = input[10]; // é€šå¸¸æ˜¯ 0x01\n            const byte11 = input[11]; // é€šå¸¸æ˜¯ 0x01\n\n            // å‡è¨­ HVAC ID = 1\n            const hvacId = 1;\n\n            // é–‹é—œæ§åˆ¶ï¼ˆåŸºæ–¼ byte8 å’Œ byte11ï¼‰\n            if (byte8 === 0x0A) {\n                // byte11 æ±ºå®šé–‹é—œï¼š0x00=é—œæ©Ÿ, 0x01=é–‹æ©Ÿ\n                const powerState = byte11 === 0x01 ? \"cool\" : \"off\";  // é–‹æ©Ÿé è¨­ç‚ºå†·æ°£æ¨¡å¼\n                debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹: ${hvacId} é›»æº=${powerState === \"off\" ? \"é—œ\" : \"é–‹\"}`);\n                return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/state`, payload: powerState }];\n            }\n\n            // æ¨¡å¼æ˜ å°„ï¼ˆåŸºæ–¼ byte8ï¼‰\n            const MODE_MAP = {\n                0x0D: \"cool\",      // å†·æ°£\n                0x10: \"heat\",      // æš–æ°£\n                0x0E: \"dry\",       // é™¤æ¿•\n                0x0F: \"fan_only\"   // é€é¢¨\n            };\n\n            // é¢¨é€Ÿæ˜ å°„ï¼ˆåŸºæ–¼ byte8ï¼‰\n            const FAN_MAP = {\n                0x13: \"low\",       // ä½é€Ÿ\n                0x12: \"medium\",    // ä¸­é€Ÿ\n                0x11: \"high\",      // é«˜é€Ÿ\n                0x14: \"auto\"       // è‡ªå‹•\n            };\n\n            // å…ˆæª¢æŸ¥æ˜¯å¦ç‚ºæ¨¡å¼æ§åˆ¶\n            const mode = MODE_MAP[byte8];\n            if (mode) {\n                debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹: ${hvacId} æ¨¡å¼=${mode}`);\n                return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/state`, payload: mode }];\n            }\n\n            // å†æª¢æŸ¥æ˜¯å¦ç‚ºé¢¨é€Ÿæ§åˆ¶\n            const fan = FAN_MAP[byte8];\n            if (fan) {\n                debugLog('hmi', `HMIç©ºèª¿ç‹€æ…‹: ${hvacId} é¢¨é€Ÿ=${fan}`);\n                return [{ topic: `homeassistant/hvac/200/${hvacId}/fan/state`, payload: fan }];\n            }\n\n            // è¨˜éŒ„æœªçŸ¥æ ¼å¼ä»¥ä¾¿èª¿è©¦\n            debugLog('hmi', `HMIç©ºèª¿æœªçŸ¥æ ¼å¼: byte8=0x${byte8.toString(16).padStart(2, '0').toUpperCase()}`);\n            return null;\n        }\n    }\n];\n\nfunction matchPattern(input, pattern) {\n    // å…è¨± input é•·åº¦å¤§æ–¼ç­‰æ–¼ patternï¼ˆæ”¯æ´å¯è®Šé•·åº¦è³‡æ–™ï¼‰\n    if (input.length < pattern.length) return false;\n    for (let i = 0; i < pattern.length; i++) {\n        if (pattern[i] !== null && pattern[i] !== input[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction bufferToHexArray(buf) {\n    return [...buf].map(v => \"0x\" + v.toString(16).padStart(2, \"0\").toUpperCase());\n}\n\nif (!msg.payload || !Buffer.isBuffer(msg.payload)) {\n    debugLog('hmi', \"HMIæ”¶åˆ°ç„¡æ•ˆçš„ payload\");\n    return null;\n}\n\nlet input = Array.from(msg.payload);\nlet result = null;\nlet matchedPattern = null;\n\nfor (const p of HMI_pattern) {\n    if (matchPattern(input, p.pattern)) {\n        matchedPattern = p.name;\n        debugLog('hmi', `âœ“ åŒ¹é…åˆ° pattern: ${p.name}`);\n        result = p.parse(input);\n        if (result) {\n            debugLog('hmi', `âœ“ parse æˆåŠŸ,è¿”å› ${result.length} å€‹æŒ‡ä»¤`);\n        } else {\n            debugLog('hmi', `âœ— parse è¿”å› null`);\n        }\n        break;\n    }\n}\n\nif (result && Array.isArray(result) && result.length > 0) {\n    debugLog('hmi', `HMIæ”¶åˆ°: ${bufferToHexArray(msg.payload)} â†’ ${result.length} å€‹ MQTT æŒ‡ä»¤`);\n    return [result];\n} else {\n    debugLog('hmi', `HMIæ”¶åˆ°: ${bufferToHexArray(msg.payload)} (${matchedPattern ? `åŒ¹é… ${matchedPattern} ä½† parse å¤±æ•—` : 'æœªåŒ¹é…'})`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 260,
        "wires": [
            [
                "cc06f2f568357a28",
                "1301b4bfabe6d00e"
            ]
        ]
    },
    {
        "id": "cc06f2f568357a28",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI æŒ‡ä»¤",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 320,
        "wires": []
    },
    {
        "id": "8a1dcb4d8fb68e37",
        "type": "comment",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI è§¸æ§è¢å¹•ï¼šçª—ç°¾/å ´æ™¯/ç‡ˆå…‰/ç©ºèª¿æ§åˆ¶",
        "info": "HMI è§¸æ§è¢å¹•è¼¸å…¥è™•ç†\n\næ”¯æ´åŠŸèƒ½ï¼š\nğŸªŸ çª—ç°¾æ§åˆ¶ - éµæ²é–€/æœƒè­°å®¤æ²ç°¾/å¸ƒç°¾/ç´—ç°¾/æ’ç…™çª—\nğŸ¬ å ´æ™¯æ§åˆ¶ - å ´æ™¯è¨˜æ†¶/æ¸¬è©¦æŒ‰éˆ•/ä¸€èˆ¬å ´æ™¯\nğŸ’¡ ç‡ˆå…‰æ§åˆ¶ - äº®åº¦/è‰²æº«èª¿ç¯€\nâ„ï¸ ç©ºèª¿æ§åˆ¶ - é–‹é—œ/æº«åº¦/æ¨¡å¼/é¢¨é‡\n\næµç¨‹ï¼š\nTCP In (8888) â†’ HMI è™•ç†å™¨ â†’ MQTT Out",
        "x": 240,
        "y": 320,
        "wires": []
    },
    {
        "id": "a96e5c88474cb10a",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æŸ¥è©¢æ‰€æœ‰è¨˜æ†¶",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "homeassistant/memory/query/all",
        "x": 130,
        "y": 120,
        "wires": [
            [
                "27bd656af41458c7"
            ]
        ]
    },
    {
        "id": "4e57977080ea5596",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¨˜æ†¶æŸ¥è©¢çµæœ",
        "active": true,
        "tosidebar": false,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 660,
        "y": 20,
        "wires": []
    },
    {
        "id": "8128d24c1e30c31b",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æ¸…é™¤æ‰€æœ‰è¨˜æ†¶",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "clear",
        "payloadType": "str",
        "x": 170,
        "y": 360,
        "wires": [
            [
                "bfa31e824ef82cb0"
            ]
        ]
    },
    {
        "id": "bfa31e824ef82cb0",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æ¸…é™¤æ‰€æœ‰è¨˜æ†¶",
        "func": "const keys = flow.keys();\nlet count = 0;\nkeys.forEach(k => {\n    if (k.startsWith('memory_')) {\n        flow.set(k, undefined);\n        node.warn(`æ¸…é™¤: ${k}`);\n        count++;\n    }\n});\nnode.warn(`=== å·²æ¸…é™¤ ${count} ç­†è¨˜æ†¶ ===`);\nnode.status({\n    fill: 'blue',\n    shape: 'ring',\n    text: `å·²æ¸…é™¤ ${count} ç­†`\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 360,
        "wires": [
            [
                "5c78efdf4cc08cdc"
            ]
        ]
    },
    {
        "id": "5c78efdf4cc08cdc",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æ¸…é™¤è¨˜æ†¶çµæœ",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 360,
        "wires": []
    },
    {
        "id": "748cd437883e26c9",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¨»å†Šè™›æ“¬è£ç½®",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 140,
        "y": 80,
        "wires": [
            [
                "9adead2839ee4cf5"
            ]
        ]
    },
    {
        "id": "9adead2839ee4cf5",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¨»å†Šè£ç½®",
        "func": "/**\n * general configuration - Home Assistant MQTT é…ç½®ç”Ÿæˆå™¨\n * æ”¯æ´: Lights (å–®è‰²/é›™è‰²), Scenes, Covers (çª—ç°¾/æ²ç°¾), Climate (ç©ºèª¿)\n */\n\n// ============ è¨­å‚™å®šç¾© ============\n\n// 1. ç‡ˆå…‰è¨­å‚™\nlet lights = [\n    // ç›¤A\n    { id: \"single_11_1\", name: \"èµ°å»Šé–“ç…§\" },\n    { id: \"single_12_1\", name: \"æ³¡èŒ¶å€\" },\n    { id: \"single_12_2\", name: \"èµ°é“å´ç‡ˆ\" },\n    { id: \"single_12_3\", name: \"å±•ç¤ºæ«ƒ\" },\n    { id: \"single_13_1\", name: \"æœƒè­°é–“ç…§\" },\n    { id: \"single_13_2\", name: \"å†·æ°£é–“ç…§\" },\n    { id: \"single_13_3\", name: \"æœƒè­°å´ç‡ˆ\" },\n    { id: \"dual_14_a\", name: \"æœƒè­°å®¤è»Œé“ç‡ˆ\" },\n    { id: \"dual_14_b\", name: \"æœƒè­°å®¤åŠç‡ˆ\" },\n    // ç›¤B\n    { id: \"single_15_1\", name: \"å®¢å»³å‰\" },\n    { id: \"single_15_2\", name: \"å®¢å»³å¾Œ\" },\n    { id: \"single_16_1\", name: \"èµ°é“é–“ç…§\" },\n    { id: \"single_17_1\", name: \"å»šæˆ¿\" },\n    { id: \"single_18_1\", name: \"1Få£ç‡ˆ\" },\n    { id: \"single_18_2\", name: \"1Fåœ°ç‡ˆ\" },\n    { id: \"single_19_1\", name: \"2Få£ç‡ˆ\" },\n    { id: \"single_19_2\", name: \"2Fåœ°ç‡ˆ\" },\n];\n\n// 2. æƒ…å¢ƒè¨­å‚™\nlet scenes = [\n    // å ´æ™¯ç‡ˆå…‰ç¾¤çµ„ (ç”¨æ–¼å ´æ™¯æ§åˆ¶)\n    // { id: \"scene_single_11-1--11-2--12-1--12-2--12-3--12-4\", name: \"å…¬å…±å€ç‡ˆçµ„\" },\n    // { id: \"scene_single_13-1--13-2--13-3\", name: \"æœƒè­°å®¤ç‡ˆçµ„\" },\n    // { id: \"scene_dual_14-a--14-b\", name: \"æœƒè­°å®¤é›™è‰²æº«ç‡ˆçµ„\" },\n    // { id: \"scene_single_15-1--15-2--16-1--17-1--18-1--18-2--19-1--19-2\", name: \"äºŒæ¨“ç‡ˆçµ„\" },\n    // { id: \"scene_single_18-1--18-2--19-1--19-2\", name: \"æˆ¶å¤–ç‡ˆçµ„\" },\n];\n\n// 3. çª—ç°¾/æ²ç°¾è¨­å‚™\nlet covers = [\n    { id: \"curtain_21_1-2-3\", name: \"éµæ²é–€\" },\n    { id: \"curtain_22_1-2\", name: \"æœƒè­°å®¤æ²ç°¾\" },\n    { id: \"curtain_23_1-2\", name: \"å¸ƒç°¾\" },\n    { id: \"curtain_23_3-4\", name: \"æ²™ç°¾\" },\n    { id: \"curtain_23_5-6-7\", name: \"æ’ç…™çª—\" },\n];\n\n// 4. ç©ºèª¿è¨­å‚™\nlet climates = [\n    { id: \"200-1\", name: \"å®¢å»³ç©ºèª¿\" },\n    { id: \"200-2\", name: \"æœƒè­°å®¤ç©ºèª¿\" },\n    { id: \"200-3\", name: \"ç„é—œç©ºèª¿\" },\n    { id: \"200-9\", name: \"è¾¦å…¬å®¤æ¸¬è©¦\" }\n];\n\n// ============ é…ç½®ç”Ÿæˆå‡½æ•¸ ============\n\n// ç”Ÿæˆç‡ˆå…‰é…ç½®\nfunction generateLightConfigs(lights) {\n    return lights.map(light => {\n        let parts = light.id.split(\"_\");\n        let basePayload = {\n            name: light.name,\n            unique_id: light.id,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            optimistic: true,\n            state_topic: `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/state`,\n            command_topic: `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set`,\n        };\n        \n        switch(parts[0]) {\n            case \"single\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/colortemp`;\n                basePayload.color_temp_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"relay\": {\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/light/${light.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆæƒ…å¢ƒé…ç½®\nfunction generateSceneConfigs(scenes) {\n    return scenes.map(scene => {\n        let parts = scene.id.split(\"_\");\n        let prefix = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}`;\n        let basePayload = {\n            name: scene.name,\n            unique_id: scene.id,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            optimistic: true,\n            state_topic: `${prefix}/state`,\n            command_topic: `${prefix}/set`,\n        };\n        \n        switch(parts[1]) {\n            case \"single\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `${prefix}/colortemp`;\n                basePayload.color_temp_command_topic = `${prefix}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"relay\": {\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/light/${scene.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆçª—ç°¾é…ç½®\nfunction generateCoverConfigs(covers) {\n    return covers.map(cover => {\n        let part = cover.id.split(\"_\");\n        let device_type = part[0];\n        let id = part[1];\n        let control = (part[2]).split(\"-\");\n\n        let basePayload = {\n            name: cover.name,\n            unique_id: cover.id,\n            optimistic: true,\n            retain: true\n        };\n\n        let operation_type;\n        switch (control.length) {\n            case 2: {\n                operation_type = \"oc\";\n                basePayload.payload_open = `${control[0]}/${control[1]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}`;\n                basePayload.payload_stop = `${control[0]}_${control[1]}/`;\n                break;\n            }\n            case 3: {\n                operation_type = \"ocs\";\n                basePayload.payload_open = `${control[0]}/${control[1]}_${control[2]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}_${control[2]}`;\n                basePayload.payload_stop = `${control[2]}/${control[0]}_${control[1]}`;\n                break;\n            }\n            default: {\n                node.warn(\"Unknown type of curtain\");\n                break;\n            }\n        }\n        \n        basePayload.command_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/set`;\n        basePayload.state_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/state`;\n\n        return {\n            topic: `homeassistant/cover/${cover.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆç©ºèª¿é…ç½®\nfunction generateClimateConfigs(climates) {\n    let ui_name = \"climate\";\n    let topic_name = \"hvac\";\n\n    return climates.map(ac => {\n        const parts = ac.id.split(\"-\");\n        const s200_id = parts[0];\n        const id = parts[1];\n        const prefix = `homeassistant/${topic_name}/${s200_id}/${id}`;\n\n        const base = {\n            name: ac.name,\n            unique_id: ac.id,\n            optimistic: true,\n            modes: [\"off\", \"cool\", \"heat\", \"dry\", \"fan_only\", \"auto\"],\n            mode_command_topic: `${prefix}/mode/set`,\n            mode_state_topic: `${prefix}/mode/state`,\n            temperature_command_topic: `${prefix}/temperature/set`,\n            temperature_state_topic: `${prefix}/temperature/state`,\n            min_temp: 16,\n            max_temp: 30,\n            temp_step: 1,\n            current_temperature_topic: `${prefix}/current_temperature`,\n            fan_modes: [\"auto\", \"low\", \"medium\", \"high\"],\n            fan_mode_command_topic: `${prefix}/fan/set`,\n            fan_mode_state_topic: `${prefix}/fan/state`,\n            retain: true,\n        };\n\n        return {\n            topic: `homeassistant/${ui_name}/${ac.id}/config`,\n            payload: base,\n            retain: true\n        };\n    });\n}\n\n// ============ ä¸»è¦åŸ·è¡Œ ============\n\n// ç”Ÿæˆæ‰€æœ‰é…ç½®\nlet allMessages = [\n    ...generateLightConfigs(lights),\n    ...generateSceneConfigs(scenes),\n    ...generateCoverConfigs(covers),\n    ...generateClimateConfigs(climates)\n];\n\n// è¿”å›æ‰€æœ‰è¨Šæ¯\nreturn [allMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 80,
        "wires": [
            [
                "9508d90a31f87e7d"
            ]
        ]
    },
    {
        "id": "9508d90a31f87e7d",
        "type": "mqtt out",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 490,
        "y": 80,
        "wires": []
    },
    {
        "id": "109a527e86772924",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "d": true,
        "g": "4083c014c4036df7",
        "name": "è¼ªè©¢",
        "props": [],
        "repeat": "5",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 710,
        "y": 360,
        "wires": [
            [
                "2f06524972ea7ed5"
            ]
        ]
    },
    {
        "id": "2f06524972ea7ed5",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¼ªè©¢",
        "func": "/**\n * è¼ªè©¢æŸ¥è©¢ - å®šæœŸæŸ¥è©¢æ‰€æœ‰è¨­å‚™ç‹€æ…‹\n * \n * ä½¿ç”¨æ–¹å¼ï¼š\n * 1. ç”¨ inject ç¯€é»è§¸ç™¼ï¼ˆè¨­å®š intervalï¼Œä¾‹å¦‚æ¯ 5 ç§’ï¼‰\n * 2. é€£æ¥åˆ°æ­¤ function node\n * 3. è¼¸å‡ºé€£åˆ° MQTT outï¼Œç™¼å¸ƒæŸ¥è©¢ä¸»é¡Œ\n */\n\n// è¨­å®šè¦æŸ¥è©¢çš„è¨­å‚™åˆ—è¡¨\nconst QUERY_DEVICES = [\n    // ========== ç›¤A å–®è‰²ç‡ˆå…‰ ==========\n    { type: \"single\", moduleId: 11, channel: \"1\" },  // èµ°å»Šé–“ç…§\n    { type: \"single\", moduleId: 11, channel: \"2\" },  // èµ°å»Šé–“ç…§\n    { type: \"single\", moduleId: 12, channel: \"1\" },  // æ³¡èŒ¶å€\n    { type: \"single\", moduleId: 12, channel: \"2\" },  // èµ°é“å´ç‡ˆ\n    { type: \"single\", moduleId: 12, channel: \"3\" },  // å±•ç¤ºæ«ƒ\n    { type: \"single\", moduleId: 12, channel: \"4\" },  // å±•ç¤ºæ«ƒ\n    { type: \"single\", moduleId: 13, channel: \"1\" },  // æœƒè­°é–“ç…§\n    { type: \"single\", moduleId: 13, channel: \"2\" },  // å†·æ°£é–“ç…§\n    { type: \"single\", moduleId: 13, channel: \"3\" },  // æœƒè­°å´ç‡ˆ\n    { type: \"single\", moduleId: 13, channel: \"4\" },  // single-13-4\n    \n    // ========== ç›¤A é›™è‰²æº«ç‡ˆå…‰ ==========\n    { type: \"dual\", moduleId: 14, channel: \"a\" },    // æœƒè­°å®¤é›™è‰²æº«A\n    { type: \"dual\", moduleId: 14, channel: \"b\" },    // æœƒè­°å®¤é›™è‰²æº«B\n    \n    // ========== ç›¤B å–®è‰²ç‡ˆå…‰ ==========\n    { type: \"single\", moduleId: 15, channel: \"1\" },  // å®¢å»³å‰\n    { type: \"single\", moduleId: 15, channel: \"2\" },  // å®¢å»³å¾Œ\n    { type: \"single\", moduleId: 16, channel: \"1\" },  // èµ°é“é–“ç…§\n    { type: \"single\", moduleId: 16, channel: \"2\" },  // èµ°é“é–“ç…§\n    { type: \"single\", moduleId: 17, channel: \"1\" },  // å»šæˆ¿\n    { type: \"single\", moduleId: 17, channel: \"2\" },  // å»šæˆ¿\n    { type: \"single\", moduleId: 18, channel: \"1\" },  // 1Få£ç‡ˆ\n    { type: \"single\", moduleId: 18, channel: \"2\" },  // 1Fåœ°ç‡ˆ\n    { type: \"single\", moduleId: 19, channel: \"1\" },  // 2Få£ç‡ˆ\n    { type: \"single\", moduleId: 19, channel: \"2\" },  // 2Fåœ°ç‡ˆ\n    \n    // ========== çª—ç°¾/æ²ç°¾ (å¯é¸) ==========\n    // { type: \"curtain\", moduleId: 21, channel: \"1-2-3\" },  // éµæ²é–€\n    // { type: \"curtain\", moduleId: 22, channel: \"1-2\" },    // æœƒè­°å®¤æ²ç°¾\n    // { type: \"curtain\", moduleId: 23, channel: \"1-2\" },    // å¸ƒç°¾\n    // { type: \"curtain\", moduleId: 23, channel: \"3-4\" },    // æ²™ç°¾\n    // { type: \"curtain\", moduleId: 23, channel: \"5-6-7\" },  // æ’ç…™çª—\n];\n\n// ç”¢ç”ŸæŸ¥è©¢è¨Šæ¯\nconst queryMessages = QUERY_DEVICES.map(device => ({\n    topic: `homeassistant/query/${device.type}/${device.moduleId}/${device.channel}`,\n    payload: \"query\"\n}));\nnode.status({\n    fill: \"blue\",\n    shape: \"ring\",\n    text: `æŸ¥è©¢ ${queryMessages.length} å€‹è¨­å‚™`\n});\n\n// è¿”å›å¤šå€‹è¨Šæ¯ï¼ˆæ¯å€‹è¨­å‚™ä¸€å€‹ï¼‰\nreturn [queryMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 360,
        "wires": [
            [
                "27bd656af41458c7"
            ]
        ]
    },
    {
        "id": "0b1b39be9f383857",
        "type": "mqtt in",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "",
        "topic": "homeassistant/query/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 160,
        "wires": [
            [
                "27bd656af41458c7"
            ]
        ]
    },
    {
        "id": "d1a4a99a2680edb7",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "modbus queue",
        "func": "// è¨­å®š\nconst TIMEOUT_MS = 500;  // ç­‰å¾… feedback è¶…æ™‚æ™‚é–“ (æ¯«ç§’)\n\n// Debug æ§åˆ¶ - å¼·åˆ¶å•Ÿç”¨ queue debug\nconst globalDebug = global.get('debug_config') || {};\nconst debugConfig = {\n    topic: globalDebug.topic !== false,\n    cache: globalDebug.cache !== false,\n    modbus: globalDebug.modbus !== false,\n    mqtt: globalDebug.mqtt !== false,\n    scene: globalDebug.scene !== false,\n    query: globalDebug.query !== false,\n    queue: true  // Queue debug å¼·åˆ¶é–‹å•Ÿ\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\n// åˆå§‹åŒ–ä½‡åˆ—ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰\nlet queue = flow.get('modbus_queue') || [];\nlet isProcessing = flow.get('modbus_queue_processing') || false;\nlet currentCmd = flow.get('modbus_queue_current') || null;\nlet lastSendTime = flow.get('modbus_queue_last_send') || 0;\n\n// åˆ¤æ–·è¼¸å…¥é¡å‹\nconst action = msg.topic || \"\";\n\n// ===== ENQUEUE: å°‡æŒ‡ä»¤åŠ å…¥ä½‡åˆ— =====\n// å¦‚æœ topic ä¸æ˜¯ queue æ§åˆ¶æŒ‡ä»¤ï¼Œå°±ç•¶ä½œæ˜¯ enqueue\nconst isQueueCommand = action.startsWith(\"modbus/queue/\");\nif (!isQueueCommand) {\n    // æ”¯æ´å–®å€‹æˆ–å¤šå€‹æŒ‡ä»¤\n    const commands = Array.isArray(msg) ? msg : [msg];\n    \n    for (const cmd of commands) {\n        // ç¢ºä¿æœ‰ payloadï¼ˆBufferï¼‰\n        if (cmd.payload && Buffer.isBuffer(cmd.payload)) {\n            queue.push({\n                payload: cmd.payload,\n                subType: cmd.subType,\n                moduleId: cmd.moduleId,\n                channel: cmd.channel,\n                state: cmd.state,\n                brightness: cmd.brightness,\n                colortemp: cmd.colortemp,\n                deviceType: cmd.deviceType,\n                queryInfo: cmd.queryInfo,\n                timestamp: Date.now()\n            });\n            debugLog('queue', `å…¥éšŠ: Module ${cmd.moduleId} Channel ${cmd.channel} - ${cmd.payload.toString('hex')}`);\n        }\n    }\n    \n    flow.set('modbus_queue', queue);\n    debugLog('queue', `ä½‡åˆ—é•·åº¦: ${queue.length}`);\n    \n    // å¦‚æœç›®å‰æ²’æœ‰åœ¨è™•ç†ï¼Œé–‹å§‹è™•ç†\n    if (!isProcessing) {\n        sendNext();\n    }\n    \n    updateStatus();\n    return null;\n}\n\n// ===== DEQUEUE: æ”¶åˆ° feedbackï¼Œç™¼é€ä¸‹ä¸€å€‹ =====\nif (action === \"modbus/queue/dequeue\") {\n    debugLog('queue', `æ”¶åˆ° feedbackï¼Œæº–å‚™ç™¼é€ä¸‹ä¸€å€‹`);\n    \n    // æ¸…é™¤ç•¶å‰æŒ‡ä»¤\n    flow.set('modbus_queue_current', null);\n    \n    // ç™¼é€ä¸‹ä¸€å€‹\n    sendNext();\n    return null;\n}\n\n// ===== TIMEOUT: è¶…æ™‚ï¼Œå¼·åˆ¶ç™¼é€ä¸‹ä¸€å€‹ =====\nif (action === \"modbus/queue/timeout\") {\n    const now = Date.now();\n    const elapsed = now - lastSendTime;\n    \n    // é¡¯ç¤ºè¶…æ™‚æª¢æŸ¥ç‹€æ…‹\n    if (isProcessing) {\n        debugLog('queue', `â±ï¸ è¶…æ™‚æª¢æŸ¥: å·²ç­‰å¾… ${elapsed}ms / ${TIMEOUT_MS}msï¼Œä½‡åˆ—å‰©é¤˜: ${queue.length}`);\n    }\n\n    if (isProcessing && elapsed >= TIMEOUT_MS) {\n        debugLog('queue', `âš ï¸ è¶…æ™‚ ${elapsed}msï¼Œå¼·åˆ¶ç™¼é€ä¸‹ä¸€å€‹`);\n        flow.set('modbus_queue_current', null);\n        sendNext();\n    }\n    return null;\n}\n\n// ===== CLEAR: æ¸…ç©ºä½‡åˆ— =====\nif (action === \"modbus/queue/clear\") {\n    queue = [];\n    flow.set('modbus_queue', []);\n    flow.set('modbus_queue_processing', false);\n    flow.set('modbus_queue_current', null);\n    \n    debugLog('queue', `ä½‡åˆ—å·²æ¸…ç©º`);\n    node.status({ fill: \"grey\", shape: \"ring\", text: \"ä½‡åˆ—å·²æ¸…ç©º\" });\n    return null;\n}\n\n// ===== STATUS: æŸ¥è©¢ä½‡åˆ—ç‹€æ…‹ =====\nif (action === \"modbus/queue/status\") {\n    const status = {\n        queueLength: queue.length,\n        isProcessing: isProcessing,\n        currentCmd: currentCmd,\n        lastSendTime: lastSendTime\n    };\n    \n    debugLog('queue', `ä½‡åˆ—ç‹€æ…‹: ${JSON.stringify(status)}`);\n    return [{ payload: status }];\n}\n\n// ===== ç™¼é€ä¸‹ä¸€å€‹æŒ‡ä»¤ =====\nfunction sendNext() {\n    queue = flow.get('modbus_queue') || [];\n    \n    if (queue.length === 0) {\n        // ä½‡åˆ—ç©ºäº†\n        flow.set('modbus_queue_processing', false);\n        flow.set('modbus_queue_current', null);\n        node.status({ fill: \"green\", shape: \"ring\", text: \"ä½‡åˆ—ç©º\" });\n        debugLog('queue', `ä½‡åˆ—è™•ç†å®Œæˆ`);\n        return;\n    }\n    \n    // å–å‡ºç¬¬ä¸€å€‹æŒ‡ä»¤\n    const cmd = queue.shift();\n    flow.set('modbus_queue', queue);\n    flow.set('modbus_queue_processing', true);\n    flow.set('modbus_queue_current', cmd);\n    flow.set('modbus_queue_last_send', Date.now());\n    \n    debugLog('queue', `ç™¼é€: Module ${cmd.moduleId} Ch ${cmd.channel} - ${cmd.payload.toString('hex')} (å‰©é¤˜ ${queue.length})`);\n    updateStatus();\n    \n    // å„²å­˜ç•¶å‰æŸ¥è©¢è³‡è¨Šåˆ° flow contextï¼Œè®“ Feedback å¯ä»¥è®€å–\n    // å› ç‚º TCP Request æœƒè¦†è“‹ msg å±¬æ€§\n    flow.set('modbus_current_query', {\n        queryInfo: cmd.queryInfo,\n        moduleId: cmd.moduleId,\n        channel: cmd.channel,\n        subType: cmd.subType,\n        timestamp: Date.now()\n    });\n\n    // ç™¼é€åˆ° Modbus\n    node.send([{\n        payload: cmd.payload,\n        queryInfo: cmd.queryInfo,\n        moduleId: cmd.moduleId,\n        channel: cmd.channel,\n        subType: cmd.subType\n    }]);\n}\n\n// ===== æ›´æ–°ç¯€é»ç‹€æ…‹ =====\nfunction updateStatus() {\n    queue = flow.get('modbus_queue') || [];\n    isProcessing = flow.get('modbus_queue_processing') || false;\n    \n    if (queue.length === 0 && !isProcessing) {\n        node.status({ fill: \"green\", shape: \"ring\", text: \"ä½‡åˆ—ç©º\" });\n    } else if (isProcessing) {\n        node.status({ fill: \"yellow\", shape: \"dot\", text: `è™•ç†ä¸­... å‰©é¤˜ ${queue.length}` });\n    } else {\n        node.status({ fill: \"blue\", shape: \"ring\", text: `ç­‰å¾…ä¸­ ${queue.length}` });\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 100,
        "wires": [
            [
                "7fdc77cd054beb5f"
            ]
        ]
    },
    {
        "id": "14ec3164167b547e",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¶…æ™‚æª¢æŸ¥",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.5",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "modbus/queue/timeout",
        "x": 550,
        "y": 220,
        "wires": [
            [
                "d1a4a99a2680edb7"
            ]
        ]
    },
    {
        "id": "751ec40a6956d4f9",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.1.233",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]