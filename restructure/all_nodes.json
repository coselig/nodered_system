[
    {
        "id": "918f3507cd7a1bdb",
        "type": "tab",
        "label": "流程1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "fb57242cb9e172c0",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "name": "完整整合測試：Light (Single/Dual/Relay) + Cover + Scene",
        "style": {
            "label": true,
            "stroke": "#ffffff",
            "fill": "#ffffff",
            "fill-opacity": "0.84"
        },
        "nodes": [
            "dac87db5e5134ba1",
            "00fc94dcc0e6fe7f",
            "99d1dfc6ef0aa602",
            "d21f93e8956ae8bb",
            "b51b480e5f185bfc",
            "7e517cbd0d6a2b1b",
            "efe6ce61475a1013",
            "edaf75594da93e05"
        ],
        "x": 8,
        "y": 33,
        "w": 1970,
        "h": 1006
    },
    {
        "id": "dac87db5e5134ba1",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "name": "",
        "style": {
            "label": true
        },
        "nodes": [
            "09355db1cc3a986d",
            "055cc37079b82ab5",
            "9170f2b152fd9be8",
            "26d25976970ff0bc",
            "dbde6dfa859f35b6"
        ],
        "x": 1054,
        "y": 813,
        "w": 898,
        "h": 174
    },
    {
        "id": "d21f93e8956ae8bb",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "42ca78bd7955dd6e",
            "afbb3323b0019313",
            "cbba2a59267c9170"
        ],
        "x": 1354,
        "y": 414,
        "w": 472,
        "h": 107
    },
    {
        "id": "b51b480e5f185bfc",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "name": "",
        "style": {
            "fill": "#92d04f",
            "fill-opacity": "0.28",
            "label": false
        },
        "nodes": [
            "789f1b9093d9c317",
            "a39fa7e4e13321cf",
            "4029932648511b89",
            "b2e16ab080b67607",
            "3d3ed32a5326765b",
            "5cec37bbc72a7354",
            "92794b29622d2433",
            "39668f9c3a056ad9",
            "ea69f13e8702d45c",
            "11349d39ba474ecf"
        ],
        "x": 34,
        "y": 59,
        "w": 1228,
        "h": 242
    },
    {
        "id": "efe6ce61475a1013",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "name": "",
        "style": {
            "fill": "#d1d1d1",
            "fill-opacity": "0.2",
            "label": true
        },
        "nodes": [
            "737caad79ddcbbc0",
            "6ba6f25c2eb002d5",
            "aaded790b4189354",
            "bdae5a6694b1a8cb",
            "5ef6650c7d60c1ae",
            "4b09975535cd95ad",
            "b828e18badfd46c7",
            "341b7da26be90f5e",
            "6b616925f063fb80",
            "0eca5b8723256271",
            "dcede551fa7f5720",
            "ede94bdeed93267f",
            "e6977952aa6de905",
            "6ace5dde2da93230",
            "a87c5b176708ceca"
        ],
        "x": 36.33331298828125,
        "y": 314.6666564941406,
        "w": 989.6666870117188,
        "h": 698.3333435058594
    },
    {
        "id": "edaf75594da93e05",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "72168b0198872955",
            "f85efdd437bcc1a2",
            "05cc16e472846fc6",
            "a79644de1f2ebde6",
            "f441a5a695b62120",
            "24d4d68139ea2355",
            "c54df2b47b60c495",
            "c2943fa3f8dc6c36",
            "5a56f0e7e6183780",
            "3e27951d637d9283"
        ],
        "x": 1054,
        "y": 579,
        "w": 732,
        "h": 187
    },
    {
        "id": "dbde6dfa859f35b6",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "dac87db5e5134ba1",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "1b163f83e680545a",
            "fadd0696d15b6c90",
            "642b321b5291c8a0",
            "a01e0bc7bcd37dce"
        ],
        "x": 1514,
        "y": 839,
        "w": 412,
        "h": 122
    },
    {
        "id": "ede94bdeed93267f",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "",
        "style": {
            "fill": "#ffcf3f",
            "fill-opacity": "0.21",
            "label": true
        },
        "nodes": [
            "7c8b51b7ef1f8656",
            "c457fdf1f1a294d7",
            "3038cff7fcb502a2",
            "dbcccac221a92702",
            "cfcbe05d9a019aaa",
            "cdff7173f5bfc4c0",
            "318d287fc5676b16",
            "fe42c150024f1c6e",
            "98394daf1a815f2b",
            "d1af9f4f42045c6b",
            "673e66e79a4eed7f",
            "2a1a39256a6f96ce"
        ],
        "x": 62.33331298828125,
        "y": 340.6666564941406,
        "w": 612,
        "h": 240.3333444595337
    },
    {
        "id": "6ace5dde2da93230",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "H40/H70場景處理器",
        "style": {
            "label": true,
            "fill": "#ff7f7f",
            "fill-opacity": "0.12"
        },
        "nodes": [
            "872803830a56f19b",
            "d07b2d2692c0e261",
            "30f0b97cb1e3438a"
        ],
        "x": 68,
        "y": 853,
        "w": 678,
        "h": 134
    },
    {
        "id": "11349d39ba474ecf",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "輪詢",
        "style": {
            "fill": "#ffff3f",
            "fill-opacity": "0.16",
            "label": true
        },
        "nodes": [
            "57ef8201cf58ceec",
            "bc699f7fdbcf063e",
            "1f0cc50a5210bb5b"
        ],
        "x": 814,
        "y": 159,
        "w": 422,
        "h": 82
    },
    {
        "id": "30f0b97cb1e3438a",
        "type": "group",
        "z": "918f3507cd7a1bdb",
        "g": "6ace5dde2da93230",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "192cb4059a9825fe"
        ],
        "x": 94,
        "y": 879,
        "w": 252,
        "h": 82
    },
    {
        "id": "42ca78bd7955dd6e",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "d21f93e8956ae8bb",
        "x": 1380,
        "y": 440,
        "wires": [
            [
                "cbba2a59267c9170"
            ]
        ]
    },
    {
        "id": "afbb3323b0019313",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "d21f93e8956ae8bb",
        "x": 1800,
        "y": 440,
        "wires": [
            [
                "c54df2b47b60c495"
            ]
        ]
    },
    {
        "id": "a39fa7e4e13321cf",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "x": 240,
        "y": 180,
        "wires": [
            [
                "3d3ed32a5326765b",
                "5cec37bbc72a7354",
                "92794b29622d2433",
                "789f1b9093d9c317",
                "ea69f13e8702d45c"
            ]
        ]
    },
    {
        "id": "4029932648511b89",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "x": 620,
        "y": 180,
        "wires": [
            [
                "39668f9c3a056ad9"
            ]
        ]
    },
    {
        "id": "7e517cbd0d6a2b1b",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "x": 1860,
        "y": 740,
        "wires": [
            [
                "00fc94dcc0e6fe7f"
            ]
        ]
    },
    {
        "id": "0eca5b8723256271",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "x": 820,
        "y": 580,
        "wires": [
            [
                "737caad79ddcbbc0"
            ]
        ]
    },
    {
        "id": "dcede551fa7f5720",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "x": 820,
        "y": 600,
        "wires": [
            [
                "e6977952aa6de905"
            ]
        ]
    },
    {
        "id": "98394daf1a815f2b",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "x": 648.3333129882812,
        "y": 421.6666564941406,
        "wires": [
            [
                "0eca5b8723256271"
            ]
        ]
    },
    {
        "id": "d1af9f4f42045c6b",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "x": 648.3333129882812,
        "y": 461.6666564941406,
        "wires": [
            [
                "dcede551fa7f5720"
            ]
        ]
    },
    {
        "id": "a79644de1f2ebde6",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "x": 1600,
        "y": 640,
        "wires": [
            [
                "7e517cbd0d6a2b1b"
            ]
        ]
    },
    {
        "id": "f441a5a695b62120",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "x": 1600,
        "y": 660,
        "wires": [
            [
                "3e27951d637d9283"
            ]
        ]
    },
    {
        "id": "c54df2b47b60c495",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "x": 1080,
        "y": 660,
        "wires": [
            [
                "24d4d68139ea2355"
            ]
        ]
    },
    {
        "id": "c2943fa3f8dc6c36",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "x": 1320,
        "y": 740,
        "wires": [
            [
                "5a56f0e7e6183780"
            ]
        ]
    },
    {
        "id": "5a56f0e7e6183780",
        "type": "junction",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "x": 1480,
        "y": 740,
        "wires": [
            [
                "a79644de1f2ebde6"
            ]
        ]
    },
    {
        "id": "09355db1cc3a986d",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "dac87db5e5134ba1",
        "name": "Debug 全開",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":true,\"cache\":true,\"modbus\":true,\"mqtt\":true,\"scene\":true,\"query\":true,\"hmi\":true}",
        "payloadType": "json",
        "x": 1170,
        "y": 860,
        "wires": [
            [
                "26d25976970ff0bc"
            ]
        ]
    },
    {
        "id": "055cc37079b82ab5",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "dac87db5e5134ba1",
        "name": "Debug 全關",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":false,\"cache\":false,\"modbus\":false,\"mqtt\":false,\"scene\":false,\"query\":false,\"hmi\":false}",
        "payloadType": "json",
        "x": 1170,
        "y": 900,
        "wires": [
            [
                "26d25976970ff0bc"
            ]
        ]
    },
    {
        "id": "9170f2b152fd9be8",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "dac87db5e5134ba1",
        "name": "只看 Modbus",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":false,\"cache\":false,\"modbus\":true,\"mqtt\":false,\"scene\":false,\"query\":false,\"hmi\":false}",
        "payloadType": "json",
        "x": 1170,
        "y": 940,
        "wires": [
            [
                "26d25976970ff0bc"
            ]
        ]
    },
    {
        "id": "26d25976970ff0bc",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "dac87db5e5134ba1",
        "name": "設定 Debug 配置",
        "func": "const config = msg.payload;\nglobal.set('debug_config', config);\n\nnode.warn('=== Debug 配置已更新 ===');\nnode.warn(`Topic: ${config.topic ? 'ON' : 'OFF'}`);\nnode.warn(`Cache: ${config.cache ? 'ON' : 'OFF'}`);\nnode.warn(`Modbus: ${config.modbus ? 'ON' : 'OFF'}`);\nnode.warn(`MQTT: ${config.mqtt ? 'ON' : 'OFF'}`);\nnode.warn(`Scene: ${config.scene ? 'ON' : 'OFF'}`);\nnode.warn(`Query: ${config.query ? 'ON' : 'OFF'}`);\nnode.warn(`HMI: ${config.hmi ? 'ON' : 'OFF'}`);\n\nnode.status({\n    fill: 'green',\n    shape: 'dot',\n    text: `已更新 Debug 配置`\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 900,
        "wires": [
            []
        ]
    },
    {
        "id": "1b163f83e680545a",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "dbde6dfa859f35b6",
        "name": "清除快取",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1620,
        "y": 880,
        "wires": [
            [
                "fadd0696d15b6c90"
            ]
        ]
    },
    {
        "id": "fadd0696d15b6c90",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "dbde6dfa859f35b6",
        "name": "清除所有快取",
        "func": "const keys = flow.keys();\nlet count = 0;\nkeys.forEach(k => {\n    if (k.startsWith('single_') || k.startsWith('dual_') || k.startsWith('relay_') || k.startsWith('scene_')) {\n        flow.set(k, undefined);\n        node.warn(`清除: ${k}`);\n        count++;\n    }\n});\nnode.warn(`=== 已清除 ${count} 筆快取 ===`);\nnode.status({\n    fill: \"blue\",\n    shape: \"ring\",\n    text: `已清除 ${count} 筆`\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "642b321b5291c8a0",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "dbde6dfa859f35b6",
        "name": "顯示快取",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 1620,
        "y": 920,
        "wires": [
            [
                "a01e0bc7bcd37dce"
            ]
        ]
    },
    {
        "id": "a01e0bc7bcd37dce",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "dbde6dfa859f35b6",
        "name": "顯示所有快取",
        "func": "node.warn(\"=== Flow Context 內容 ===\");\nconst keys = flow.keys();\nconst filtered = keys.filter(k => \n    k.startsWith('single_') || \n    k.startsWith('dual_') || \n    k.startsWith('relay_') || \n    k.startsWith('scene_')\n);\n\nif (filtered.length === 0) {\n    node.warn(\"目前沒有任何快取資料\");\n} else {\n    // 分類顯示\n    const groups = {\n        single: [],\n        dual: [],\n        relay: [],\n        scene: []\n    };\n    \n    filtered.forEach(k => {\n        const value = flow.get(k);\n        if (k.startsWith('single_')) groups.single.push(`${k}: ${value}`);\n        else if (k.startsWith('dual_')) groups.dual.push(`${k}: ${value}`);\n        else if (k.startsWith('relay_')) groups.relay.push(`${k}: ${value}`);\n        else if (k.startsWith('scene_')) groups.scene.push(`${k}: ${value}`);\n    });\n    \n    if (groups.single.length > 0) {\n        node.warn(\"--- Single ---\");\n        groups.single.forEach(s => node.warn(s));\n    }\n    if (groups.dual.length > 0) {\n        node.warn(\"--- Dual ---\");\n        groups.dual.forEach(s => node.warn(s));\n    }\n    if (groups.relay.length > 0) {\n        node.warn(\"--- Relay ---\");\n        groups.relay.forEach(s => node.warn(s));\n    }\n    if (groups.scene.length > 0) {\n        node.warn(\"--- Scene ---\");\n        groups.scene.forEach(s => node.warn(s));\n    }\n    \n    node.warn(`=== 共 ${filtered.length} 筆快取 ===`);\n}\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1820,
        "y": 920,
        "wires": [
            []
        ]
    },
    {
        "id": "00fc94dcc0e6fe7f",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "name": "modbus queue",
        "func": "// 設定\nconst TIMEOUT_MS = 100;  // 等待 feedback 超時時間 (毫秒)\nconst MAX_QUEUE_SIZE = 100;  // 佇列最大長度，超過自動清空\n\n// Debug 控制 - 強制啟用 queue debug\nconst globalDebug = global.get('debug_config') || {};\nconst debugConfig = {\n    topic: globalDebug.topic !== false,\n    cache: globalDebug.cache !== false,\n    modbus: globalDebug.modbus !== false,\n    mqtt: globalDebug.mqtt !== false,\n    scene: globalDebug.scene !== false,\n    query: globalDebug.query !== false,\n    queue: true  // Queue debug 強制開啟\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\n// 初始化佇列（如果不存在）\nlet queue = flow.get('modbus_queue') || [];\nlet isProcessing = flow.get('modbus_queue_processing') || false;\nlet currentCmd = flow.get('modbus_queue_current') || null;\nlet lastSendTime = flow.get('modbus_queue_last_send') || 0;\n\n// 判斷輸入類型\nconst action = msg.topic || \"\";\n\n// ===== ENQUEUE: 將指令加入佇列 =====\n// 如果 topic 不是 queue 控制指令，就當作是 enqueue\nconst isQueueCommand = action.startsWith(\"modbus/queue/\");\nif (!isQueueCommand) {\n    // 支援單個或多個指令\n    const commands = Array.isArray(msg) ? msg : [msg];\n    \n    for (const cmd of commands) {\n        // 確保有 payload（Buffer）\n        if (cmd.payload && Buffer.isBuffer(cmd.payload)) {\n            queue.push({\n                payload: cmd.payload,\n                subType: cmd.subType,\n                moduleId: cmd.moduleId,\n                channel: cmd.channel,\n                state: cmd.state,\n                brightness: cmd.brightness,\n                colortemp: cmd.colortemp,\n                deviceType: cmd.deviceType,\n                queryInfo: cmd.queryInfo,\n                timestamp: Date.now()\n            });\n            debugLog('queue', `入隊: Module ${cmd.moduleId} Channel ${cmd.channel} - ${cmd.payload.toString('hex')}`);\n        }\n    }\n    \n    flow.set('modbus_queue', queue);\n    debugLog('queue', `佇列長度: ${queue.length}`);\n    \n    // 佇列過長，自動清空\n    if (queue.length > MAX_QUEUE_SIZE) {\n        node.warn(`⚠️ 佇列超過 ${MAX_QUEUE_SIZE} 個指令，自動清空！`);\n        queue = [];\n        flow.set('modbus_queue', []);\n        flow.set('modbus_queue_processing', false);\n        flow.set('modbus_queue_current', null);\n        node.status({ fill: \"red\", shape: \"ring\", text: `佇列溢出，已清空` });\n        return null;\n    }\n\n    // 如果目前沒有在處理，開始處理\n    if (!isProcessing) {\n        sendNext();\n    }\n    \n    updateStatus();\n    return null;\n}\n\n// ===== DEQUEUE: 收到 feedback，發送下一個 =====\nif (action === \"modbus/queue/dequeue\") {\n    debugLog('queue', `收到 feedback，準備發送下一個`);\n    \n    // 清除當前指令\n    flow.set('modbus_queue_current', null);\n    \n    // 發送下一個\n    sendNext();\n    return null;\n}\n\n// ===== TIMEOUT: 超時，強制發送下一個 =====\nif (action === \"modbus/queue/timeout\") {\n    const now = Date.now();\n    const elapsed = now - lastSendTime;\n    \n    // 顯示超時檢查狀態\n    if (isProcessing) {\n        debugLog('queue', `⏱️ 超時檢查: 已等待 ${elapsed}ms / ${TIMEOUT_MS}ms，佇列剩餘: ${queue.length}`);\n    }\n\n    if (isProcessing && elapsed >= TIMEOUT_MS) {\n        debugLog('queue', `⚠️ 超時 ${elapsed}ms，強制發送下一個`);\n        flow.set('modbus_queue_current', null);\n        sendNext();\n    }\n    return null;\n}\n\n// ===== CLEAR: 清空佇列 =====\nif (action === \"modbus/queue/clear\") {\n    queue = [];\n    flow.set('modbus_queue', []);\n    flow.set('modbus_queue_processing', false);\n    flow.set('modbus_queue_current', null);\n    \n    debugLog('queue', `佇列已清空`);\n    node.status({ fill: \"grey\", shape: \"ring\", text: \"佇列已清空\" });\n    return null;\n}\n\n// ===== STATUS: 查詢佇列狀態 =====\nif (action === \"modbus/queue/status\") {\n    const status = {\n        queueLength: queue.length,\n        isProcessing: isProcessing,\n        currentCmd: currentCmd,\n        lastSendTime: lastSendTime\n    };\n    \n    debugLog('queue', `佇列狀態: ${JSON.stringify(status)}`);\n    return [{ payload: status }];\n}\n\n// ===== 發送下一個指令 =====\nfunction sendNext() {\n    queue = flow.get('modbus_queue') || [];\n    \n    if (queue.length === 0) {\n        // 佇列空了\n        flow.set('modbus_queue_processing', false);\n        flow.set('modbus_queue_current', null);\n        node.status({ fill: \"green\", shape: \"ring\", text: \"佇列空\" });\n        debugLog('queue', `佇列處理完成`);\n        return;\n    }\n    \n    // 取出第一個指令\n    const cmd = queue.shift();\n    flow.set('modbus_queue', queue);\n    flow.set('modbus_queue_processing', true);\n    flow.set('modbus_queue_current', cmd);\n    flow.set('modbus_queue_last_send', Date.now());\n    \n    debugLog('queue', `發送: Module ${cmd.moduleId} Ch ${cmd.channel} - ${cmd.payload.toString('hex')} (剩餘 ${queue.length})`);\n    updateStatus();\n    \n    // 儲存當前查詢資訊到 flow context，讓 Feedback 可以讀取\n    // 因為 TCP Request 會覆蓋 msg 屬性\n    flow.set('modbus_current_query', {\n        queryInfo: cmd.queryInfo,\n        moduleId: cmd.moduleId,\n        channel: cmd.channel,\n        subType: cmd.subType,\n        timestamp: Date.now()\n    });\n\n    // 發送到 Modbus\n    node.send([{\n        payload: cmd.payload,\n        queryInfo: cmd.queryInfo,\n        moduleId: cmd.moduleId,\n        channel: cmd.channel,\n        subType: cmd.subType\n    }]);\n}\n\n// ===== 更新節點狀態 =====\nfunction updateStatus() {\n    queue = flow.get('modbus_queue') || [];\n    isProcessing = flow.get('modbus_queue_processing') || false;\n    \n    if (queue.length === 0 && !isProcessing) {\n        node.status({ fill: \"green\", shape: \"ring\", text: \"佇列空\" });\n    } else if (isProcessing) {\n        node.status({ fill: \"yellow\", shape: \"dot\", text: `處理中... 剩餘 ${queue.length}` });\n    } else {\n        node.status({ fill: \"blue\", shape: \"ring\", text: `等待中 ${queue.length}` });\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 500,
        "wires": [
            [
                "42ca78bd7955dd6e"
            ]
        ]
    },
    {
        "id": "99d1dfc6ef0aa602",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "fb57242cb9e172c0",
        "name": "超時檢查",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.2",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "modbus/queue/timeout",
        "x": 1150,
        "y": 420,
        "wires": [
            [
                "00fc94dcc0e6fe7f"
            ]
        ]
    },
    {
        "id": "cbba2a59267c9170",
        "type": "tcp request",
        "z": "918f3507cd7a1bdb",
        "g": "d21f93e8956ae8bb",
        "name": "",
        "server": "192.168.1.252",
        "port": "1030",
        "out": "time",
        "ret": "buffer",
        "splitc": "0",
        "newline": "",
        "trim": false,
        "tls": "",
        "x": 1590,
        "y": 480,
        "wires": [
            [
                "afbb3323b0019313"
            ]
        ]
    },
    {
        "id": "789f1b9093d9c317",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "註冊場景裝置",
        "func": "// 情境設備配置生成器\n// 支援: 燈光(single/dual/wrgb/relay)、窗簾(cover) 情境群組控制\n\n// ============ 情境設備定義 ============\n// ID 格式: scene_{deviceType}_{module-channel}--{module-channel}...\n// deviceType: single, dual, wrgb, relay, cover\n//\n// 燈光範例:\n//   scene_single_11-1--11-2       單色溫燈群組\n//   scene_dual_14-a--14-b         雙色溫燈群組\n//   scene_wrgb_2-x--11-x          WRGB燈群組\n//   scene_relay_10-1--10-2        Relay開關群組\n//\n// 窗簾範例:\n//   scene_cover_22-oc--23-oc      窗簾群組 (oc = open/close)\n\nlet scenes = [\n    // === 燈光場景 ===\n    // { id: \"scene_single_11-1--11-2\", name: \"走廊間照\" },\n    // { id: \"scene_single_12-1\", name: \"泡茶區\" },\n    // { id: \"scene_single_12-2\", name: \"走道崁燈\" },\n    // { id: \"scene_single_12-3--12-4\", name: \"展示櫃\" },\n    // { id: \"scene_single_13-1--13-2--13-3\", name: \"會議室燈組\" },\n    // { id: \"scene_dual_14-a--14-b\", name: \"會議室雙色溫燈組\" },\n    \n    // === WRGB 場景 ===\n    // { id: \"scene_wrgb_2-x--11-x\", name: \"WRGB燈組\" },\n    \n    // === Relay 場景 ===\n    // { id: \"scene_relay_10-1--10-2--10-3\", name: \"Relay開關組\" },\n    \n    // === 窗簾場景 ===\n    // { id: \"scene_cover_22-oc--23-oc\", name: \"窗簾群組\" },\n];\n\n// ============ 配置生成函數 ============\nfunction generateSceneConfigs(scenes) {\n    return scenes.map(scene => {\n        let parts = scene.id.split(\"_\");\n        // parts[0] = \"scene\"\n        // parts[1] = deviceType (single, dual, wrgb, relay, cover)\n        // parts[2] = devices (11-1--11-2)\n        let deviceType = parts[1];\n        let devices = parts[2];\n        \n        // 根據設備類型決定 HA 實體類型\n        let haEntityType = (deviceType === \"cover\") ? \"cover\" : \"light\";\n        let prefix = `homeassistant/${haEntityType}/scene/${deviceType}/${devices}`;\n        \n        let basePayload = {\n            name: scene.name,\n            unique_id: scene.id,\n            optimistic: true,\n            state_topic: `${prefix}/state`,\n            command_topic: `${prefix}/set`,\n        };\n        \n        switch(deviceType) {\n            case \"single\": {\n                // 單色溫燈: 開關 + 亮度\n                basePayload.payload_on = \"ON\";\n                basePayload.payload_off = \"OFF\";\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                // 雙色溫燈: 開關 + 亮度 + 色溫\n                basePayload.payload_on = \"ON\";\n                basePayload.payload_off = \"OFF\";\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `${prefix}/colortemp`;\n                basePayload.color_temp_command_topic = `${prefix}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"wrgb\": {\n                // WRGB燈: 開關 + 亮度 + RGB顏色\n                basePayload.payload_on = \"ON\";\n                basePayload.payload_off = \"OFF\";\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.rgb = true;\n                basePayload.rgb_state_topic = `${prefix}/rgb`;\n                basePayload.rgb_command_topic = `${prefix}/set/rgb`;\n                break;\n            }\n            case \"relay\": {\n                // Relay開關: 純開關\n                basePayload.payload_on = \"ON\";\n                basePayload.payload_off = \"OFF\";\n                break;\n            }\n            case \"cover\": {\n                // 窗簾: 開/關/停\n                basePayload.payload_open = \"OPEN\";\n                basePayload.payload_close = \"CLOSE\";\n                basePayload.payload_stop = \"STOP\";\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/${haEntityType}/${scene.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ============ 主要執行 ============\nlet allMessages = generateSceneConfigs(scenes);\nreturn [allMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 220,
        "wires": [
            [
                "4029932648511b89"
            ]
        ]
    },
    {
        "id": "b2e16ab080b67607",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "註冊虛擬裝置",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 150,
        "y": 180,
        "wires": [
            [
                "a39fa7e4e13321cf"
            ]
        ]
    },
    {
        "id": "3d3ed32a5326765b",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "註冊冷氣裝置",
        "func": "// 空調設備配置生成器\n// 支援: HVAC 空調控制\n\n// ============ 空調設備定義 ============\nlet climates = [\n];\n\n// ============ 配置生成函數 ============\nfunction generateClimateConfigs(climates) {\n    let ui_name = \"climate\";\n    let topic_name = \"hvac\";\n\n    return climates.map(ac => {\n        const parts = ac.id.split(\"-\");\n        const s200_id = parts[0];\n        const id = parts[1];\n        const prefix = `homeassistant/${topic_name}/${s200_id}/${id}`;\n\n        const base = {\n            name: ac.name,\n            unique_id: ac.id,\n            optimistic: true,\n            modes: [\"off\", \"cool\", \"heat\", \"dry\", \"fan_only\", \"auto\"],\n            mode_command_topic: `${prefix}/mode/set`,\n            mode_state_topic: `${prefix}/mode/state`,\n            temperature_command_topic: `${prefix}/temperature/set`,\n            temperature_state_topic: `${prefix}/temperature/state`,\n            min_temp: 16,\n            max_temp: 30,\n            temp_step: 1,\n            current_temperature_topic: `${prefix}/current_temperature`,\n            fan_modes: [\"auto\", \"low\", \"medium\", \"high\"],\n            fan_mode_command_topic: `${prefix}/fan/set`,\n            fan_mode_state_topic: `${prefix}/fan/state`,\n            retain: true,\n        };\n\n        return {\n            topic: `homeassistant/${ui_name}/${ac.id}/config`,\n            payload: base,\n            retain: true\n        };\n    });\n}\n\n// ============ 主要執行 ============\nlet allMessages = generateClimateConfigs(climates);\nreturn [allMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 100,
        "wires": [
            [
                "4029932648511b89"
            ]
        ]
    },
    {
        "id": "5cec37bbc72a7354",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "註冊捲簾裝置",
        "func": "// 窗簾/捲簾設備配置生成器\n// 支援: 窗簾(curtain), 捲簾, 排煙窗\n\n// ============ 窗簾設備定義 ============\nlet covers = [\n    { id: \"scene_single_14-1--14-2--14-3\", name: \"主堂外側走道天花\" },\n    { id: \"scene_single_15-1--15-2--15-3--15-4\", name: \"舞台左側\" },\n    { id: \"scene_rgb_26-x--27-x\", name: \"講台\" },\n    { id: \"scene_rgb_28-x--29-x\", name: \"舞台右側\" },\n    { id: \"scene_rgb_30-x\", name: \"舞台右側十字架燈\" }\n];\n\n// ============ 配置生成函數 ============\nfunction generateCoverConfigs(covers) {\n    return covers.map(cover => {\n        let part = cover.id.split(\"_\");\n        let device_type = part[0];\n        let id = part[1];\n        let control = (part[2]).split(\"-\");\n\n        let basePayload = {\n            name: cover.name,\n            unique_id: cover.id,\n            optimistic: true,\n            retain: true\n        };\n\n        let operation_type;\n        switch (control.length) {\n            case 2: {\n                operation_type = \"oc\";\n                basePayload.payload_open = `${control[0]}/${control[1]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}`;\n                basePayload.payload_stop = `${control[0]}_${control[1]}/`;\n                break;\n            }\n            case 3: {\n                operation_type = \"ocs\";\n                basePayload.payload_open = `${control[0]}/${control[1]}_${control[2]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}_${control[2]}`;\n                basePayload.payload_stop = `${control[2]}/${control[0]}_${control[1]}`;\n                break;\n            }\n            default: {\n                node.warn(\"Unknown type of curtain\");\n                break;\n            }\n        }\n\n        basePayload.command_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/set`;\n        basePayload.state_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/state`;\n\n        return {\n            topic: `homeassistant/cover/${cover.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ============ 主要執行 ============\nlet allMessages = generateCoverConfigs(covers);\nreturn [allMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 140,
        "wires": [
            [
                "4029932648511b89"
            ]
        ]
    },
    {
        "id": "92794b29622d2433",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "註冊燈光裝置",
        "func": "// 燈光設備配置生成器\n// 支援: 單色(single), 雙色溫(dual), WRGB, RGB, Relay\n\n// ============ 燈光設備定義 ============\nlet lights = [\n    { id: \"single_11_1\", name: \"single-11-1\" },\n    { id: \"single_11_2\", name: \"single-11-2\" },\n    { id: \"single_11_3\", name: \"single-11-3\" },\n    { id: \"single_11_4\", name: \"single-11-4\" },\n    { id: \"single_12_1\", name: \"single-12-1\" },\n    { id: \"single_12_2\", name: \"single-12-2\" },\n    { id: \"single_12_3\", name: \"single-12-3\" },\n    { id: \"single_12_4\", name: \"single-12-4\" },\n    { id: \"single_13_1\", name: \"single-13-1\" },\n    { id: \"single_13_2\", name: \"single-13-2\" },\n    { id: \"single_13_3\", name: \"single-13-3\" },\n    { id: \"single_13_4\", name: \"single-13-4\" },\n    { id: \"single_14_1\", name: \"single-14-1\" },\n    { id: \"single_14_2\", name: \"single-14-2\" },\n    { id: \"single_14_3\", name: \"single-14-3\" },\n    { id: \"single_14_4\", name: \"single-14-4\" },\n    { id: \"single_15_1\", name: \"single-15-1\" },\n    { id: \"single_15_2\", name: \"single-15-2\" },\n    { id: \"wrgb_26_x\", name: \"wrgb-26-x\"},\n    { id: \"wrgb_27_x\", name: \"wrgb-27-x\"},\n    { id: \"wrgb_28_x\", name: \"wrgb-28-x\"},\n    { id: \"rgb_29_x\", name: \"rgb-29-x\"},\n    { id: \"single_16_1\", name: \"single-16-1\"},\n    { id: \"single_16_2\", name: \"single-16-2\"},\n    { id: \"single_16_3\", name: \"single-16-3\"},\n    { id: \"relay_30_1\", name: \"relay-30-1\"},\n];\n\n// ============ 配置生成函數 ============\nfunction generateLightConfigs(lights) {\n    return lights.map(light => {\n        let parts = light.id.split(\"_\");\n        let lightType = parts[0]; // single, dual, relay, rgb\n        let moduleId = parts[1];\n        let channel = parts[2];\n        \n        let basePayload = {\n            name: light.name,\n            unique_id: light.id,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            optimistic: true,\n            state_topic: `homeassistant/light/${lightType}/${moduleId}/${channel}/state`,\n            command_topic: `homeassistant/light/${lightType}/${moduleId}/${channel}/set`,\n        };\n        \n        switch(lightType) {\n            case \"single\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/colortemp`;\n                basePayload.color_temp_command_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"wrgb\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.rgb = true;\n                basePayload.rgb_state_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/rgb`;\n                basePayload.rgb_command_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/set/rgb`;\n                break;\n            }\n            case \"rgb\": {\n                // RGB 燈光 (純RGB，無白光通道)\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.rgb = true;\n                basePayload.rgb_state_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/rgb`;\n                basePayload.rgb_command_topic = `homeassistant/light/${lightType}/${moduleId}/${channel}/set/rgb`;\n                break;\n            }\n            case \"relay\": {\n                // Relay 只需開關，沒有亮度\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/light/${light.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ============ 主要執行 ============\nlet allMessages = generateLightConfigs(lights);\nreturn [allMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 180,
        "wires": [
            [
                "4029932648511b89"
            ]
        ]
    },
    {
        "id": "39668f9c3a056ad9",
        "type": "mqtt out",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 690,
        "y": 180,
        "wires": []
    },
    {
        "id": "ea69f13e8702d45c",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "b51b480e5f185bfc",
        "name": "註冊共用函數",
        "func": "/**\n * 系統共用模組 - 統一初始化共用常數和函數到 global context\n * \n * Node Type: function\n * \n * 用途：\n *   在 Node-RED 啟動時執行一次，將共用常數和函數註冊到 global context\n *   處理器和 Feedback 都透過 global.get('lib') 取得這些函數\n * \n * 接線方式：\n *   Inject (啟動時觸發, 延遲 0.1 秒) → common.js\n *   輸出可不接，或接 Debug 節點確認初始化成功\n * \n * 使用方式：\n *   const lib = global.get('lib');\n *   const { CONST, UTILS } = lib;\n */\n\n// ========== 常數定義 ==========\nconst CONST = {\n    // === 預設值 ===\n    DEFAULT_BRIGHTNESS: 100,\n    DEFAULT_COLORTEMP: 250,\n    DEFAULT_WRGB: \"255,255,255\",\n    BRIGHTNESS_TIME: 0x05,\n    \n    // === 色溫範圍 ===\n    MIN_MIRED: 167,\n    MAX_MIRED: 333,\n    \n    // === Single Light 寄存器映射 (0x06 Write Single Register) ===\n    SINGLE_REGISTER_MAP: {\n        \"1\": 0x082A,\n        \"2\": 0x082B,\n        \"3\": 0x082C,\n        \"4\": 0x082D\n    },\n    \n    // === Dual Light 寄存器映射 (每通道兩個寄存器: 亮度, 色溫) ===\n    DUAL_REGISTER_MAP: {\n        \"a\": [0x082A, 0x082B],\n        \"b\": [0x082C, 0x082D]\n    },\n    \n    // === Relay Coil 映射 (0x05 Write Single Coil) ===\n    RELAY_COIL_MAP: {\n        \"1\": 0x0000,\n        \"2\": 0x0001,\n        \"3\": 0x0002,\n        \"4\": 0x0003\n    },\n    \n    // === WRGB 寄存器映射 (0x10 Write Multiple Registers) ===\n    WRGB_REGISTER_MAP: {\n        \"x\": 0x0829,\n        \"y\": 0x082B,\n        \"z\": 0x082D\n    },\n    \n    // === RGB 寄存器映射 (0x10 Write Multiple Registers, 純RGB無白光) ===\n    RGB_REGISTER_MAP: {\n        \"x\": 0x0829,\n        \"y\": 0x082B,\n        \"z\": 0x082D\n    },\n\n    // === Feedback 用：寄存器反查映射 ===\n    REGISTER_TO_SINGLE: {\n        0x082A: { type: \"single\", channel: \"1\" },\n        0x082B: { type: \"single\", channel: \"2\" },\n        0x082C: { type: \"single\", channel: \"3\" },\n        0x082D: { type: \"single\", channel: \"4\" }\n    },\n    \n    REGISTER_TO_DUAL: {\n        0x082A: { type: \"dual\", channel: \"a\", attribute: \"brightness\" },\n        0x082B: { type: \"dual\", channel: \"a\", attribute: \"colortemp\" },\n        0x082C: { type: \"dual\", channel: \"b\", attribute: \"brightness\" },\n        0x082D: { type: \"dual\", channel: \"b\", attribute: \"colortemp\" }\n    },\n    \n    COIL_TO_RELAY: {\n        0x0000: { channel: \"1\" },\n        0x0001: { channel: \"2\" },\n        0x0002: { channel: \"3\" },\n        0x0003: { channel: \"4\" }\n    },\n    \n    REGISTER_TO_WRGB: {\n        0x0829: \"x\",\n        0x082B: \"y\",\n        0x082D: \"z\"\n    },\n    \n    // === HVAC 映射 ===\n    HVAC_MODE_MAP: {\n        0: \"cool\",\n        1: \"heat\",\n        2: \"dry\",\n        3: \"fan_only\",\n        4: \"off\"\n    },\n    \n    HVAC_FAN_MAP: {\n        0: \"auto\",\n        1: \"low\",\n        2: \"medium\",\n        3: \"high\"\n    }\n};\n\n// ========== DEBUG 控制 ==========\nconst DEFAULT_DEBUG_CONFIG = {\n    topic: true,\n    cache: true,\n    modbus: true,\n    mqtt: true,\n    scene: true,\n    query: true\n};\n\n// ========== 工具函數 ==========\nconst UTILS = {\n    // === Debug 輸出 ===\n    debugLog: function(category, message) {\n        const debugConfig = global.get('debug_config') || DEFAULT_DEBUG_CONFIG;\n        if (debugConfig[category] && this.warn) {\n            this.warn(message);\n        }\n    },\n    \n    // === 數值範圍限制 ===\n    clamp: function(value, min, max) {\n        return value < min ? min : value > max ? max : value;\n    },\n    \n    // === CRC16 計算 ===\n    crc16: function(buf) {\n        let crc = 0xFFFF;\n        for (const b of buf) {\n            crc ^= b;\n            for (let i = 0; i < 8; i++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        return crc;\n    },\n    \n    // === CRC16 驗證 ===\n    verifyCRC: function(buf) {\n        let crc = 0xFFFF;\n        for (let i = 0; i < buf.length - 2; i++) {\n            crc ^= buf[i];\n            for (let j = 0; j < 8; j++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        const lo = crc & 0xFF;\n        const hi = (crc >> 8) & 0xFF;\n        return lo === buf[buf.length - 2] && hi === buf[buf.length - 1];\n    },\n    \n    // === 附加 CRC 到 Buffer ===\n    appendCRC: function(buf) {\n        const crc = this.crc16(buf);\n        const lo = crc & 0xFF;\n        const hi = (crc >> 8) & 0xFF;\n        return Buffer.concat([buf, Buffer.from([lo, hi])]);\n    },\n    \n    // === 建構 Modbus 0x06 指令 (Write Single Register) ===\n    buildCommand: function(moduleId, reg, value, speed = CONST.BRIGHTNESS_TIME) {\n        const hi = (reg >> 8) & 0xFF;\n        const lo = reg & 0xFF;\n        return Buffer.from([moduleId, 0x06, hi, lo, speed, value]);\n    },\n    \n    // === 建構 Modbus 0x05 指令 (Write Single Coil) ===\n    buildCoilCommand: function(moduleId, addr, state) {\n        const hi = (addr >> 8) & 0xFF;\n        const lo = addr & 0xFF;\n        const valHi = state ? 0xFF : 0x00;\n        return Buffer.from([moduleId, 0x05, hi, lo, valHi, 0x00]);\n    },\n    \n    // === 建構 Modbus 0x10 指令 (Write Multiple Registers) ===\n    buildMultiCommand: function(moduleId, reg, data) {\n        const regHi = (reg >> 8) & 0xFF;\n        const regLo = reg & 0xFF;\n        const regCount = Math.ceil(data.length / 2);\n        return Buffer.from([\n            moduleId, 0x10, regHi, regLo,\n            0x00, regCount,\n            data.length,\n            ...data\n        ]);\n    },\n    \n    // === 色溫轉換：Mired → 百分比 ===\n    miredToPercent: function(mired) {\n        const min = CONST.MIN_MIRED;\n        const max = CONST.MAX_MIRED;\n        mired = this.clamp(Math.round(mired), min, max);\n        return Math.round(((max - mired) / (max - min)) * 100);\n    },\n    \n    // === 色溫轉換：百分比 → Mired ===\n    percentToMired: function(percent) {\n        return Math.round(CONST.MAX_MIRED - (percent / 100) * (CONST.MAX_MIRED - CONST.MIN_MIRED));\n    },\n    \n    // === RGB 轉 WRGB ===\n    rgbToWrgb: function(r, g, b, brightness) {\n        const w = Math.min(r, g, b);\n        let rOut = r - w;\n        let gOut = g - w;\n        let bOut = b - w;\n        let wOut = w;\n        \n        const total = rOut + gOut + bOut + wOut;\n        if (total === 0) {\n            return { r: 0, g: 0, b: 0, w: brightness };\n        }\n        \n        return {\n            r: Math.round(brightness * rOut / total),\n            g: Math.round(brightness * gOut / total),\n            b: Math.round(brightness * bOut / total),\n            w: Math.round(brightness * wOut / total)\n        };\n    },\n    \n    // === 解析 RGB/WRGB 字串 \"R,G,B\" ===\n    parseRgb: function(rgbString) {\n        const parts = (rgbString || CONST.DEFAULT_WRGB).split(\",\");\n        return {\n            r: parseInt(parts[0]?.trim(), 10) || 0,\n            g: parseInt(parts[1]?.trim(), 10) || 0,\n            b: parseInt(parts[2]?.trim(), 10) || 0\n        };\n    },\n    \n    // === 產生 Dequeue 訊息 ===\n    makeDequeueMsg: function() {\n        return { topic: \"modbus/queue/dequeue\", payload: \"next\" };\n    }\n};\n\n// ========== 註冊到 Global Context ==========\nconst lib = {\n    CONST: CONST,\n    UTILS: UTILS,\n    version: \"2.0.0\",\n    initialized: new Date().toISOString()\n};\n\nglobal.set('lib', lib);\nglobal.set('debug_config', global.get('debug_config') || DEFAULT_DEBUG_CONFIG);\n\nnode.status({\n    fill: \"green\",\n    shape: \"dot\",\n    text: `共用模組 v${lib.version} 已載入`\n});\n\nreturn {\n    payload: {\n        message: \"共用模組已初始化\",\n        version: lib.version,\n        constants: Object.keys(CONST),\n        utils: Object.keys(UTILS)\n    }\n};\n",
        "outputs": 0,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 260,
        "wires": []
    },
    {
        "id": "737caad79ddcbbc0",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "CRC builder",
        "func": "/**\n * CRC16 指令建構器\n * \n * Node Type: function\n * \n * 輸入：\n *   msg.payload = Buffer (不含 CRC 的 Modbus 指令)\n * \n * 輸出：\n *   msg.payload = Buffer (含 CRC 的完整 Modbus 指令)\n * \n * 使用方式：\n *   processor_light → crc_builder → modbus_queue\n */\n\nfunction crc16(buf) {\n    let crc = 0xFFFF;\n    for (const b of buf) {\n        crc ^= b;\n        for (let i = 0; i < 8; i++) {\n            crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n        }\n    }\n    return crc;\n}\n\n// 確保 payload 是 Buffer\nlet frame = msg.payload;\nif (!Buffer.isBuffer(frame)) {\n    if (Array.isArray(frame)) {\n        frame = Buffer.from(frame);\n    } else {\n        node.warn(\"輸入必須是 Buffer 或 Array\");\n        return null;\n    }\n}\n\nconst crc = crc16(frame);\nmsg.payload = Buffer.concat([frame, Buffer.from([crc & 0xFF, (crc >> 8) & 0xFF])]);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 580,
        "wires": [
            [
                "00fc94dcc0e6fe7f"
            ]
        ]
    },
    {
        "id": "6ba6f25c2eb002d5",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "窗簾裝置處理器",
        "func": "/**\n * 窗簾處理器 - 支援窗簾/捲簾/排煙窗\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 modbus_queue.js\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 支援的 Topic 格式:\n *   homeassistant/cover/general/{moduleId}/set\n *   payload: \"1_2/3\" 表示開啟 relay 1 和 2，關閉 relay 3\n */\n\n// ========== 共用模組 ==========\nconst debugConfig = global.get('debug_config') || {\n    topic: true, cache: true, modbus: true, mqtt: true, scene: true, query: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) node.warn(message);\n}\n\n// CRC 由 crc_builder.js 處理\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // cover\nconst subType = parts[2];        // general, curtain\nconst moduleId = parseInt(parts[3]);\n\nif (deviceType !== \"cover\") {\n    return null;\n}\n\ndebugLog('topic', `=== Cover 處理器 ===`);\ndebugLog('topic', `Topic: ${msg.topic}, Payload: ${msg.payload}`);\n\nlet modbusMessages = [];\n\n// 格式: homeassistant/cover/general/12/set\n// payload: \"1_2/3\" 表示開啟 relay 1 和 2，關閉 relay 3\n\nconst relays = String(msg.payload).split(\"/\");\nconst on_relays = relays[0] ? relays[0].split(\"_\").map(Number).filter(n => !isNaN(n)) : [];\nconst off_relays = (relays[1] && relays[1].length > 0) ? relays[1].split(\"_\").map(Number).filter(n => !isNaN(n)) : [];\n\nlet output = 0x00;\nfor (let relay of on_relays) {\n    output |= (1 << (relay - 1));\n}\nfor (let relay of off_relays) {\n    output &= ~(1 << (relay - 1));\n}\n\nconst cmd = Buffer.from([moduleId, 0x06, 0x01, 0x9b, 0x10, output]);\n\ndebugLog('modbus', `=== Modbus 指令 (Cover) ===`);\ndebugLog('modbus', `開啟 Relay: ${on_relays.join(\", \")}`);\ndebugLog('modbus', `關閉 Relay: ${off_relays.join(\", \")}`);\ndebugLog('modbus', `Bit Mask: 0b${output.toString(2).padStart(8, '0')} (0x${output.toString(16).padStart(2, '0')})`);\ndebugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\nmodbusMessages.push({ payload: cmd, deviceType, moduleId, on_relays, off_relays });\n\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `Cover: ON[${on_relays}] OFF[${off_relays}]`\n});\n\nreturn [modbusMessages, []];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 568.3333129882812,
        "y": 601.6666564941406,
        "wires": [
            [
                "0eca5b8723256271"
            ],
            [
                "dcede551fa7f5720"
            ]
        ]
    },
    {
        "id": "aaded790b4189354",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "",
        "topic": "homeassistant/cover/+/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 318.33331298828125,
        "y": 601.6666564941406,
        "wires": [
            [
                "6ba6f25c2eb002d5"
            ]
        ]
    },
    {
        "id": "bdae5a6694b1a8cb",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "冷氣風控處理器",
        "func": "/**\n * 空調處理器 - 支援 HVAC 控制\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 modbus_queue.js\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 支援的 Topic 格式:\n *   homeassistant/hvac/{s200Id}/{hvacId}/mode/set     (payload: \"cool\", \"heat\", \"dry\", \"fan_only\", \"off\")\n *   homeassistant/hvac/{s200Id}/{hvacId}/temperature/set (payload: 16-30)\n *   homeassistant/hvac/{s200Id}/{hvacId}/fan/set      (payload: \"auto\", \"low\", \"medium\", \"high\")\n */\n\n// ========== 共用模組 ==========\nconst debugConfig = global.get('debug_config') || {\n    topic: true, cache: true, modbus: true, mqtt: true, scene: true, query: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) node.warn(message);\n}\n\n// CRC 由 crc_builder.js 處理\n\n// ========== 常數定義 ==========\nconst MODE_MAP = {\n    \"cool\": 0,\n    \"heat\": 1,\n    \"dry\": 2,\n    \"fan_only\": 3,\n    \"off\": 4\n};\n\nconst FAN_MODE_MAP = {\n    \"auto\": 0,\n    \"low\": 1,\n    \"medium\": 2,\n    \"high\": 3\n};\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // hvac\n\nif (deviceType !== \"hvac\") {\n    return null;\n}\n\nconst s200Id = parseInt(parts[2]);      // S200 模組 ID (通常是 200)\nconst hvacId = parseInt(parts[3]);      // HVAC 設備 ID (1, 2, 3...)\nconst hvacAction = parts[4];            // mode, fan, temperature\nconst payload = msg.payload;\n\ndebugLog('topic', `=== HVAC 處理器 ===`);\ndebugLog('topic', `S200 ID: ${s200Id}, HVAC ID: ${hvacId}, 動作: ${hvacAction}, 值: ${payload}`);\n\nconst baseAddress = 0x100;\nconst speed = 0x00; // HVAC 統一使用 0x00 (立即執行)\n\nlet register, value;\n\nswitch (hvacAction) {\n    case \"mode\":\n        register = baseAddress + hvacId * 8 + 1;\n        value = MODE_MAP[payload];\n        debugLog('modbus', `模式設定: ${payload} -> ${value}`);\n        break;\n\n    case \"fan\":\n        register = baseAddress + hvacId * 8 + 2;\n        value = FAN_MODE_MAP[payload];\n        debugLog('modbus', `風速設定: ${payload} -> ${value}`);\n        break;\n\n    case \"temperature\":\n        register = baseAddress + hvacId * 8 + 3;\n        value = parseFloat(payload);\n        debugLog('modbus', `溫度設定: ${value}°C`);\n        break;\n\n    default:\n        debugLog('topic', `未知的 HVAC 動作: ${hvacAction}`);\n        return null;\n}\n\nif (value === undefined || value === null) {\n    debugLog('topic', `無效的 HVAC 值: ${payload}`);\n    return null;\n}\n\nconst regHi = (register >> 8) & 0xFF;\nconst regLo = register & 0xFF;\n\nconst cmd = Buffer.from([\n    s200Id,\n    0x06,\n    regHi,\n    regLo,\n    speed,\n    value\n]);\n\ndebugLog('modbus', `=== Modbus 指令 (HVAC) ===`);\ndebugLog('modbus', `寄存器: 0x${register.toString(16).padStart(4, '0')}`);\ndebugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\nlet modbusMessages = [];\nmodbusMessages.push({ payload: cmd, deviceType, s200Id, hvacId, hvacAction, value });\n\nnode.status({\n    fill: \"orange\",\n    shape: \"dot\",\n    text: `HVAC ${hvacId}: ${hvacAction}=${payload}`\n});\n\nreturn [modbusMessages, []];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 568.3333129882812,
        "y": 661.6666564941406,
        "wires": [
            [
                "0eca5b8723256271"
            ],
            [
                "dcede551fa7f5720"
            ]
        ]
    },
    {
        "id": "5ef6650c7d60c1ae",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "",
        "topic": "homeassistant/hvac/+/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 318.33331298828125,
        "y": 661.6666564941406,
        "wires": [
            [
                "bdae5a6694b1a8cb"
            ]
        ]
    },
    {
        "id": "4b09975535cd95ad",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "燈光場景處理器",
        "func": "/**\n * 場景處理器 - 支援多種設備群組控制\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 modbus_queue.js (保留供未來擴展)\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 支援的設備類型:\n *   - single: 單色溫燈 (亮度)\n *   - dual:   雙色溫燈 (亮度 + 色溫)\n *   - wrgb:   WRGB燈   (亮度 + RGB顏色)\n *   - relay:  繼電器    (純開關)\n *   - cover:  窗簾      (開/關/停)\n * \n * 支援的 Topic 格式:\n *   homeassistant/light/scene/{sceneType}/{devices}/set\n *   homeassistant/light/scene/{sceneType}/{devices}/set/brightness\n *   homeassistant/light/scene/{sceneType}/{devices}/set/colortemp\n *   homeassistant/light/scene/{sceneType}/{devices}/set/rgb\n *   homeassistant/cover/scene/cover/{devices}/set\n * \n * 範例:\n *   homeassistant/light/scene/single/12-1--12-2/set\n *   homeassistant/light/scene/wrgb/2-x--11-x/set/rgb\n *   homeassistant/cover/scene/cover/22-oc--23-oc/set\n */\n\n// ========== 共用模組 ==========\nconst debugConfig = global.get('debug_config') || {\n    topic: true, cache: true, modbus: true, mqtt: true, scene: true, query: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) node.warn(message);\n}\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst haEntityType = parts[1];   // light 或 cover\nconst subType = parts[2];        // scene\n\nif (subType !== \"scene\") {\n    return null;\n}\n\nconst sceneType = parts[3];  // single, dual, wrgb, relay, cover\nconst devicesStr = parts[4]; // 12-1--12-2 或 22-oc--23-oc\nconst devices = devicesStr.split(\"--\");\n\ndebugLog('scene', `=== Scene 處理器 ===`);\ndebugLog('scene', `HA 實體類型: ${haEntityType}`);\ndebugLog('scene', `場景類型: ${sceneType}`);\ndebugLog('scene', `設備列表: ${devices.join(\", \")}`);\ndebugLog('scene', `Payload: ${msg.payload}`);\n\nlet mqttMessages = [];\n\n// 場景快取 key 前綴\nconst scenePrefix = `scene_${sceneType}_${devicesStr}`;\n\n// ========== 處理屬性設定 (brightness/colortemp/rgb) ==========\nif (parts.length >= 7 && parts[5] === \"set\") {\n    const attribute = parts[6];\n    const key = `${scenePrefix}_${attribute}`;\n    flow.set(key, msg.payload);\n    debugLog('cache', `儲存場景屬性: ${key} = ${msg.payload}`);\n\n    // 屬性變更後，同步到所有子設備\n    for (let device of devices) {\n        const [deviceId, deviceChannel] = device.split(\"-\");\n        const deviceKey = `${sceneType}_${deviceId}_${deviceChannel}_${attribute}`;\n        flow.set(deviceKey, msg.payload);\n        debugLog('cache', `同步子設備: ${deviceKey} = ${msg.payload}`);\n\n        // 發送屬性更新到個別設備\n        if (haEntityType === \"light\") {\n            const attrTopic = `homeassistant/light/${sceneType}/${deviceId}/${deviceChannel}/set/${attribute}`;\n            mqttMessages.push({ topic: attrTopic, payload: msg.payload });\n        }\n    }\n\n    // 更新場景屬性狀態\n    const stateTopic = `homeassistant/${haEntityType}/scene/${sceneType}/${devicesStr}/${attribute}`;\n    mqttMessages.push({ topic: stateTopic, payload: msg.payload });\n\n    node.status({\n        fill: \"blue\",\n        shape: \"ring\",\n        text: `Scene ${attribute}: ${devices.length} 設備`\n    });\n\n    return [[], mqttMessages];\n}\n\n// ========== 處理窗簾場景 ==========\nif (sceneType === \"cover\") {\n    const command = String(msg.payload).toUpperCase(); // OPEN, CLOSE, STOP\n\n    debugLog('scene', `窗簾場景指令: ${command}`);\n\n    for (let device of devices) {\n        // device 格式: 22-oc 或 23-ocs\n        const [deviceId, controlType] = device.split(\"-\");\n\n        // 轉發到個別窗簾\n        // 需要將 OPEN/CLOSE/STOP 轉換為窗簾控制格式\n        const coverTopic = `homeassistant/cover/curtain/${deviceId}/${controlType}/set`;\n\n        // 窗簾的 payload 格式根據 config_covers.js:\n        // OPEN: \"1/2\" 或 \"1/2_3\"\n        // CLOSE: \"2/1\" 或 \"2/1_3\"  \n        // STOP: \"1_2/\" 或 \"3/1_2\"\n        // 這裡簡化為發送標準 HA 指令，由 processor_cover 處理轉換\n        mqttMessages.push({ topic: coverTopic, payload: command });\n    }\n\n    // 更新場景狀態\n    const statePayload = (command === \"OPEN\") ? \"open\" : (command === \"CLOSE\") ? \"closed\" : \"stopped\";\n    mqttMessages.push({\n        topic: `homeassistant/cover/scene/cover/${devicesStr}/state`,\n        payload: statePayload\n    });\n\n    node.status({\n        fill: command === \"STOP\" ? \"yellow\" : \"blue\",\n        shape: \"ring\",\n        text: `Cover Scene: ${devices.length} 窗簾 ${command}`\n    });\n\n    return [[], mqttMessages];\n}\n\n// ========== 處理燈光場景 (single, dual, wrgb, relay) ==========\nconst state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n\ndebugLog('scene', `燈光狀態: ${state}`);\n\n// 讀取場景儲存的屬性\nconst groupBrightness = flow.get(`${scenePrefix}_brightness`);\nconst groupColortemp = flow.get(`${scenePrefix}_colortemp`);\nconst groupRgb = flow.get(`${scenePrefix}_rgb`);\n\n// 發送指令到每個燈光\nfor (let device of devices) {\n    const [deviceId, deviceChannel] = device.split(\"-\");\n\n    // 根據場景類型，先更新個別設備的快取\n    if (state === \"ON\") {\n        if (groupBrightness !== undefined && (sceneType === \"single\" || sceneType === \"dual\" || sceneType === \"wrgb\")) {\n            flow.set(`${sceneType}_${deviceId}_${deviceChannel}_brightness`, groupBrightness);\n            debugLog('cache', `更新快取: ${sceneType}_${deviceId}_${deviceChannel}_brightness = ${groupBrightness}`);\n        }\n        if (groupColortemp !== undefined && sceneType === \"dual\") {\n            flow.set(`${sceneType}_${deviceId}_${deviceChannel}_colortemp`, groupColortemp);\n            debugLog('cache', `更新快取: ${sceneType}_${deviceId}_${deviceChannel}_colortemp = ${groupColortemp}`);\n        }\n        if (groupRgb !== undefined && sceneType === \"wrgb\") {\n            flow.set(`${sceneType}_${deviceId}_${deviceChannel}_rgb`, groupRgb);\n            debugLog('cache', `更新快取: ${sceneType}_${deviceId}_${deviceChannel}_rgb = ${groupRgb}`);\n        }\n    }\n\n    // 發送開關指令到個別設備（會使用剛更新的快取）\n    const lightTopic = `homeassistant/light/${sceneType}/${deviceId}/${deviceChannel}/set`;\n    mqttMessages.push({ topic: lightTopic, payload: state });\n}\n\n// 更新場景本身的狀態\nmqttMessages.push({\n    topic: `homeassistant/light/scene/${sceneType}/${devicesStr}/state`,\n    payload: state\n});\n\n// 如果是 ON，也更新場景的屬性狀態\nif (state === \"ON\") {\n    if (groupBrightness !== undefined) {\n        mqttMessages.push({\n            topic: `homeassistant/light/scene/${sceneType}/${devicesStr}/brightness`,\n            payload: groupBrightness\n        });\n    }\n    if (groupColortemp !== undefined && sceneType === \"dual\") {\n        mqttMessages.push({\n            topic: `homeassistant/light/scene/${sceneType}/${devicesStr}/colortemp`,\n            payload: groupColortemp\n        });\n    }\n    if (groupRgb !== undefined && sceneType === \"wrgb\") {\n        mqttMessages.push({\n            topic: `homeassistant/light/scene/${sceneType}/${devicesStr}/rgb`,\n            payload: groupRgb\n        });\n    }\n}\n\n// 設定狀態顯示\nconst statusColors = {\n    single: \"yellow\",\n    dual: \"yellow\",\n    wrgb: \"magenta\",\n    relay: \"green\"\n};\n\nnode.status({\n    fill: state === \"ON\" ? (statusColors[sceneType] || \"yellow\") : \"grey\",\n    shape: \"ring\",\n    text: `Scene ${sceneType}: ${devices.length} 燈 ${state}`\n});\n\n// Scene 不直接產生 Modbus 指令，透過 MQTT 觸發個別設備\nreturn [[], mqttMessages];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 568.3333129882812,
        "y": 721.6666564941406,
        "wires": [
            [
                "0eca5b8723256271"
            ],
            [
                "dcede551fa7f5720"
            ]
        ]
    },
    {
        "id": "b828e18badfd46c7",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "",
        "topic": "homeassistant/light/scene/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 328.33331298828125,
        "y": 721.6666564941406,
        "wires": [
            [
                "4b09975535cd95ad"
            ]
        ]
    },
    {
        "id": "341b7da26be90f5e",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "",
        "topic": "homeassistant/query/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 320,
        "y": 780,
        "wires": [
            [
                "6b616925f063fb80"
            ]
        ]
    },
    {
        "id": "6b616925f063fb80",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "狀態查詢處理器",
        "func": "/**\n * 查詢處理器 - 支援設備狀態查詢\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 crc_builder → modbus_queue\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 支援的 Topic 格式:\n *   homeassistant/query/single/{moduleId}/{channel}\n *   homeassistant/query/dual/{moduleId}/{channel}\n *   homeassistant/query/relay/{moduleId}/{channel}\n *   homeassistant/query/hvac/{s200Id}/{hvacId}\n */\n\n// ========== 共用模組 ==========\nconst debugConfig = global.get('debug_config') || {\n    topic: true, cache: true, modbus: true, mqtt: true, scene: true, query: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) node.warn(message);\n}\n\n// CRC 由 crc_builder.js 處理\n\nconst CHANNEL_REGISTER_MAP = {\n    \"1\": 0x082A, \"2\": 0x082B, \"3\": 0x082C, \"4\": 0x082D,\n    \"a\": [0x082A, 0x082B], \"b\": [0x082C, 0x082D]\n};\n\nconst CHANNEL_COIL_MAP = { \"1\": 0x0000, \"2\": 0x0001, \"3\": 0x0002, \"4\": 0x0003 };\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // query\n\nif (deviceType !== \"query\") {\n    return null;\n}\n\nconst querySubType = parts[2];   // single, dual, relay\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\ndebugLog('query', `=== Query 處理器 ===`);\ndebugLog('query', `類型: ${querySubType}, 模組: ${moduleId}, 通道: ${channel}`);\n\nlet frame;\nlet modbusMessages = [];\n\nif (querySubType === \"single\" || querySubType === \"dual\") {\n    // 查詢 Single/Dual Light: Read Holding Registers (0x03)\n    const reg = CHANNEL_REGISTER_MAP[channel];\n    if (!reg) {\n        debugLog('query', `找不到通道 ${channel} 的寄存器`);\n        return null;\n    }\n\n    const startReg = Array.isArray(reg) ? reg[0] : reg;\n    const quantity = Array.isArray(reg) ? 2 : 1;\n\n    const regHi = (startReg >> 8) & 0xFF;\n    const regLo = startReg & 0xFF;\n    const qtyHi = (quantity >> 8) & 0xFF;\n    const qtyLo = quantity & 0xFF;\n\n    frame = Buffer.from([moduleId, 0x03, regHi, regLo, qtyHi, qtyLo]);\n\n    debugLog('query', `讀取寄存器: 0x${startReg.toString(16).padStart(4, '0')}, 數量: ${quantity}`);\n}\nelse if (querySubType === \"relay\") {\n    // 查詢 Relay: Read Coils (0x01)\n    const addr = CHANNEL_COIL_MAP[channel] || 0x0000;\n    const quantity = 4;\n\n    const addrHi = (addr >> 8) & 0xFF;\n    const addrLo = addr & 0xFF;\n    const qtyHi = (quantity >> 8) & 0xFF;\n    const qtyLo = quantity & 0xFF;\n\n    frame = Buffer.from([moduleId, 0x01, addrHi, addrLo, qtyHi, qtyLo]);\n\n    debugLog('query', `讀取線圈: 0x${addr.toString(16).padStart(4, '0')}, 數量: ${quantity}`);\n}\nelse if (querySubType === \"hvac\") {\n    // 查詢 HVAC: Read Holding Registers (0x03)\n    // HVAC 資料格式: 起始地址 = 0x100 + hvacId * 8, 讀取 6 個寄存器\n    // [Power] [Mode] [Fan] [Temp] [CurrentTemp] [Reserved]\n    const hvacId = parseInt(channel);\n    const startReg = 0x100 + hvacId * 8;\n    const quantity = 6;\n\n    const regHi = (startReg >> 8) & 0xFF;\n    const regLo = startReg & 0xFF;\n    const qtyHi = (quantity >> 8) & 0xFF;\n    const qtyLo = quantity & 0xFF;\n\n    frame = Buffer.from([moduleId, 0x03, regHi, regLo, qtyHi, qtyLo]);\n\n    debugLog('query', `HVAC 查詢: S200=${moduleId}, HVAC ID=${hvacId}`);\n    debugLog('query', `讀取寄存器: 0x${startReg.toString(16).padStart(4, '0')}, 數量: ${quantity}`);\n}\nelse {\n    debugLog('query', `不支援的查詢類型: ${querySubType}`);\n    return null;\n}\n\nconst cmd = frame;\n\ndebugLog('modbus', `=== Modbus 查詢指令 ===`);\ndebugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\nconst queryMsg = {\n    payload: cmd,\n    deviceType: \"query\",\n    subType: querySubType,\n    moduleId,\n    channel,\n    queryInfo: { type: querySubType, channel: channel }\n};\nmodbusMessages.push(queryMsg);\n\nnode.status({\n    fill: \"cyan\",\n    shape: \"ring\",\n    text: `Query ${querySubType} ${moduleId}-${channel}`\n});\n\nreturn [modbusMessages, []];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 568.3333129882812,
        "y": 781.6666564941406,
        "wires": [
            [
                "0eca5b8723256271"
            ],
            [
                "dcede551fa7f5720"
            ]
        ]
    },
    {
        "id": "7c8b51b7ef1f8656",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "單色溫調光處理器",
        "func": "/**\n * 單色溫燈光處理器 (Single)\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 crc_builder → modbus_queue\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 支援的 Topic 格式:\n *   homeassistant/light/single/{moduleId}/{channel}/set\n *   homeassistant/light/single/{moduleId}/{channel}/set/brightness\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { clamp, buildCommand } = UTILS;\nconst { DEFAULT_BRIGHTNESS, BRIGHTNESS_TIME, SINGLE_REGISTER_MAP } = CONST;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light\nconst subType = parts[2];        // single\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\nif (deviceType !== \"light\" || subType !== \"single\") {\n    return null;\n}\n\ndebugLog('topic', `=== Single Light 處理器 ===`);\ndebugLog('topic', `Topic: ${msg.topic}, Payload: ${msg.payload}`);\ndebugLog('topic', `Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\nconst baseTopic = `homeassistant/light/single/${moduleId}/${channel}`;\n\n// 處理 set/brightness\nif (parts.length >= 7 && parts[5] === \"set\" && parts[6] === \"brightness\") {\n    const val = Number(msg.payload);\n    if (!isNaN(val)) {\n        const key = `single_${moduleId}_${channel}_brightness`;\n        flow.set(key, val);\n        debugLog('cache', `儲存 ${key} = ${val}`);\n    }\n    \n    // 亮度變更時，保持當前開關狀態\n    const stateKey = `single_${moduleId}_${channel}_state`;\n    const state = flow.get(stateKey) || \"ON\";\n    msg.payload = state;\n}\n\n// 處理開關指令\nconst reg = SINGLE_REGISTER_MAP[channel];\nif (!reg) {\n    debugLog('modbus', `找不到通道 ${channel} 的寄存器`);\n    return null;\n}\n\nlet state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\nflow.set(`single_${moduleId}_${channel}_state`, state);\n\nlet brightness = flow.get(`single_${moduleId}_${channel}_brightness`);\nif (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\nbrightness = clamp(Math.round(brightness), 0, 100);\n\nconst brValue = (state === \"ON\") ? brightness : 0;\nconst speed = (state === \"OFF\") ? 0x00 : BRIGHTNESS_TIME;\nconst cmd = buildCommand(moduleId, reg, brValue, speed);\n\ndebugLog('modbus', `=== Modbus 指令 (Single) ===`);\ndebugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\nmodbusMessages.push({ payload: cmd, subType: \"single\", moduleId, channel, state, brightness });\nmqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\nif (state === \"ON\") {\n    mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n}\n\nnode.status({ \n    fill: state === \"ON\" ? \"green\" : \"grey\", \n    shape: \"dot\", \n    text: `${moduleId}-${channel}: ${state} ${brightness}%` \n});\n\nreturn [modbusMessages, mqttMessages];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 478.33331298828125,
        "y": 381.6666564941406,
        "wires": [
            [
                "98394daf1a815f2b"
            ],
            [
                "d1af9f4f42045c6b"
            ]
        ]
    },
    {
        "id": "c457fdf1f1a294d7",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "",
        "topic": "homeassistant/light/single/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 228.33331298828125,
        "y": 381.6666564941406,
        "wires": [
            [
                "7c8b51b7ef1f8656"
            ]
        ]
    },
    {
        "id": "3038cff7fcb502a2",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "雙色溫調光處理器",
        "func": "/**\n * 雙色溫燈光處理器 (Dual)\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 crc_builder → modbus_queue\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 支援的 Topic 格式:\n *   homeassistant/light/dual/{moduleId}/{channel}/set\n *   homeassistant/light/dual/{moduleId}/{channel}/set/brightness\n *   homeassistant/light/dual/{moduleId}/{channel}/set/colortemp\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 light_common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { clamp, buildCommand, miredToPercent } = UTILS;\nconst { DEFAULT_BRIGHTNESS, DEFAULT_COLORTEMP, MIN_MIRED, MAX_MIRED, BRIGHTNESS_TIME, DUAL_REGISTER_MAP } = CONST;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light\nconst subType = parts[2];        // dual\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\nif (deviceType !== \"light\" || subType !== \"dual\") {\n    return null;\n}\n\ndebugLog('topic', `=== Dual Light 處理器 ===`);\ndebugLog('topic', `Topic: ${msg.topic}, Payload: ${msg.payload}`);\ndebugLog('topic', `Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\nconst baseTopic = `homeassistant/light/dual/${moduleId}/${channel}`;\n\nconst regs = DUAL_REGISTER_MAP[channel];\nif (!regs) {\n    debugLog('modbus', `找不到通道 ${channel} 的寄存器`);\n    return null;\n}\n\n// 處理 set/brightness 或 set/colortemp\nif (parts.length >= 7 && parts[5] === \"set\") {\n    const attribute = parts[6];\n    const val = Number(msg.payload);\n    \n    if (!isNaN(val)) {\n        const key = `dual_${moduleId}_${channel}_${attribute}`;\n        flow.set(key, val);\n        debugLog('cache', `儲存 ${key} = ${val}`);\n    }\n\n    // 色溫調整：只發送色溫指令\n    if (attribute === \"colortemp\") {\n        let colortemp = val;\n        colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n        const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n        const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n        debugLog('modbus', `=== Modbus 指令 (Dual Colortemp Only) ===`);\n        debugLog('modbus', `色溫: ${cmdColortemp.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmdColortemp, subType: \"dual\", moduleId, channel, colortemp });\n\n        node.status({ fill: \"yellow\", shape: \"dot\", text: `${moduleId}-${channel}: Colortemp ${colortemp}K` });\n        return [modbusMessages, []];\n    }\n\n    // 亮度變更時，保持當前開關狀態\n    if (attribute === \"brightness\") {\n        const stateKey = `dual_${moduleId}_${channel}_state`;\n        const state = flow.get(stateKey) || \"ON\";\n        msg.payload = state;\n    }\n}\n\n// 處理開關指令\nlet state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\nflow.set(`dual_${moduleId}_${channel}_state`, state);\n\nlet brightness = flow.get(`dual_${moduleId}_${channel}_brightness`);\nif (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\nbrightness = clamp(Math.round(brightness), 0, 100);\n\nlet colortemp = flow.get(`dual_${moduleId}_${channel}_colortemp`);\nif (typeof colortemp !== \"number\") colortemp = DEFAULT_COLORTEMP;\ncolortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\nconst ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\nconst brValue = (state === \"ON\") ? brightness : 0;\nconst cmdBrightness = buildCommand(moduleId, regs[0], brValue);\nconst cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\ndebugLog('modbus', `=== Modbus 指令 (Dual) ===`);\ndebugLog('modbus', `亮度: ${cmdBrightness.toString('hex')}`);\ndebugLog('modbus', `色溫: ${cmdColortemp.toString('hex')}`);\n\nmodbusMessages.push({ payload: cmdBrightness, subType: \"dual\", moduleId, channel, state, brightness, colortemp });\nmodbusMessages.push({ payload: cmdColortemp, subType: \"dual\", moduleId, channel, state, brightness, colortemp });\nmqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\nif (state === \"ON\") {\n    mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n    mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n}\n\nnode.status({ \n    fill: state === \"ON\" ? \"green\" : \"grey\", \n    shape: \"dot\", \n    text: `${moduleId}-${channel}: ${state} ${brightness}% ${colortemp}K` \n});\n\nreturn [modbusMessages, mqttMessages];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 478.33331298828125,
        "y": 421.6666564941406,
        "wires": [
            [
                "98394daf1a815f2b"
            ],
            [
                "d1af9f4f42045c6b"
            ]
        ]
    },
    {
        "id": "dbcccac221a92702",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "",
        "topic": "homeassistant/light/dual/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 218.33331298828125,
        "y": 421.6666564941406,
        "wires": [
            [
                "3038cff7fcb502a2"
            ]
        ]
    },
    {
        "id": "cfcbe05d9a019aaa",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "斷路器燈光處理器",
        "func": "/**\n * Relay 燈光處理器\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 crc_builder → modbus_queue\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 支援的 Topic 格式:\n *   homeassistant/light/relay/{moduleId}/{channel}/set\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { buildCoilCommand } = UTILS;\nconst { RELAY_COIL_MAP } = CONST;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light\nconst subType = parts[2];        // relay\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\nif (deviceType !== \"light\" || subType !== \"relay\") {\n    return null;\n}\n\ndebugLog('topic', `=== Relay 處理器 ===`);\ndebugLog('topic', `Topic: ${msg.topic}, Payload: ${msg.payload}`);\ndebugLog('topic', `Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\nconst baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n\nconst addr = RELAY_COIL_MAP[channel];\nif (addr === undefined) {\n    debugLog('modbus', `找不到 Relay 通道 ${channel}`);\n    return null;\n}\n\nconst state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\nconst cmd = buildCoilCommand(moduleId, addr, state === \"ON\");\n\nflow.set(`relay_${moduleId}_${channel}_state`, state);\n\ndebugLog('modbus', `=== Modbus 指令 (Relay) ===`);\ndebugLog('modbus', `Coil 地址: 0x${addr.toString(16).padStart(4, '0')}`);\ndebugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\nmodbusMessages.push({ payload: cmd, subType: \"relay\", moduleId, channel, state });\nmqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n\nnode.status({ \n    fill: state === \"ON\" ? \"green\" : \"grey\", \n    shape: \"dot\", \n    text: `Relay ${moduleId}-${channel}: ${state}` \n});\n\nreturn [modbusMessages, mqttMessages];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 478.33331298828125,
        "y": 461.6666564941406,
        "wires": [
            [
                "98394daf1a815f2b"
            ],
            [
                "d1af9f4f42045c6b"
            ]
        ]
    },
    {
        "id": "cdff7173f5bfc4c0",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "",
        "topic": "homeassistant/light/relay/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 228.33331298828125,
        "y": 461.6666564941406,
        "wires": [
            [
                "cfcbe05d9a019aaa"
            ]
        ]
    },
    {
        "id": "318d287fc5676b16",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "WRGB燈光處理器",
        "func": "/**\n * WRGB 燈光處理器\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 crc_builder → modbus_queue\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 支援的 Topic 格式:\n *   homeassistant/light/wrgb/{moduleId}/{channel}/set\n *   homeassistant/light/wrgb/{moduleId}/{channel}/set/brightness\n *   homeassistant/light/wrgb/{moduleId}/{channel}/set/rgb\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { clamp, buildMultiCommand, rgbToWrgb, parseRgb } = UTILS;\nconst { DEFAULT_BRIGHTNESS, DEFAULT_WRGB, WRGB_REGISTER_MAP } = CONST;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light\nconst subType = parts[2];        // wrgb\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\nif (deviceType !== \"light\" || subType !== \"wrgb\") {\n    return null;\n}\n\ndebugLog('topic', `=== WRGB 處理器 ===`);\ndebugLog('topic', `Topic: ${msg.topic}, Payload: ${msg.payload}`);\ndebugLog('topic', `Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\nconst baseTopic = `homeassistant/light/wrgb/${moduleId}/${channel}`;\n\nconst reg = WRGB_REGISTER_MAP[channel];\nif (!reg) {\n    debugLog('modbus', `找不到 WRGB 通道 ${channel} 的寄存器`);\n    return null;\n}\n\n// 處理 set/brightness 或 set/rgb\nif (parts.length >= 7 && parts[5] === \"set\") {\n    const attribute = parts[6];\n    const key = `wrgb_${moduleId}_${channel}_${attribute}`;\n    \n    if (attribute === \"rgb\") {\n        flow.set(key, msg.payload);\n        debugLog('cache', `儲存 ${key} = ${msg.payload}`);\n    } else if (attribute === \"brightness\") {\n        const val = Number(msg.payload);\n        if (!isNaN(val)) {\n            flow.set(key, val);\n            debugLog('cache', `儲存 ${key} = ${val}`);\n        }\n    }\n    \n    // 亮度或顏色變更時，保持當前開關狀態\n    const stateKey = `wrgb_${moduleId}_${channel}_state`;\n    const state = flow.get(stateKey) || \"ON\";\n    msg.payload = state;\n}\n\n// 處理開關指令\nlet state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\nflow.set(`wrgb_${moduleId}_${channel}_state`, state);\n\nlet brightness = flow.get(`wrgb_${moduleId}_${channel}_brightness`);\nif (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\nbrightness = clamp(Math.round(brightness), 0, 100);\n\nlet rgbString = flow.get(`wrgb_${moduleId}_${channel}_rgb`);\nif (!rgbString) rgbString = DEFAULT_WRGB;\n\nconst { r: r_ha, g: g_ha, b: b_ha } = parseRgb(rgbString);\n\nlet r, g, b, w;\nif (state === \"OFF\") {\n    r = g = b = w = 0;\n} else {\n    const wrgb = rgbToWrgb(r_ha, g_ha, b_ha, brightness);\n    r = wrgb.r;\n    g = wrgb.g;\n    b = wrgb.b;\n    w = wrgb.w;\n}\n\n// 組 Modbus 0x10 指令 (Write Multiple Registers)\nconst cmd = buildMultiCommand(moduleId, reg, [r, g, b, w]);\n\ndebugLog('modbus', `=== Modbus 指令 (WRGB) ===`);\ndebugLog('modbus', `原始 RGB: ${r_ha},${g_ha},${b_ha}`);\ndebugLog('modbus', `WRGB 輸出: R=${r}, G=${g}, B=${b}, W=${w}`);\ndebugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\nmodbusMessages.push({ payload: cmd, subType: \"wrgb\", moduleId, channel, state, brightness, rgb: rgbString });\nmqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\nif (state === \"ON\") {\n    mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n    mqttMessages.push({ topic: `${baseTopic}/rgb`, payload: rgbString });\n}\n\nnode.status({ \n    fill: state === \"ON\" ? \"magenta\" : \"grey\", \n    shape: \"dot\", \n    text: `WRGB ${moduleId}-${channel}: ${state} ${brightness}%`\n});\n\nreturn [modbusMessages, mqttMessages];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 478.33331298828125,
        "y": 501.6666564941406,
        "wires": [
            [
                "98394daf1a815f2b",
                "a87c5b176708ceca"
            ],
            [
                "d1af9f4f42045c6b"
            ]
        ]
    },
    {
        "id": "fe42c150024f1c6e",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "",
        "topic": "homeassistant/light/wrgb/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 228.33331298828125,
        "y": 501.6666564941406,
        "wires": [
            [
                "318d287fc5676b16"
            ]
        ]
    },
    {
        "id": "e6977952aa6de905",
        "type": "mqtt out",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 910,
        "y": 620,
        "wires": []
    },
    {
        "id": "872803830a56f19b",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "6ace5dde2da93230",
        "name": "HMI 處理器",
        "func": "/**\n * HMI 處理器 - 觸控螢幕指令解析\n * \n * Node ID: hmi_processor\n * Node Type: function\n * \n * 此檔案從 test_full_integrated.json 自動提取\n */\n\nconst MIN_MIRED = 167, MAX_MIRED = 333;\n\n// ========== 功能開關 ==========\n// 設為 false 可暫時停用非冷氣的 HMI 查詢（燈光、窗簾、場景等）\nconst ENABLE_NON_HVAC_QUERY = false;\n\n// Debug 控制\nconst debugConfig = global.get('debug_config') || {\n    topic: true,\n    cache: true,\n    modbus: true,\n    mqtt: true,\n    scene: true,\n    query: true,\n    hmi: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nconst HMI_pattern = [\n    // 窗簾/鐵捲門控制 - 觸發 HA 查詢模式（HMI 直接控制設備，發送 query 讓 HA 更新狀態）\n    {\n        name: \"curtain_control\",\n        pattern: [null, 0x06, 0x01, 0x9b, 0x00, null, null, null],\n        parse: (input) => {\n            const curtainId = input[0];\n            const action = input[5];\n\n            const CURTAIN_MAP = {\n                0x15: { topic: \"homeassistant/cover/curtain/21/query\" },  // 鐵捲門\n                0x16: { topic: \"homeassistant/cover/curtain/22/query\" },  // 會議室捲簾\n                0x17: { topic: \"homeassistant/cover/curtain/23/query\" }   // 多組窗簾\n            };\n\n            const config = CURTAIN_MAP[curtainId];\n            if (!config) return null;\n\n            debugLog('hmi', `HMI窗簾操作: curtainId=0x${curtainId.toString(16).toUpperCase()} action=0x${action.toString(16).toUpperCase()} → 發送query`);\n            return [{ topic: config.topic, payload: \"query\" }];\n        }\n    },\n    // 場景控制（含測試按鈕）- 主動發送查詢序列\n    {\n        name: \"scene_unified\",\n        pattern: [0xfe, 0x06, 0x08, 0x20, null, null, null, null],\n        parse: (input) => {\n            const operation = input[4];\n            const sceneId = input[5];\n\n            // ============================================================\n            // H70 場景對應的設備查詢列表\n            // 場景 ID 格式: 0x02=會議室, 0x03=公共區, 0xFF=全開/全關\n            // 操作: 0x01=S1(ON), 0x02=S2(OFF), 0x03=S3, 0x04=S4\n            // ============================================================\n            const SCENE_QUERY_MAP = {\n                // ============ H70 場景 ============\n                0x02: {\n                    name: \"H70-會議室\",\n                    queries: [\n                        // 群組2: 會議室 (S1=ON 60%, S2=OFF, S3=100%, S4=特殊)\n                        { topic: \"homeassistant/query/single/13/1\", payload: \"query\" },  // 會議間照\n                        { topic: \"homeassistant/query/single/13/2\", payload: \"query\" },  // 冷氣間照\n                        { topic: \"homeassistant/query/single/13/3\", payload: \"query\" },  // 會議崁燈\n                        { topic: \"homeassistant/query/dual/14/a\", payload: \"query\" },    // 軌道燈 (14-1亮度, 14-2色溫)\n                        { topic: \"homeassistant/query/dual/14/b\", payload: \"query\" }     // 會議桌 (14-3亮度, 14-4色溫)\n                    ]\n                },\n                0x03: {\n                    name: \"H70-公共區\",\n                    queries: [\n                        // 群組3: 公共區 (S1=ON 50%, S2=OFF)\n                        { topic: \"homeassistant/query/single/11/1\", payload: \"query\" },  // 走廊間照\n                        { topic: \"homeassistant/query/single/12/1\", payload: \"query\" },  // 泡茶區\n                        { topic: \"homeassistant/query/single/12/2\", payload: \"query\" },  // 走道崁燈\n                        { topic: \"homeassistant/query/single/12/3\", payload: \"query\" }   // 展示櫃\n                    ]\n                },\n                0xFF: {\n                    name: \"H70-全開/全關\",\n                    queries: [\n                        // 群組255: 全開/全關 (S1=全開, S2=全關)\n                        // 會議室區域\n                        { topic: \"homeassistant/query/single/13/1\", payload: \"query\" },  // 會議間照 60%\n                        { topic: \"homeassistant/query/single/13/2\", payload: \"query\" },  // 冷氣間照 60%\n                        { topic: \"homeassistant/query/single/13/3\", payload: \"query\" },  // 會議崁燈 60%\n                        { topic: \"homeassistant/query/dual/14/a\", payload: \"query\" },    // 軌道燈 50%\n                        { topic: \"homeassistant/query/dual/14/b\", payload: \"query\" },    // 會議桌 50%\n                        // 公共區域\n                        { topic: \"homeassistant/query/single/11/1\", payload: \"query\" },  // 走廊間照 50%\n                        { topic: \"homeassistant/query/single/12/1\", payload: \"query\" },  // 泡茶區 50%\n                        { topic: \"homeassistant/query/single/12/2\", payload: \"query\" },  // 走道崁燈 50%\n                        { topic: \"homeassistant/query/single/12/3\", payload: \"query\" }   // 展示櫃 50%\n                    ]\n                },\n\n                // ============ H40 場景 ============\n                0x04: {\n                    name: \"H40-戶外燈\",\n                    queries: [\n                        // 群組4: 戶外燈 (S1=ON 50%, S2=OFF)\n                        { topic: \"homeassistant/query/single/18/1\", payload: \"query\" },  // 1F地燈\n                        { topic: \"homeassistant/query/single/18/2\", payload: \"query\" },  // 1F壁燈\n                        { topic: \"homeassistant/query/single/19/1\", payload: \"query\" },  // 2F壁燈\n                        { topic: \"homeassistant/query/single/19/2\", payload: \"query\" }   // 2F地燈\n                    ]\n                },\n                0x05: {\n                    name: \"H40-室內燈\",\n                    queries: [\n                        // 群組5: 室內燈 (S1=全開50%, S2=全關, S3=舒適, S4=用餐, S5=影音, S6=睡眠)\n                        { topic: \"homeassistant/query/single/15/1\", payload: \"query\" },  // 客廳後\n                        { topic: \"homeassistant/query/single/15/2\", payload: \"query\" },  // 客廳前\n                        { topic: \"homeassistant/query/single/16/2\", payload: \"query\" },  // 走道間照\n                        { topic: \"homeassistant/query/single/17/1\", payload: \"query\" }   // 廚房\n                    ]\n                }\n            };\n\n            const sceneConfig = SCENE_QUERY_MAP[sceneId];\n\n            if (sceneConfig) {\n                debugLog('hmi', `HMI場景按鈕: ${sceneConfig.name}(0x${sceneId.toString(16).padStart(2, '0').toUpperCase()}) 操作0x${operation.toString(16).padStart(2, '0').toUpperCase()} → 發送${sceneConfig.queries.length}個查詢`);\n                return sceneConfig.queries;\n            }\n\n            // 未知場景：fallback 到觸發全部輪詢\n            debugLog('hmi', `HMI場景按鈕: 未知場景0x${sceneId.toString(16).padStart(2, '0').toUpperCase()} 操作0x${operation.toString(16).padStart(2, '0').toUpperCase()} → 觸發全部輪詢`);\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n        }\n    },\n    // 燈光控制 - 觸發輪詢查詢模式\n    {\n        name: \"light_control_unified\",\n        pattern: [0xEE, 0xB1, 0x11, 0x00, null, 0x00, null, 0x13, 0x00, 0x00, null, null, 0xFF, 0xFC, 0xFF, 0xFF],\n        parse: (input) => {\n            const sceneId = input[4];\n            const functionId = input[6];\n            const valueHigh = input[10];\n            const valueLow = input[11];\n            const raw = (valueHigh << 8) + valueLow;\n\n            let value = Math.round((raw / 1000) * 100);\n            value = value < 0 ? 0 : value > 100 ? 100 : value;\n\n            debugLog('hmi', `HMI燈光控制(舊格式): 場景0x${sceneId.toString(16).toUpperCase()} 功能0x${functionId.toString(16).toUpperCase()} 數值=${value}% → 觸發輪詢`);\n            \n            // 觸發輪詢查詢\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n\n            /* 已停用狀態同步\n\n            const LIGHT_MAP = {\n                \"0x1E-0x0B\": { topic: \"homeassistant/light/scene/single/11-1--11-2\", type: \"brightness\" },\n                \"0x1E-0x0D\": { topic: \"homeassistant/light/scene/single/12-1\", type: \"brightness\" },\n                \"0x1E-0x0F\": { topic: \"homeassistant/light/scene/single/12-2\", type: \"brightness\" },\n                \"0x1E-0x11\": { topic: \"homeassistant/light/scene/single/12-3--12-4\", type: \"brightness\" },\n                \"0x1F-0x0B\": { topic: \"homeassistant/light/dual/14/a\", type: \"brightness\" },\n                \"0x1F-0x0D\": { topic: \"homeassistant/light/dual/14/a\", type: \"colortemp\" },\n                \"0x1F-0x0F\": { topic: \"homeassistant/light/dual/14/b\", type: \"brightness\" },\n                \"0x1F-0x11\": { topic: \"homeassistant/light/dual/14/b\", type: \"colortemp\" }\n            };\n\n            const key = `0x${sceneId.toString(16).toUpperCase()}-0x${functionId.toString(16).toUpperCase()}`;\n            const config = LIGHT_MAP[key];\n            if (!config) return null;\n\n            const baseTopic = config.topic;\n\n            if (config.type === \"brightness\") {\n                debugLog('hmi', `HMI燈光狀態: ${baseTopic} 亮度=${value}%`);\n                return [\n                    { topic: `${baseTopic}/state`, payload: state },\n                    { topic: `${baseTopic}/brightness`, payload: value }\n                ];\n            } else if (config.type === \"colortemp\") {\n                const colortemp = Math.round(MAX_MIRED - ((MAX_MIRED - MIN_MIRED) * value / 100));\n                debugLog('hmi', `HMI燈光狀態: ${baseTopic} 色溫=${colortemp} mired`);\n                return [\n                    { topic: `${baseTopic}/colortemp`, payload: colortemp }\n                ];\n            }\n            return null;\n            */\n        }\n    },\n    // 雙色溫燈控制 - 新格式 0x11 帶數值(狀態同步) ⚠️ 必須放在 single_light_control 之前!\n    {\n        name: \"dual_light\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, 0x1F, 0x00, null, 0x13, 0x00, 0x00, null, null, 0xFF, 0xFC, 0xFF, 0xFF],\n        parse: (input) => {\n            const functionId = input[8];   // byte[8]: 功能ID (0x0B=亮度, 0x0D=色溫)\n            const valueHigh = input[12];   // byte[12-13]: 數值 0-1000\n            const valueLow = input[13];\n            const raw = (valueHigh << 8) + valueLow;\n\n            // 映射: 0x0B=A亮度, 0x0D=A色溫, 0x0F=B亮度, 0x11=B色溫\n            const DUAL_MAP = {\n                0x0B: { topic: \"homeassistant/light/dual/14/a\", type: \"brightness\" },\n                0x0D: { topic: \"homeassistant/light/dual/14/a\", type: \"colortemp\" },\n                0x0F: { topic: \"homeassistant/light/dual/14/b\", type: \"brightness\" },\n                0x11: { topic: \"homeassistant/light/dual/14/b\", type: \"colortemp\" }\n            };\n\n            const config = DUAL_MAP[functionId];\n            if (!config) return null;\n\n            const baseTopic = config.topic;\n\n            if (config.type === \"brightness\") {\n                const brightness = Math.round((raw / 1000) * 100);\n                const state = brightness > 0 ? \"ON\" : \"OFF\";\n                debugLog('hmi', `HMI雙色溫燈亮度: ${baseTopic} 亮度=${brightness}%`);\n                return [\n                    { topic: `${baseTopic}/state`, payload: state },\n                    { topic: `${baseTopic}/brightness`, payload: brightness }\n                ];\n            } else if (config.type === \"colortemp\") {\n                const percentage = Math.round((raw / 1000) * 100);\n                const colortemp = Math.round(MAX_MIRED - ((MAX_MIRED - MIN_MIRED) * percentage / 100));\n                debugLog('hmi', `HMI雙色溫燈色溫: ${baseTopic} 色溫=${colortemp} mired (${percentage}%)`);\n                return [\n                    { topic: `${baseTopic}/colortemp`, payload: colortemp }\n                ];\n            }\n\n            return null;\n        }\n    },\n    // 單色燈帶數值控制 - 新格式 0x11 帶數值(狀態同步) ⚠️ 必須放在 single_light_control 之前!\n    {\n        name: \"single_light_with_value\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, null, 0x00, null, 0x13, 0x00, 0x00, null, null, 0xFF, 0xFC, 0xFF, 0xFF],\n        parse: (input) => {\n            const sceneId = input[6];      // byte[6]: 場景ID\n            const functionId = input[8];   // byte[8]: 功能ID\n            const valueHigh = input[12];   // byte[12-13]: 數值 0-1000\n            const valueLow = input[13];\n            const raw = (valueHigh << 8) + valueLow;\n\n            // 映射表: 觸發查詢模式 (因為 HMI 直接控制設備,同一指令可能對應多個燈光)\n            const SINGLE_MAP = {\n                // Scene 0x1E - 走廊區域 + 二樓區域 (會衝突,需要查詢多個設備)\n                \"0x1E-0x0B\": { \n                    topic: \"homeassistant/light/single/11/1\",\n                    name: \"走廊間照+客廳後\",\n                    queryTopics: [\n                        \"homeassistant/query/single/11/1\",\n                        \"homeassistant/query/single/15/2\"\n                    ]\n                },\n                \"0x1E-0x0D\": { \n                    topic: \"homeassistant/light/single/12/1\",\n                    name: \"泡茶區\",\n                    queryTopics: [\"homeassistant/query/single/12/1\"]\n                },\n                \"0x1E-0x0F\": { \n                    topic: \"homeassistant/light/single/12/2\",\n                    name: \"走道崁燈\",\n                    queryTopics: [\"homeassistant/query/single/12/2\"]\n                },\n                \"0x1E-0x11\": { \n                    topic: \"homeassistant/light/single/12/3\",\n                    name: \"展示櫃\",\n                    queryTopics: [\"homeassistant/query/single/12/3\"]\n                },\n                // Scene 0x20 - 會議室區域\n                \"0x20-0x0B\": { \n                    topic: \"homeassistant/light/single/13/1\",\n                    name: \"會議間照\",\n                    queryTopics: [\"homeassistant/query/single/13/1\"]\n                },\n                \"0x20-0x0D\": { \n                    topic: \"homeassistant/light/single/13/2\",\n                    name: \"冷氣間照\",\n                    queryTopics: [\"homeassistant/query/single/13/2\"]\n                },\n                \"0x20-0x0F\": { \n                    topic: \"homeassistant/light/single/13/3\",\n                    name: \"會議崁燈\",\n                    queryTopics: [\"homeassistant/query/single/13/3\"]\n                }\n            };\n\n            const key = `0x${sceneId.toString(16).toUpperCase().padStart(2, '0')}-0x${functionId.toString(16).toUpperCase().padStart(2, '0')}`;\n            const config = SINGLE_MAP[key];\n            if (!config) {\n                debugLog('hmi', `HMI單色燈未匹配: key=\"${key}\" sceneId=${sceneId}(0x${sceneId.toString(16).toUpperCase()}) functionId=${functionId}(0x${functionId.toString(16).toUpperCase()})`);\n                return null;\n            }\n\n            const brightness = Math.round((raw / 1000) * 100);\n            const state = brightness > 0 ? \"ON\" : \"OFF\";\n            \n            debugLog('hmi', `HMI單色燈調整: ${config.name} → 觸發查詢`);\n            \n            // HMI 直接控制設備,這裡發送 query 觸發狀態查詢\n            const commands = [];\n            \n            // 查詢所有可能受影響的燈光\n            if (config.queryTopics && Array.isArray(config.queryTopics)) {\n                for (const queryTopic of config.queryTopics) {\n                    commands.push({ topic: queryTopic, payload: \"query\" });\n                }\n            } else {\n                // 如果沒有指定 queryTopics,則查詢單個設備\n                const parts = config.topic.split(\"/\");\n                const queryTopic = `homeassistant/query/${parts[2]}/${parts[3]}/${parts[4]}`;\n                commands.push({ topic: queryTopic, payload: \"query\" });\n            }\n            \n            return commands;\n        }\n    },\n    // 單色燈控制 - 新格式 0x11 控制指令(觸發輪詢)\n    {\n        name: \"single_light_control\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, null, 0x00, null, 0x13, 0x00, 0x00],\n        parse: (input) => {\n            const sceneId = input[6];      // byte[6]: 場景ID (例如 0x1E)\n            const functionId = input[8];   // byte[8]: 功能ID (例如 0x0B)\n\n            debugLog('hmi', `HMI單色燈控制: 場景0x${sceneId.toString(16).toUpperCase()} 功能0x${functionId.toString(16).toUpperCase()} → 觸發輪詢`);\n            \n            // 觸發輪詢查詢\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n        }\n    },\n    // 單色燈設定值 - 新格式 0x12 ASCII 字串(觸發輪詢)\n    {\n        name: \"single_light_value\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x12, 0x00, null, 0x00, null, 0x00, null],\n        parse: (input) => {\n            const sceneId = input[6];      // byte[6]: 場景ID (例如 0x1E)\n            const functionId = input[8];   // byte[8]: 功能ID (例如 0x15)\n            const length = input[10];      // byte[10]: ASCII 字串長度\n\n            // 提取 ASCII 數值（亮度百分比）\n            let brightness = null;\n            if (length > 0 && input.length >= 11 + length) {\n                let valueStr = '';\n                for (let i = 0; i < length; i++) {\n                    valueStr += String.fromCharCode(input[11 + i]);\n                }\n                brightness = parseInt(valueStr);\n            }\n\n            debugLog('hmi', `HMI單色燈亮度(ASCII): 場景0x${sceneId.toString(16).toUpperCase()} 功能0x${functionId.toString(16).toUpperCase()} 數值=${brightness}% → 觸發輪詢`);\n            \n            // 觸發輪詢查詢\n            return [{ topic: \"homeassistant/polling/trigger\", payload: \"query_all\" }];\n        }\n    },\n    // ========== 空調控制 ==========\n    // HMI 不會直接控制冷氣，需要 Node-RED 發送 Modbus 指令\n    // 這裡發送 set 指令讓 processor_hvac.js 處理\n    // ⚠️ 注意：這些是舊格式，可能不再使用\n    {\n        name: \"hvac_power_mode\",\n        pattern: [0x01, 0x31, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const powerValue = input[2];\n            const hvacId = input[5];\n            const mode = powerValue === 0x01 ? \"cool\" : \"off\";  // 開機預設冷氣模式\n            debugLog('hmi', `HMI空調控制(舊): ${hvacId} 模式=${mode} → 發送控制指令`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_temperature\",\n        pattern: [0x01, 0x32, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const tempValue = input[2];\n            const hvacId = input[5];\n            debugLog('hmi', `HMI空調控制: ${hvacId} 溫度=${tempValue}°C → 發送控制指令`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/temperature/set`, payload: String(tempValue) }];\n        }\n    },\n    {\n        name: \"hvac_mode\",\n        pattern: [0x01, 0x33, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const modeValue = input[2];\n            const hvacId = input[5];\n            const MODE_MAP = {\n                0x00: \"cool\",\n                0x01: \"dry\",\n                0x02: \"fan_only\",\n                0x04: \"heat\"\n            };\n            const mode = MODE_MAP[modeValue];\n            if (!mode) return null;\n            debugLog('hmi', `HMI空調控制: ${hvacId} 模式=${mode} → 發送控制指令`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_fan_speed\",\n        pattern: [0x01, 0x34, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const fanValue = input[2];\n            const hvacId = input[5];\n            const FAN_MAP = {\n                0x03: \"medium\",\n                0x04: \"high\",\n                0x05: \"auto\",\n                0x07: \"low\"\n            };\n            const fan = FAN_MAP[fanValue];\n            if (!fan) return null;\n            debugLog('hmi', `HMI空調控制(舊): ${hvacId} 風量=${fan} → 發送控制指令`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/fan/set`, payload: fan }];\n        }\n    },\n    // HMI 實際格式 - 溫度控制（ASCII 字串格式）\n    // HMI 不會直接控制冷氣，發送 set 指令讓 processor_hvac.js 處理\n    // 格式: [0xEE, 0x00, 0x00, 0xB1, 0x12, 0x00, 0x2C, 0x00, 0x1F, 0x00, 0x02, '3', '1', ...]\n    {\n        name: \"hvac_temperature_ascii\",\n        pattern: [0xEE, 0x00, 0x00, 0xB1, 0x12, 0x00, 0x2C, 0x00, 0x1F, 0x00, null],\n        parse: (input) => {\n            // input[10] 是長度，後面是 ASCII 溫度字串\n            const length = input[10];\n            if (length < 1 || input.length < 11 + length) return null;\n\n            // 提取 ASCII 溫度字串並轉換\n            let tempStr = '';\n            for (let i = 0; i < length; i++) {\n                tempStr += String.fromCharCode(input[11 + i]);\n            }\n\n            const temperature = parseInt(tempStr);\n            if (isNaN(temperature)) return null;\n\n            // 假設 HVAC ID = 1（可能需要從其他地方判斷）\n            const hvacId = 1;\n\n            debugLog('hmi', `HMI空調控制: ${hvacId} 溫度=${temperature}°C (ASCII: \"${tempStr}\") → 發送控制指令`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/temperature/set`, payload: String(temperature) }];\n        }\n    },\n    // HMI 實際格式 - 模式/風速控制\n    // HMI 不會直接控制冷氣，發送 set 指令讓 processor_hvac.js 處理\n    // 格式: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, 0x2C, 0x00, byte8, 0x10, 0x01, 0x01, ...]\n    // byte8 決定模式或風速\n    {\n        name: \"hvac_mode_fanspeed\",\n        pattern: [0xEE, 0x00, 0x65, 0xB1, 0x11, 0x00, 0x2C, 0x00, null, null, null, null],\n        parse: (input) => {\n            const byte8 = input[8];   // 關鍵位置：決定模式或風速\n            const byte9 = input[9];   // 通常是 0x10\n            const byte10 = input[10]; // 通常是 0x01\n            const byte11 = input[11]; // 通常是 0x01\n\n            // 假設 HVAC ID = 1\n            const hvacId = 1;\n\n            // 開關控制（基於 byte8 和 byte11）\n            if (byte8 === 0x0A) {\n                // byte11 決定開關：0x00=關機, 0x01=開機\n                const powerState = byte11 === 0x01 ? \"cool\" : \"off\";  // 開機預設為冷氣模式\n                debugLog('hmi', `HMI空調控制: ${hvacId} 電源=${powerState === \"off\" ? \"關\" : \"開\"} → 發送控制指令`);\n                return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: powerState }];\n            }\n\n            // 模式映射（基於 byte8）\n            const MODE_MAP = {\n                0x0D: \"cool\",      // 冷氣\n                0x10: \"heat\",      // 暖氣\n                0x0E: \"dry\",       // 除濕\n                0x0F: \"fan_only\"   // 送風\n            };\n\n            // 風速映射（基於 byte8）\n            const FAN_MAP = {\n                0x13: \"low\",       // 低速\n                0x12: \"medium\",    // 中速\n                0x11: \"high\",      // 高速\n                0x14: \"auto\"       // 自動\n            };\n\n            // 先檢查是否為模式控制\n            const mode = MODE_MAP[byte8];\n            if (mode) {\n                debugLog('hmi', `HMI空調控制: ${hvacId} 模式=${mode} → 發送控制指令`);\n                return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: mode }];\n            }\n\n            // 再檢查是否為風速控制\n            const fan = FAN_MAP[byte8];\n            if (fan) {\n                debugLog('hmi', `HMI空調控制: ${hvacId} 風速=${fan} → 發送控制指令`);\n                return [{ topic: `homeassistant/hvac/200/${hvacId}/fan/set`, payload: fan }];\n            }\n\n            // 記錄未知格式以便調試\n            debugLog('hmi', `HMI空調未知格式: byte8=0x${byte8.toString(16).padStart(2, '0').toUpperCase()}`);\n            return null;\n        }\n    }\n];\n\nfunction matchPattern(input, pattern) {\n    // 允許 input 長度大於等於 pattern（支援可變長度資料）\n    if (input.length < pattern.length) return false;\n    for (let i = 0; i < pattern.length; i++) {\n        if (pattern[i] !== null && pattern[i] !== input[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// 非冷氣的 pattern 名稱列表（用於開關控制）\nconst NON_HVAC_PATTERNS = [\n    \"curtain_control\",\n    \"scene_unified\",\n    \"light_control_unified\",\n    \"dual_light\",\n    \"single_light_with_value\",\n    \"single_light_control\",\n    \"single_light_value\"\n];\n\nfunction bufferToHexArray(buf) {\n    return [...buf].map(v => \"0x\" + v.toString(16).padStart(2, \"0\").toUpperCase());\n}\n\nif (!msg.payload || !Buffer.isBuffer(msg.payload)) {\n    debugLog('hmi', \"HMI收到無效的 payload\");\n    return null;\n}\n\nlet input = Array.from(msg.payload);\nlet result = null;\nlet matchedPattern = null;\n\nfor (const p of HMI_pattern) {\n    if (matchPattern(input, p.pattern)) {\n        matchedPattern = p.name;\n        debugLog('hmi', `✓ 匹配到 pattern: ${p.name}`);\n\n        // 檢查是否為非冷氣的 pattern，且開關關閉\n        if (!ENABLE_NON_HVAC_QUERY && NON_HVAC_PATTERNS.includes(p.name)) {\n            debugLog('hmi', `⏸ 非冷氣查詢已停用，跳過 ${p.name}`);\n            return null;\n        }\n\n        result = p.parse(input);\n        if (result) {\n            debugLog('hmi', `✓ parse 成功,返回 ${result.length} 個指令`);\n        } else {\n            debugLog('hmi', `✗ parse 返回 null`);\n        }\n        break;\n    }\n}\n\nif (result && Array.isArray(result) && result.length > 0) {\n    debugLog('hmi', `HMI收到: ${bufferToHexArray(msg.payload)} → ${result.length} 個 MQTT 指令`);\n    return [result];\n} else {\n    debugLog('hmi', `HMI收到: ${bufferToHexArray(msg.payload)} (${matchedPattern ? `匹配 ${matchedPattern} 但 parse 失敗` : '未匹配'})`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 920,
        "wires": [
            [
                "d07b2d2692c0e261"
            ]
        ]
    },
    {
        "id": "d07b2d2692c0e261",
        "type": "mqtt out",
        "z": "918f3507cd7a1bdb",
        "g": "6ace5dde2da93230",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 670,
        "y": 920,
        "wires": []
    },
    {
        "id": "192cb4059a9825fe",
        "type": "tcp in",
        "z": "918f3507cd7a1bdb",
        "g": "30f0b97cb1e3438a",
        "name": "",
        "server": "client",
        "host": "192.168.1.252",
        "port": "1030",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 220,
        "y": 920,
        "wires": [
            [
                "872803830a56f19b"
            ]
        ]
    },
    {
        "id": "72168b0198872955",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "name": "feedback_light",
        "func": "/**\n * 燈光 Feedback 處理器 - 解析燈光控制回應\n * \n * Node Type: function\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 輸入：\n *   msg.payload = Buffer (已驗證 CRC 的 Modbus 回應)\n * \n * 輸出：\n *   Output 1: MQTT 狀態 → 連接到 MQTT out\n *   Output 2: Dequeue  → 連接到 modbus_queue\n * \n * 處理的功能碼：\n *   - 0x06: Write Single Register (Single/Dual Light 亮度/色溫)\n *   - 0x05: Write Single Coil (Relay 開關)\n *   - 0x10: Write Multiple Registers (WRGB 顏色)\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { REGISTER_TO_SINGLE, REGISTER_TO_DUAL, COIL_TO_RELAY, REGISTER_TO_WRGB } = CONST;\nconst { makeDequeueMsg, percentToMired } = UTILS;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst buf = msg.payload;\n\nif (!Buffer.isBuffer(buf) || buf.length < 5) {\n    return null;\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\n\n// 只處理燈光相關的功能碼\nif (funcCode !== 0x06 && funcCode !== 0x05 && funcCode !== 0x10) {\n    return null;\n}\n\nlet mqttMessages = [];\n\n// ===== 0x06 Write Single Register (Single/Dual Light) =====\nif (funcCode === 0x06) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const valueOrCoil = buf[5];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `=== Light Feedback (0x06) ===`);\n    debugLog('modbus', `模組: ${moduleId}, 寄存器: 0x${register.toString(16).padStart(4, '0')}, 值: ${valueOrCoil}`);\n    \n    // 檢查是否為 Single Light\n    const singleInfo = REGISTER_TO_SINGLE[register];\n    if (singleInfo) {\n        const { type, channel } = singleInfo;\n        const brightness = valueOrCoil;\n        const state = brightness > 0 ? \"ON\" : \"OFF\";\n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `Single 燈光: ${moduleId}-${channel}, 狀態: ${state}, 亮度: ${brightness}`);\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n        \n        // 更新快取\n        flow.set(`single_${moduleId}_${channel}_state`, state);\n        if (brightness > 0) {\n            flow.set(`single_${moduleId}_${channel}_brightness`, brightness);\n        }\n        \n        node.status({ fill: state === \"ON\" ? \"green\" : \"grey\", shape: \"dot\", text: `Single ${moduleId}-${channel}: ${state} ${brightness}%` });\n    }\n    \n    // 檢查是否為 Dual Light\n    const dualInfo = REGISTER_TO_DUAL[register];\n    if (dualInfo) {\n        const { type, channel, attribute } = dualInfo;\n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        if (attribute === \"brightness\") {\n            const brightness = valueOrCoil;\n            const state = brightness > 0 ? \"ON\" : \"OFF\";\n            \n            debugLog('modbus', `Dual 燈光亮度: ${moduleId}-${channel}, 狀態: ${state}, 亮度: ${brightness}`);\n            \n            mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n            if (state === \"ON\") {\n                mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            }\n            \n            flow.set(`dual_${moduleId}_${channel}_state`, state);\n            if (brightness > 0) {\n                flow.set(`dual_${moduleId}_${channel}_brightness`, brightness);\n            }\n            \n            node.status({ fill: state === \"ON\" ? \"green\" : \"grey\", shape: \"dot\", text: `Dual ${moduleId}-${channel}: ${state} ${brightness}%` });\n            \n        } else if (attribute === \"colortemp\") {\n            const ctPercent = valueOrCoil;\n            const colortemp = percentToMired(ctPercent);\n            \n            debugLog('modbus', `Dual 燈光色溫: ${moduleId}-${channel}, 色溫: ${colortemp} mired (${ctPercent}%)`);\n            \n            mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n            flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n            \n            node.status({ fill: \"yellow\", shape: \"dot\", text: `Dual ${moduleId}-${channel}: ${colortemp} mired` });\n        }\n    }\n}\n\n// ===== 0x05 Write Single Coil (Relay) =====\nelse if (funcCode === 0x05) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const coilValue = buf[4];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `=== Relay Feedback (0x05) ===`);\n    debugLog('modbus', `模組: ${moduleId}, Coil: 0x${register.toString(16).padStart(4, '0')}`);\n    \n    const coilInfo = COIL_TO_RELAY[register];\n    if (coilInfo) {\n        const { channel } = coilInfo;\n        const state = coilValue === 0xFF ? \"ON\" : \"OFF\";\n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `Relay: ${moduleId}-${channel}, 狀態: ${state}`);\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        node.status({ fill: state === \"ON\" ? \"green\" : \"grey\", shape: \"ring\", text: `Relay ${moduleId}-${channel}: ${state}` });\n    }\n}\n\n// ===== 0x10 Write Multiple Registers (WRGB) =====\nelse if (funcCode === 0x10) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `=== WRGB Feedback (0x10) ===`);\n    debugLog('modbus', `模組: ${moduleId}, 寄存器: 0x${register.toString(16).padStart(4, '0')}`);\n    \n    const channel = REGISTER_TO_WRGB[register];\n    if (channel) {\n        const baseTopic = `homeassistant/light/wrgb/${moduleId}/${channel}`;\n        const stateKey = `wrgb_${moduleId}_${channel}_state`;\n        const state = flow.get(stateKey) || \"OFF\";\n        \n        debugLog('modbus', `WRGB: ${moduleId}-${channel}, 狀態確認: ${state}`);\n        \n        // WRGB 回應只確認指令已執行，狀態從 flow context 取得\n        node.status({ fill: state === \"ON\" ? \"magenta\" : \"grey\", shape: \"dot\", text: `WRGB ${moduleId}-${channel}: ${state}` });\n    }\n}\n\n// 回傳 MQTT 訊息和 Dequeue\nif (mqttMessages.length > 0) {\n    return [mqttMessages, makeDequeueMsg()];\n}\n\nreturn [null, makeDequeueMsg()];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 620,
        "wires": [
            [
                "f441a5a695b62120"
            ],
            [
                "a79644de1f2ebde6"
            ]
        ]
    },
    {
        "id": "f85efdd437bcc1a2",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "name": "feedback_hvac",
        "func": "/**\n * HVAC Feedback 處理器 - 解析空調回應\n * \n * Node Type: function\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 輸入：\n *   msg.payload = Buffer (已驗證 CRC 的 Modbus 回應)\n * \n * 輸出：\n *   Output 1: MQTT 狀態 → 連接到 MQTT out\n *   Output 2: Dequeue  → 連接到 modbus_queue\n * \n * 處理的功能碼：\n *   - 0x03: Read Holding Registers (HVAC 狀態回應，長度 17 bytes)\n * \n * HVAC 回應格式 (17 bytes):\n *   [Module_ID] [0x03] [ByteCount] [Power Hi] [Power Lo] [Mode Hi] [Mode Lo] \n *   [Fan Hi] [Fan Lo] [Temp Hi] [Temp Lo] [CurrTemp Hi] [CurrTemp Lo] \n *   [0x00] [HVAC_ID*8] [CRC Lo] [CRC Hi]\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { HVAC_MODE_MAP, HVAC_FAN_MAP } = CONST;\nconst { makeDequeueMsg } = UTILS;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst buf = msg.payload;\n\nif (!Buffer.isBuffer(buf) || buf.length < 5) {\n    return null;\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\n\n// HVAC 回應特徵: 功能碼 0x03, 長度 17 bytes\nif (funcCode !== 0x03 || buf.length !== 17) {\n    return null;\n}\n\ndebugLog('modbus', `=== HVAC Feedback (0x03) ===`);\ndebugLog('modbus', `模組: ${moduleId}, 長度: ${buf.length}`);\n\nlet mqttMessages = [];\n\nconst power_state = buf.readUInt16BE(3);\nconst mode_state = buf.readUInt16BE(5);\nconst fan_mode_state = buf.readUInt16BE(7);\nconst temperature_state = buf.readUInt16BE(9);\nconst current_temperature_state = buf.readUInt16BE(11);\nconst hvac_id = buf.readUInt8(14) / 8;\n\ndebugLog('modbus', `HVAC ID: ${hvac_id}`);\ndebugLog('modbus', `電源: ${power_state}, 模式: ${mode_state}, 風速: ${fan_mode_state}`);\ndebugLog('modbus', `設定溫度: ${temperature_state}°C, 當前溫度: ${current_temperature_state}°C`);\n\n// 當 power_state 為 0 時，將 mode_state 設為 \"off\"\nconst mode_state_str = (power_state === 0) ? \"off\" : (HVAC_MODE_MAP[mode_state] || \"off\");\nconst fan_mode_state_str = HVAC_FAN_MAP[fan_mode_state] || \"auto\";\n\ndebugLog('modbus', `模式字串: ${mode_state_str}, 風速字串: ${fan_mode_state_str}`);\n\n// 發布 MQTT 狀態\nconst baseTopic = `homeassistant/hvac/${moduleId}/${hvac_id}`;\n\nmqttMessages.push({ topic: `${baseTopic}/mode/state`, payload: mode_state_str });\nmqttMessages.push({ topic: `${baseTopic}/fan/state`, payload: fan_mode_state_str });  // fan_mode → fan (配合 config_climates.js)\nmqttMessages.push({ topic: `${baseTopic}/temperature/state`, payload: temperature_state });\nmqttMessages.push({ topic: `${baseTopic}/current_temperature`, payload: current_temperature_state });\n\n// 更新快取\nflow.set(`hvac_${moduleId}_${hvac_id}_mode`, mode_state_str);\nflow.set(`hvac_${moduleId}_${hvac_id}_fan`, fan_mode_state_str);  // fan_mode → fan\nflow.set(`hvac_${moduleId}_${hvac_id}_temperature`, temperature_state);\nflow.set(`hvac_${moduleId}_${hvac_id}_current_temperature`, current_temperature_state);\n\ndebugLog('mqtt', `發布 HVAC 狀態: ${baseTopic}`);\ndebugLog('mqtt', `  模式: ${mode_state_str}, 風速: ${fan_mode_state_str}`);\ndebugLog('mqtt', `  設定溫度: ${temperature_state}°C, 當前溫度: ${current_temperature_state}°C`);\n\nnode.status({\n    fill: \"orange\",\n    shape: \"dot\",\n    text: `HVAC ${moduleId}-${hvac_id}: ${mode_state_str} ${temperature_state}°C (${current_temperature_state}°C)`\n});\n\nreturn [mqttMessages, makeDequeueMsg()];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 660,
        "wires": [
            [
                "f441a5a695b62120"
            ],
            [
                "a79644de1f2ebde6"
            ]
        ]
    },
    {
        "id": "05cc16e472846fc6",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "name": "feedback_query",
        "func": "/**\n * 查詢 Feedback 處理器 - 解析燈光/Relay 查詢回應\n * \n * Node Type: function\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 輸入：\n *   msg.payload = Buffer (已驗證 CRC 的 Modbus 回應)\n * \n * 輸出：\n *   Output 1: MQTT 狀態 → 連接到 MQTT out\n *   Output 2: Dequeue  → 連接到 modbus_queue\n * \n * 處理的功能碼：\n *   - 0x03: Read Holding Registers (燈光亮度/色溫查詢，非 HVAC 長度)\n *   - 0x01: Read Coils (Relay 狀態查詢)\n * \n * 查詢資訊來源：\n *   從 flow.get('modbus_current_query') 或 msg.queryInfo 取得查詢類型和通道\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { MIN_MIRED, MAX_MIRED } = CONST;\nconst { makeDequeueMsg, percentToMired } = UTILS;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst buf = msg.payload;\n\nif (!Buffer.isBuffer(buf) || buf.length < 5) {\n    return null;\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\n\n// 只處理查詢相關的功能碼\n// 0x03 且長度不是 17 (HVAC) → 燈光查詢\n// 0x01 → Relay 查詢\nif (funcCode === 0x03 && buf.length === 17) {\n    // 這是 HVAC 回應，交給 feedback_hvac.js 處理\n    return null;\n}\n\nif (funcCode !== 0x03 && funcCode !== 0x01) {\n    return null;\n}\n\nlet mqttMessages = [];\n\n// ===== 0x03 Read Holding Registers (燈光查詢回應) =====\nif (funcCode === 0x03) {\n    const byteCount = buf[2];\n    \n    debugLog('modbus', `=== Query Feedback (0x03 Read Holding Registers) ===`);\n    debugLog('modbus', `模組: ${moduleId}, Byte Count: ${byteCount}`);\n    \n    if (byteCount < 2) {\n        return [null, makeDequeueMsg()];\n    }\n    \n    // 解析寄存器數據\n    const reg1Hi = buf[3];\n    const reg1Lo = buf[4];\n    const brightness = reg1Lo;\n    const state = brightness > 0 ? \"ON\" : \"OFF\";\n    \n    debugLog('modbus', `寄存器值: 0x${((reg1Hi << 8) | reg1Lo).toString(16).padStart(4, '0')} (亮度: ${brightness})`);\n    \n    // 從 flow context 取得查詢資訊\n    const currentQuery = flow.get('modbus_current_query') || {};\n    const queryInfo = msg.queryInfo || currentQuery.queryInfo || {};\n    \n    const type = queryInfo.type || currentQuery.subType || \"single\";\n    const channel = queryInfo.channel || currentQuery.channel || \"1\";\n    const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n    \n    debugLog('modbus', `查詢結果: ${type} 燈光, 模組 ${moduleId}, 通道 ${channel}`);\n    debugLog('modbus', `狀態: ${state}, 亮度: ${brightness}`);\n    \n    // 發布狀態\n    mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n    if (state === \"ON\") {\n        mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n    }\n    \n    // 更新快取\n    flow.set(`${type}_${moduleId}_${channel}_state`, state);\n    if (brightness > 0) {\n        flow.set(`${type}_${moduleId}_${channel}_brightness`, brightness);\n    }\n    \n    // 如果有第二個寄存器 (Dual Light 色溫)\n    if (byteCount >= 4 && type === \"dual\") {\n        const reg2Lo = buf[6];\n        const ctPercent = reg2Lo;\n        const colortemp = percentToMired(ctPercent);\n        \n        debugLog('modbus', `色溫: ${colortemp} mired (${ctPercent}%)`);\n        \n        mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n        flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n    }\n    \n    node.status({\n        fill: state === \"ON\" ? \"cyan\" : \"grey\",\n        shape: \"ring\",\n        text: `Query: ${type} ${moduleId}-${channel}: ${state} ${brightness}%`\n    });\n}\n\n// ===== 0x01 Read Coils (Relay 查詢回應) =====\nelse if (funcCode === 0x01) {\n    const byteCount = buf[2];\n    const coilStatus = buf[3];\n    \n    debugLog('modbus', `=== Query Feedback (0x01 Read Coils) ===`);\n    debugLog('modbus', `模組: ${moduleId}, Coil 狀態: 0b${coilStatus.toString(2).padStart(8, '0')}`);\n    \n    // 解析每個 Relay 的狀態\n    for (let i = 0; i < 4; i++) {\n        const channel = String(i + 1);\n        const state = (coilStatus & (1 << i)) ? \"ON\" : \"OFF\";\n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        debugLog('mqtt', `Relay ${moduleId}-${channel}: ${state}`);\n    }\n    \n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query: Relay ${moduleId} (1-4)`\n    });\n}\n\nreturn [mqttMessages, makeDequeueMsg()];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 700,
        "wires": [
            [
                "f441a5a695b62120"
            ],
            [
                "a79644de1f2ebde6"
            ]
        ]
    },
    {
        "id": "24d4d68139ea2355",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "name": "feedback router",
        "func": "/**\n * Feedback 路由器 - 驗證 CRC 並分發到對應處理器\n * \n * Node Type: function\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 輸入：\n *   msg.payload = Buffer (來自 Serial Port 的原始 Modbus 回應)\n * \n * 輸出：\n *   Output 1: 燈光回應  → 連接到 feedback_light.js  (0x05, 0x06, 0x10)\n *   Output 2: HVAC 回應 → 連接到 feedback_hvac.js   (0x03 且長度 17)\n *   Output 3: 查詢回應  → 連接到 feedback_query.js  (0x01, 0x03 非 HVAC)\n *   Output 4: Dequeue   → 連接到 modbus_queue       (CRC 失敗時觸發)\n * \n * 連接架構：\n *   Serial Port → feedback_router → feedback_light  → MQTT out\n *                                 → feedback_hvac   → MQTT out\n *                                 → feedback_query  → MQTT out\n *                                 → modbus_queue (dequeue)\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { UTILS } = lib;\nconst { verifyCRC, makeDequeueMsg } = UTILS;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== 主處理邏輯 ==========\nconst buf = msg.payload;\n\n// 檢查是否為有效的 Modbus 資料\nif (!Buffer.isBuffer(buf) || buf.length < 5) {\n    debugLog('modbus', \"回應格式錯誤或長度不足\");\n    return null;\n}\n\n// 過濾 HMI 資料 (開頭是 0xEE)\nif (buf[0] === 0xEE) {\n    debugLog('modbus', \"略過 HMI 資料 (0xEE 開頭)\");\n    return null;\n}\n\n// CRC 驗證\nif (!verifyCRC(buf)) {\n    debugLog('modbus', \"CRC 驗證失敗，觸發下一個指令\");\n    debugLog('modbus', `資料: ${buf.toString('hex')}`);\n    // CRC 失敗仍觸發 dequeue，避免佇列卡住\n    return [null, null, null, makeDequeueMsg()];\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\n\ndebugLog('modbus', `=== Feedback Router ===`);\ndebugLog('modbus', `模組: ${moduleId}, 功能碼: 0x${funcCode.toString(16).padStart(2, '0')}, 長度: ${buf.length}`);\n\n// 根據功能碼和長度分發到對應處理器\nlet lightMsg = null;\nlet hvacMsg = null;\nlet queryMsg = null;\n\nswitch (funcCode) {\n    case 0x05:  // Write Single Coil (Relay)\n    case 0x06:  // Write Single Register (Single/Dual Light)\n    case 0x10:  // Write Multiple Registers (WRGB)\n        lightMsg = msg;\n        debugLog('modbus', `→ 分發到 feedback_light`);\n        break;\n        \n    case 0x03:  // Read Holding Registers\n        if (buf.length === 17) {\n            // HVAC 回應\n            hvacMsg = msg;\n            debugLog('modbus', `→ 分發到 feedback_hvac`);\n        } else {\n            // 燈光查詢回應\n            queryMsg = msg;\n            debugLog('modbus', `→ 分發到 feedback_query`);\n        }\n        break;\n        \n    case 0x01:  // Read Coils (Relay 查詢)\n        queryMsg = msg;\n        debugLog('modbus', `→ 分發到 feedback_query`);\n        break;\n        \n    default:\n        debugLog('modbus', `未知功能碼: 0x${funcCode.toString(16).padStart(2, '0')}`);\n        debugLog('modbus', `原始資料: ${buf.toString('hex')}`);\n        break;\n}\n\nnode.status({\n    fill: \"blue\",\n    shape: \"dot\",\n    text: `Route: 0x${funcCode.toString(16).padStart(2, '0')} → ${lightMsg ? 'light' : hvacMsg ? 'hvac' : queryMsg ? 'query' : 'unknown'}`\n});\n\n// 回傳: [燈光, HVAC, 查詢, Dequeue]\n// 正常情況不需要 dequeue，各處理器會自己發送\nreturn [lightMsg, hvacMsg, queryMsg, null];\n",
        "outputs": 4,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 660,
        "wires": [
            [
                "72168b0198872955"
            ],
            [
                "f85efdd437bcc1a2"
            ],
            [
                "05cc16e472846fc6"
            ],
            [
                "c2943fa3f8dc6c36"
            ]
        ]
    },
    {
        "id": "3e27951d637d9283",
        "type": "mqtt out",
        "z": "918f3507cd7a1bdb",
        "g": "edaf75594da93e05",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 1710,
        "y": 660,
        "wires": []
    },
    {
        "id": "673e66e79a4eed7f",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "RGB的燈光處理器",
        "func": "/**\n * RGB 燈光處理器 (純 RGB，無白光通道)\n * \n * Node Type: function\n * \n * 輸出：\n *   Output 1: Modbus 指令 → 連接到 crc_builder → modbus_queue\n *   Output 2: MQTT 狀態   → 連接到 MQTT out\n * \n * 前置需求：\n *   必須先執行 common.js 初始化共用模組\n * \n * 支援的 Topic 格式:\n *   homeassistant/light/rgb/{moduleId}/{channel}/set\n *   homeassistant/light/rgb/{moduleId}/{channel}/set/brightness\n *   homeassistant/light/rgb/{moduleId}/{channel}/set/rgb\n * \n * 與 WRGB 的差異:\n *   - RGB 只有 3 個通道 (R, G, B)，無白光 (W) 通道\n *   - 亮度分配直接按 RGB 比例計算，不提取白光\n *   - Modbus 指令只發送 3 bytes 資料 + 1 byte 填充\n */\n\n// ========== 載入共用模組 ==========\nconst lib = global.get('lib');\nif (!lib) {\n    node.error('共用模組未初始化，請先執行 common.js');\n    return null;\n}\n\nconst { CONST, UTILS } = lib;\nconst { clamp, buildMultiCommand, parseRgb } = UTILS;\nconst { DEFAULT_BRIGHTNESS, DEFAULT_WRGB, RGB_REGISTER_MAP } = CONST;\n\nfunction debugLog(category, message) {\n    UTILS.debugLog.call({ warn: node.warn.bind(node) }, category, message);\n}\n\n// ========== RGB 亮度計算 (純 RGB，不提取白光) ==========\nfunction rgbToBrightness(r, g, b, brightness) {\n    const total = r + g + b;\n    if (total === 0) {\n        // 若 RGB 都為 0，平均分配亮度\n        const avg = Math.round(brightness / 3);\n        return { r: avg, g: avg, b: avg };\n    }\n    \n    // 亮度最小值映射 (13-100)\n    const minLevel = 13;\n    const maxLevel = 100;\n    const mappedBrightness = Math.round(minLevel + (brightness / 100) * (maxLevel - minLevel));\n    \n    return {\n        r: Math.round(mappedBrightness * r / total),\n        g: Math.round(mappedBrightness * g / total),\n        b: Math.round(mappedBrightness * b / total)\n    };\n}\n\n// ========== 主處理邏輯 ==========\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light\nconst subType = parts[2];        // rgb\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\nif (deviceType !== \"light\" || subType !== \"rgb\") {\n    return null;\n}\n\ndebugLog('topic', `=== RGB 處理器 ===`);\ndebugLog('topic', `Topic: ${msg.topic}, Payload: ${msg.payload}`);\ndebugLog('topic', `Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\nconst baseTopic = `homeassistant/light/rgb/${moduleId}/${channel}`;\n\nconst reg = RGB_REGISTER_MAP[channel];\nif (!reg) {\n    debugLog('modbus', `找不到 RGB 通道 ${channel} 的寄存器`);\n    return null;\n}\n\n// 處理 set/brightness 或 set/rgb\nif (parts.length >= 7 && parts[5] === \"set\") {\n    const attribute = parts[6];\n    const key = `rgb_${moduleId}_${channel}_${attribute}`;\n    \n    if (attribute === \"rgb\") {\n        flow.set(key, msg.payload);\n        debugLog('cache', `儲存 ${key} = ${msg.payload}`);\n    } else if (attribute === \"brightness\") {\n        const val = Number(msg.payload);\n        if (!isNaN(val)) {\n            flow.set(key, val);\n            debugLog('cache', `儲存 ${key} = ${val}`);\n        }\n    }\n    \n    // 亮度或顏色變更時，保持當前開關狀態\n    const stateKey = `rgb_${moduleId}_${channel}_state`;\n    const state = flow.get(stateKey) || \"ON\";\n    msg.payload = state;\n}\n\n// 處理開關指令\nlet state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\nflow.set(`rgb_${moduleId}_${channel}_state`, state);\n\nlet brightness = flow.get(`rgb_${moduleId}_${channel}_brightness`);\nif (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\nbrightness = clamp(Math.round(brightness), 0, 100);\n\nlet rgbString = flow.get(`rgb_${moduleId}_${channel}_rgb`);\nif (!rgbString) rgbString = DEFAULT_WRGB;\n\nconst { r: r_ha, g: g_ha, b: b_ha } = parseRgb(rgbString);\n\nlet r, g, b;\nif (state === \"OFF\") {\n    r = g = b = 0;\n} else {\n    const rgb = rgbToBrightness(r_ha, g_ha, b_ha, brightness);\n    r = rgb.r;\n    g = rgb.g;\n    b = rgb.b;\n}\n\n// 組 Modbus 0x10 指令 (Write Multiple Registers)\n// RGB 指令: 3 bytes 資料 + 1 byte 填充 (0x00)\n\n// const cmd = buildMultiCommand(moduleId, reg, [r, g, b, 0x00]);\nconst cmd = buildMultiCommand(moduleId, reg, [0x00, r, g, b]);//此為龍井個案 請勿繼續使用(U4 ch1 故障)\n\ndebugLog('modbus', `=== Modbus 指令 (RGB) ===`);\ndebugLog('modbus', `原始 RGB: ${r_ha},${g_ha},${b_ha}`);\ndebugLog('modbus', `輸出 RGB: R=${r}, G=${g}, B=${b}`);\ndebugLog('modbus', `指令: ${cmd.toString('hex')}`);\n\nmodbusMessages.push({ payload: cmd, subType: \"rgb\", moduleId, channel, state, brightness, rgb: rgbString });\nmqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\nif (state === \"ON\") {\n    mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n    mqttMessages.push({ topic: `${baseTopic}/rgb`, payload: rgbString });\n}\n\nnode.status({ \n    fill: state === \"ON\" ? \"red\" : \"grey\", \n    shape: \"dot\", \n    text: `RGB ${moduleId}-${channel}: ${state} ${brightness}%`\n});\n\nreturn [modbusMessages, mqttMessages];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 478.33333587646484,
        "y": 540.0000009536743,
        "wires": [
            [
                "98394daf1a815f2b"
            ],
            [
                "d1af9f4f42045c6b"
            ]
        ]
    },
    {
        "id": "2a1a39256a6f96ce",
        "type": "mqtt in",
        "z": "918f3507cd7a1bdb",
        "g": "ede94bdeed93267f",
        "name": "",
        "topic": "homeassistant/light/rgb/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 218.33334350585938,
        "y": 540.0000009536743,
        "wires": [
            [
                "673e66e79a4eed7f"
            ]
        ]
    },
    {
        "id": "57ef8201cf58ceec",
        "type": "inject",
        "z": "918f3507cd7a1bdb",
        "g": "11349d39ba474ecf",
        "name": "輪詢",
        "props": [],
        "repeat": "10",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 910,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "bc699f7fdbcf063e",
        "type": "function",
        "z": "918f3507cd7a1bdb",
        "g": "11349d39ba474ecf",
        "name": "輪詢",
        "func": "/**\n * 輪詢查詢 - 定期查詢所有設備狀態\n * \n * 使用方式：\n * 1. 用 inject 節點觸發（設定 interval，例如每 5 秒）\n * 2. 連接到此 function node\n * 3. 輸出連到 MQTT out，發布查詢主題\n */\n\n// 設定要查詢的設備列表\nconst QUERY_DEVICES = [\n    // ========== 盤A 單色燈光 ==========\n    { type: \"single\", moduleId: 11, channel: \"1\" },  // 走廊間照\n    { type: \"single\", moduleId: 11, channel: \"2\" },  // 走廊間照\n    { type: \"single\", moduleId: 12, channel: \"1\" },  // 泡茶區\n    { type: \"single\", moduleId: 12, channel: \"2\" },  // 走道崁燈\n    { type: \"single\", moduleId: 12, channel: \"3\" },  // 展示櫃\n    { type: \"single\", moduleId: 12, channel: \"4\" },  // 展示櫃\n    { type: \"single\", moduleId: 13, channel: \"1\" },  // 會議間照\n    { type: \"single\", moduleId: 13, channel: \"2\" },  // 冷氣間照\n    { type: \"single\", moduleId: 13, channel: \"3\" },  // 會議崁燈\n    { type: \"single\", moduleId: 13, channel: \"4\" },  // single-13-4\n    \n    // ========== 盤A 雙色溫燈光 ==========\n    { type: \"dual\", moduleId: 14, channel: \"a\" },    // 會議室雙色溫A\n    { type: \"dual\", moduleId: 14, channel: \"b\" },    // 會議室雙色溫B\n    \n    // ========== 盤B 單色燈光 ==========\n    { type: \"single\", moduleId: 15, channel: \"1\" },  // 客廳前\n    { type: \"single\", moduleId: 15, channel: \"2\" },  // 客廳後\n    { type: \"single\", moduleId: 16, channel: \"1\" },  // 走道間照\n    { type: \"single\", moduleId: 16, channel: \"2\" },  // 走道間照\n    { type: \"single\", moduleId: 17, channel: \"1\" },  // 廚房\n    { type: \"single\", moduleId: 17, channel: \"2\" },  // 廚房\n    { type: \"single\", moduleId: 18, channel: \"1\" },  // 1F壁燈\n    { type: \"single\", moduleId: 18, channel: \"2\" },  // 1F地燈\n    { type: \"single\", moduleId: 19, channel: \"1\" },  // 2F壁燈\n    { type: \"single\", moduleId: 19, channel: \"2\" },  // 2F地燈\n    \n    // ========== 窗簾/捲簾 (可選) ==========\n    // { type: \"curtain\", moduleId: 21, channel: \"1-2-3\" },  // 鐵捲門\n    // { type: \"curtain\", moduleId: 22, channel: \"1-2\" },    // 會議室捲簾\n    // { type: \"curtain\", moduleId: 23, channel: \"1-2\" },    // 布簾\n    // { type: \"curtain\", moduleId: 23, channel: \"3-4\" },    // 沙簾\n    // { type: \"curtain\", moduleId: 23, channel: \"5-6-7\" },  // 排煙窗\n\n    // ========== HVAC 空調 ==========\n    { type: \"hvac\", moduleId: 200, channel: \"1\" },  // 客廳空調\n    { type: \"hvac\", moduleId: 200, channel: \"2\" },  // 會議室空調\n    { type: \"hvac\", moduleId: 200, channel: \"3\" },  // 玄關空調\n    // { type: \"hvac\", moduleId: 200, channel: \"9\" },  // 辦公室測試\n];\n\n// 產生查詢訊息\nconst queryMessages = QUERY_DEVICES.map(device => ({\n    topic: `homeassistant/query/${device.type}/${device.moduleId}/${device.channel}`,\n    payload: \"query\"\n}));\nnode.status({\n    fill: \"blue\",\n    shape: \"ring\",\n    text: `查詢 ${queryMessages.length} 個設備`\n});\n\n// 返回多個訊息（每個設備一個）\nreturn [queryMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 200,
        "wires": [
            [
                "1f0cc50a5210bb5b"
            ]
        ]
    },
    {
        "id": "1f0cc50a5210bb5b",
        "type": "mqtt out",
        "z": "918f3507cd7a1bdb",
        "g": "11349d39ba474ecf",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 1160,
        "y": 200,
        "wires": []
    },
    {
        "id": "a87c5b176708ceca",
        "type": "debug",
        "z": "918f3507cd7a1bdb",
        "g": "efe6ce61475a1013",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 710,
        "y": 500,
        "wires": []
    },
    {
        "id": "751ec40a6956d4f9",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.1.250",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]