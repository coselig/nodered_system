[
    {
        "id": "4083c014c4036df7",
        "type": "group",
        "z": "2489f740882ffd1e",
        "name": "å®Œæ•´æ•´åˆæ¸¬è©¦ï¼šLight (Single/Dual/Relay) + Cover + Scene",
        "style": {
            "label": true,
            "stroke": "#7c3aed",
            "fill": "#f3e8ff",
            "fill-opacity": "0.5"
        },
        "nodes": [
            "7b84182b40c2408a",
            "27bd656af41458c7",
            "c3642e1b2e281419",
            "7fdc77cd054beb5f",
            "eb35a4f1a8369e28",
            "3405944690501c27",
            "1301b4bfabe6d00e",
            "a2388fae33290227",
            "8ff2c6df0c7984f0",
            "2361f69cb0630c2d",
            "9506b0dd9dfd9d8c",
            "f3fd3b3a44906912",
            "cc06f2f568357a28",
            "8a1dcb4d8fb68e37",
            "a96e5c88474cb10a",
            "4e57977080ea5596",
            "8128d24c1e30c31b",
            "bfa31e824ef82cb0",
            "5c78efdf4cc08cdc",
            "748cd437883e26c9",
            "9adead2839ee4cf5",
            "9508d90a31f87e7d"
        ],
        "x": 8,
        "y": 39,
        "w": 1218,
        "h": 588
    },
    {
        "id": "7b84182b40c2408a",
        "type": "mqtt in",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "MQTT è¨‚é–±æ‰€æœ‰æ§åˆ¶",
        "topic": "homeassistant/+/+/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "751ec40a6956d4f9",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 200,
        "wires": [
            [
                "27bd656af41458c7"
            ]
        ]
    },
    {
        "id": "27bd656af41458c7",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "å®Œæ•´è™•ç†å™¨ (All Devices)",
        "func": "// å®Œæ•´ç‰ˆè™•ç†å™¨ï¼šæ”¯æ´ Single/Dual/Relay ç‡ˆå…‰ã€Coverã€Scene\n\n// Debug æ§åˆ¶ (é€é global context è¨­å®š)\nconst debugConfig = global.get('debug_config') || {\n    topic: true,        // é¡¯ç¤ºæ”¶åˆ°çš„ Topic\n    cache: true,        // é¡¯ç¤ºå¿«å–æ“ä½œ\n    modbus: true,       // é¡¯ç¤º Modbus æŒ‡ä»¤è©³æƒ…\n    mqtt: true,         // é¡¯ç¤º MQTT ç‹€æ…‹å›å ±\n    scene: true,        // é¡¯ç¤º Scene è™•ç†\n    query: true         // é¡¯ç¤º Query æŸ¥è©¢\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nconst DEFAULT_BRIGHTNESS = 100;\nconst DEFAULT_COLORTEMP = 250;\nconst MIN_MIRED = 167;\nconst MAX_MIRED = 333;\nconst BRIGHTNESS_TIME = 0x05;\nconst CHANNEL_REGISTER_MAP = {\n    \"1\": 0x082A,\n    \"2\": 0x082B,\n    \"3\": 0x082C,\n    \"4\": 0x082D,\n    \"a\": [0x082A, 0x082B],\n    \"b\": [0x082C, 0x082D]\n};\nconst CHANNEL_COIL_MAP = {\n    \"1\": 0x0000,\n    \"2\": 0x0001,\n    \"3\": 0x0002,\n    \"4\": 0x0003\n};\n\nfunction generalCommandBuild(frame) {\n    function crc16(buf) {\n        let crc = 0xFFFF;\n        for (const b of buf) {\n            crc ^= b;\n            for (let i = 0; i < 8; i++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        return crc;\n    }\n    const crc = crc16(frame);\n    return Buffer.concat([frame, Buffer.from([crc & 0xFF, (crc >> 8) & 0xFF])]);\n}\n\nfunction clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\n\nfunction buildCommand(moduleId, reg, value, speed = 0x05) {\n    const hi = (reg >> 8) & 0xFF;\n    const lo = reg & 0xFF;\n    const cmd = Buffer.from([moduleId, 0x06, hi, lo, speed, value]);\n    return generalCommandBuild(cmd);\n}\n\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light, cover, memory\nconst subType = parts[2];        // single, dual, relay, scene, general\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\ndebugLog('topic', `=== æ”¶åˆ°è¨Šæ¯ ===`);\ndebugLog('topic', `Topic: ${msg.topic}`);\ndebugLog('topic', `Payload: ${msg.payload}`);\ndebugLog('topic', `Device: ${deviceType}, SubType: ${subType}, Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\n\n// ========== MEMORY DEVICE (è¨˜æ†¶åŠŸèƒ½) ==========\nif (deviceType === \"memory\") {\n    // æ ¼å¼: homeassistant/memory/{sceneId}/{operation}/save/set\n    // payload: JSON { scene_name, devices, timestamp }\n    const sceneId = parts[2];      // 0x02, 0x03, etc.\n    const operation = parts[3];    // 0x01 (ON), 0x02 (OFF)\n    const action = parts[4];       // save, execute\n\n    if (action === \"save\") {\n        // å„²å­˜è¨˜æ†¶ï¼šè®€å–æ‰€æœ‰è¨­å‚™ç•¶å‰ç‹€æ…‹ä¸¦å„²å­˜\n        let memoryData;\n        try {\n            memoryData = JSON.parse(msg.payload);\n        } catch (e) {\n            debugLog('topic', `è¨˜æ†¶æŒ‡ä»¤ JSON è§£æå¤±æ•—: ${e.message}`);\n            return null;\n        }\n\n        const devices = memoryData.devices || [];\n        const memoryKey = `memory_${sceneId}_${operation}`;\n        const savedStates = {};\n\n        debugLog('cache', `=== å„²å­˜è¨˜æ†¶ ${memoryKey} ===`);\n        debugLog('cache', `å ´æ™¯åç¨±: ${memoryData.scene_name}`);\n        debugLog('cache', `è¨­å‚™æ•¸é‡: ${devices.length}`);\n\n        // è®€å–æ¯å€‹è¨­å‚™çš„ç•¶å‰ç‹€æ…‹\n        for (const deviceTopic of devices) {\n            const deviceParts = deviceTopic.split(\"/\");\n            const devType = deviceParts[1];        // light\n            const devSubType = deviceParts[2];     // single, dual\n            const devModuleId = deviceParts[3];    // 13, 14\n            const devChannel = deviceParts[4];     // 1, a, b\n\n            if (devType === \"light\") {\n                const stateKey = `${devSubType}_${devModuleId}_${devChannel}_state`;\n                const brightnessKey = `${devSubType}_${devModuleId}_${devChannel}_brightness`;\n                const colortempKey = `${devSubType}_${devModuleId}_${devChannel}_colortemp`;\n\n                const state = flow.get(stateKey) || \"OFF\";\n                const brightness = flow.get(brightnessKey) || DEFAULT_BRIGHTNESS;\n                const colortemp = flow.get(colortempKey) || DEFAULT_COLORTEMP;\n\n                savedStates[deviceTopic] = {\n                    state,\n                    brightness,\n                    colortemp: devSubType === \"dual\" ? colortemp : undefined\n                };\n\n                debugLog('cache', `  ${deviceTopic}: ${state} ${brightness}%${devSubType === 'dual' ? ` ${colortemp}K` : ''}`);\n            }\n        }\n\n        // å„²å­˜è¨˜æ†¶è³‡æ–™\n        const memoryRecord = {\n            scene_name: memoryData.scene_name,\n            timestamp: memoryData.timestamp || new Date().toISOString(),\n            devices: savedStates\n        };\n\n        flow.set(memoryKey, memoryRecord);\n        debugLog('cache', `âœ… è¨˜æ†¶å·²å„²å­˜: ${memoryKey}`);\n\n        node.status({\n            fill: \"blue\",\n            shape: \"dot\",\n            text: `è¨˜æ†¶: ${memoryData.scene_name} (${devices.length}å€‹è¨­å‚™)`\n        });\n\n        return null;\n    }\n}\n\n// ========== SCENE DEVICE (å ´æ™¯åŸ·è¡Œï¼ŒåŒ…å«è¨˜æ†¶åŸ·è¡Œ) ==========\nif (deviceType === \"scene\") {\n    // æ ¼å¼: homeassistant/scene/{sceneId}/{operation}/execute/set\n    const sceneId = parts[2];      // 0x02, 0x03, etc.\n    const operation = parts[3];    // 0x01 (ON), 0x02 (OFF)\n    const action = parts[4];       // execute\n\n    if (action === \"execute\") {\n        // åŸ·è¡Œè¨˜æ†¶å ´æ™¯\n        const memoryKey = `memory_${sceneId}_${operation}`;\n        const memoryRecord = flow.get(memoryKey);\n\n        if (!memoryRecord) {\n            debugLog('scene', `âš ï¸ æ‰¾ä¸åˆ°è¨˜æ†¶: ${memoryKey}`);\n            return null;\n        }\n\n        debugLog('scene', `=== åŸ·è¡Œè¨˜æ†¶å ´æ™¯ ${memoryKey} ===`);\n        debugLog('scene', `å ´æ™¯åç¨±: ${memoryRecord.scene_name}`);\n        debugLog('scene', `å„²å­˜æ™‚é–“: ${memoryRecord.timestamp}`);\n\n        const devices = memoryRecord.devices || {};\n        const deviceTopics = Object.keys(devices);\n\n        // å°æ¯å€‹è¨­å‚™ç™¼é€ MQTT æŒ‡ä»¤\n        for (const deviceTopic of deviceTopics) {\n            const savedState = devices[deviceTopic];\n            const deviceParts = deviceTopic.split(\"/\");\n            const devSubType = deviceParts[2];     // single, dual\n            const devModuleId = deviceParts[3];\n            const devChannel = deviceParts[4];\n\n            // å…ˆæ›´æ–°å¿«å–\n            const stateKey = `${devSubType}_${devModuleId}_${devChannel}_state`;\n            const brightnessKey = `${devSubType}_${devModuleId}_${devChannel}_brightness`;\n\n            flow.set(stateKey, savedState.state);\n            flow.set(brightnessKey, savedState.brightness);\n\n            if (devSubType === \"dual\" && savedState.colortemp !== undefined) {\n                const colortempKey = `${devSubType}_${devModuleId}_${devChannel}_colortemp`;\n                flow.set(colortempKey, savedState.colortemp);\n            }\n\n            debugLog('scene', `  ${deviceTopic}: ${savedState.state} ${savedState.brightness}%${savedState.colortemp ? ` ${savedState.colortemp}K` : ''}`);\n\n            // ç™¼é€æ§åˆ¶æŒ‡ä»¤\n            mqttMessages.push({\n                topic: `${deviceTopic}/set`,\n                payload: savedState.state\n            });\n        }\n\n        node.status({\n            fill: \"yellow\",\n            shape: \"ring\",\n            text: `åŸ·è¡Œè¨˜æ†¶: ${memoryRecord.scene_name} (${deviceTopics.length}å€‹è¨­å‚™)`\n        });\n\n        // ç›´æ¥è¿”å› MQTT è¨Šæ¯ï¼Œä¸éœ€è¦ Modbus\n        return [[], mqttMessages];\n    }\n}\n\n// ========== LIGHT DEVICE ==========\nif (deviceType === \"light\") {\n    const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n\n    // è™•ç† set/brightness å’Œ set/colortemp\n    if (parts.length >= 7 && parts[5] === \"set\") {\n        const attribute = parts[6];\n        // Scene çš„ key æ ¼å¼ä¸åŒï¼šscene_single_12-3--12-4_brightness\n        let key;\n        if (subType === \"scene\") {\n            key = `scene_${parts[3]}_${parts[4]}_${attribute}`;\n        } else {\n            key = `${subType}_${moduleId}_${channel}_${attribute}`;\n        }\n        const val = Number(msg.payload);\n\n        if (!isNaN(val)) {\n            flow.set(key, val);\n            debugLog('cache', `å„²å­˜ ${key} = ${val}`);\n        }\n\n        if (attribute === \"brightness\" || attribute === \"colortemp\") {\n            // å°æ–¼ dual ç‡ˆå…‰çš„è‰²æº«èª¿æ•´ï¼Œåªç™¼é€è‰²æº«æŒ‡ä»¤ï¼Œä¸è§¸ç™¼å®Œæ•´æ§åˆ¶æµç¨‹\n            if (subType === \"dual\" && attribute === \"colortemp\") {\n                const regs = CHANNEL_REGISTER_MAP[channel];\n                if (!regs) {\n                    debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n                    return null;\n                }\n                \n                let colortemp = val;\n                colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n                const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n                \n                const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n                \n                debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Dual Colortemp Only) ===`);\n                debugLog('modbus', `è‰²æº«: ${cmdColortemp.toString('hex')}`);\n                \n                modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, colortemp });\n                \n                node.status({\n                    fill: \"yellow\",\n                    shape: \"dot\",\n                    text: `${moduleId}-${channel}: Colortemp ${colortemp}K`\n                });\n                \n                return [modbusMessages, []];\n            }\n            \n            // äº®åº¦æˆ–è‰²æº«è®Šæ›´æ™‚ï¼Œä¿æŒç•¶å‰é–‹é—œç‹€æ…‹ä¸è®Š\n            // 0% ä¸æœƒè‡ªå‹•è®Šæˆ OFFï¼Œéœ€è¦æ˜ç¢ºç™¼é€ OFF æŒ‡ä»¤æ‰æœƒé—œé–‰\n            const stateKey = `${subType}_${moduleId}_${channel}_state`;\n            const state = flow.get(stateKey) || \"ON\";\n            msg.topic = `homeassistant/light/${subType}/${moduleId}/${channel}/set`;\n            msg.payload = state;\n        } else {\n            return null;\n        }\n    }\n\n    // ===== RELAY =====\n    if (subType === \"relay\") {\n        const addr = CHANNEL_COIL_MAP[channel];\n        if (addr === undefined) {\n            debugLog('modbus', `æ‰¾ä¸åˆ° Relay é€šé“ ${channel}`);\n            return null;\n        }\n\n        const state = (msg.payload === \"ON\") ? \"ON\" : \"OFF\";\n        const valHi = (msg.payload === \"ON\") ? 0xFF : 0x00;\n        const valLo = 0x00;\n        const hi = (addr >> 8) & 0xFF;\n        const lo = addr & 0xFF;\n        const frame = Buffer.from([moduleId, 0x05, hi, lo, valHi, valLo]);\n        const cmd = generalCommandBuild(frame);\n\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Relay) ===`);\n        debugLog('modbus', `Coil åœ°å€: 0x${addr.toString(16).padStart(4, '0')}`);\n        debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n\n    // ===== SINGLE =====\n    else if (subType === \"single\") {\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const speed = (state === \"OFF\") ? 0x00 : BRIGHTNESS_TIME;\n        const cmd = buildCommand(moduleId, reg, brValue, speed);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Single) ===`);\n        debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state, brightness });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n\n    // ===== DUAL =====\n    else if (subType === \"dual\") {\n        const regs = CHANNEL_REGISTER_MAP[channel];\n        if (!regs) {\n            debugLog('modbus', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        let colortemp = flow.get(`${subType}_${moduleId}_${channel}_colortemp`);\n        if (typeof colortemp !== \"number\") colortemp = DEFAULT_COLORTEMP;\n        colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n        const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const cmdBrightness = buildCommand(moduleId, regs[0], brValue);\n        const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n        debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Dual) ===`);\n        debugLog('modbus', `äº®åº¦: ${cmdBrightness.toString('hex')}`);\n        debugLog('modbus', `è‰²æº«: ${cmdColortemp.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmdBrightness, subType, moduleId, channel, state, brightness, colortemp });\n        modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, state, brightness, colortemp });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}% ${colortemp}K`\n        });\n    }\n\n    // ===== SCENE =====\n    else if (subType === \"scene\") {\n        const sceneType = parts[3];  // single, dual\n        const lights = parts[4].split(\"--\");  // 12-1--12-2\n        const state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        \n        // Scene å¿«å– key æ ¼å¼: scene_single_12-3--12-4_brightness\n        const groupBrightnessKey = `scene_${sceneType}_${parts[4]}_brightness`;\n        const groupColortempKey = `scene_${sceneType}_${parts[4]}_colortemp`;\n        const groupBrightness = flow.get(groupBrightnessKey);\n        const groupColortemp = flow.get(groupColortempKey);\n\n        debugLog('scene', `=== Scene æ§åˆ¶ ===`);\n        debugLog('scene', `å ´æ™¯é¡å‹: ${sceneType}`);\n        debugLog('scene', `ç‡ˆå…‰åˆ—è¡¨: ${lights.join(\", \")}`);\n        debugLog('scene', `ç‹€æ…‹: ${state}`);\n\n        // ç™¼é€æŒ‡ä»¤åˆ°æ¯å€‹ç‡ˆå…‰\n        for (let light of lights) {\n            const [lightId, lightChannel] = light.split(\"-\");\n            \n            // å…ˆç›´æ¥æ›´æ–°å€‹åˆ¥ç‡ˆå…‰çš„å¿«å–ï¼ˆä¸é€é MQTTï¼‰\n            if (state === \"ON\" && groupBrightness !== undefined) {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_brightness`, groupBrightness);\n                debugLog('scene', `æ›´æ–°å¿«å–: ${sceneType}_${lightId}_${lightChannel}_brightness = ${groupBrightness}`);\n            }\n            if (state === \"ON\" && groupColortemp !== undefined && sceneType === \"dual\") {\n                flow.set(`${sceneType}_${lightId}_${lightChannel}_colortemp`, groupColortemp);\n                debugLog('scene', `æ›´æ–°å¿«å–: ${sceneType}_${lightId}_${lightChannel}_colortemp = ${groupColortemp}`);\n            }\n            \n            // ç„¶å¾Œç™¼é€é–‹é—œæŒ‡ä»¤ï¼ˆæœƒä½¿ç”¨å‰›æ›´æ–°çš„å¿«å–ï¼‰\n            const lightTopic = `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/set`;\n            mqttMessages.push({ topic: lightTopic, payload: state });\n        }\n\n        // æ›´æ–°å ´æ™¯æœ¬èº«çš„ç‹€æ…‹\n        mqttMessages.push({ topic: `homeassistant/light/scene/${sceneType}/${parts[4]}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"yellow\" : \"grey\",\n            shape: \"ring\",\n            text: `Scene: ${lights.length} ç‡ˆ ${state}`\n        });\n    }\n}\n\n// ========== COVER DEVICE ==========\nelse if (deviceType === \"cover\") {\n    // æ ¼å¼: homeassistant/cover/general/12/set\n    // payload: \"1_2/3\" è¡¨ç¤ºé–‹å•Ÿ relay 1 å’Œ 2ï¼Œé—œé–‰ relay 3\n    \n    const relays = msg.payload.split(\"/\");\n    const on_relays = relays[0] ? relays[0].split(\"_\").map(Number) : [];\n    const off_relays = (relays[1] && relays[1].length > 0) ? relays[1].split(\"_\").map(Number) : [];\n\n    let output = 0x00;\n    for (let relay of on_relays) {\n        output |= (1 << (relay - 1));\n    }\n    for (let relay of off_relays) {\n        output &= ~(1 << (relay - 1));\n    }\n\n    const frame = Buffer.from([moduleId, 0x06, 0x01, 0x9b, 0x10, output]);\n    const cmd = generalCommandBuild(frame);\n\n    debugLog('modbus', `=== Modbus æŒ‡ä»¤ (Cover) ===`);\n    debugLog('modbus', `é–‹å•Ÿ Relay: ${on_relays.join(\", \")}`);\n    debugLog('modbus', `é—œé–‰ Relay: ${off_relays.join(\", \")}`);\n    debugLog('modbus', `Bit Mask: 0b${output.toString(2).padStart(8, '0')} (0x${output.toString(16).padStart(2, '0')})`);\n    debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n\n    modbusMessages.push({ payload: cmd, deviceType, moduleId, on_relays, off_relays });\n\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `Cover: ON[${on_relays}] OFF[${off_relays}]`\n    });\n}\n\n\n// ========== QUERY DEVICE (æŸ¥è©¢) ==========\nelse if (deviceType === \"query\") {\n    // æ ¼å¼: homeassistant/query/{subType}/{moduleId}/{channel}\n    // subType: single, dual, relay\n    \n    const querySubType = subType;  // single, dual, relay\n    \n    debugLog('query', `=== Query æŸ¥è©¢ ===`);\n    debugLog('query', `é¡å‹: ${querySubType}, æ¨¡çµ„: ${moduleId}, é€šé“: ${channel}`);\n    \n    let frame;\n    \n    if (querySubType === \"single\" || querySubType === \"dual\") {\n        // æŸ¥è©¢ Single/Dual Light: Read Holding Registers (0x03)\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            debugLog('query', `æ‰¾ä¸åˆ°é€šé“ ${channel} çš„å¯„å­˜å™¨`);\n            return null;\n        }\n        \n        const startReg = Array.isArray(reg) ? reg[0] : reg;  // dual å–ç¬¬ä¸€å€‹å¯„å­˜å™¨\n        const quantity = Array.isArray(reg) ? 2 : 1;  // dual è®€ 2 å€‹ï¼Œsingle è®€ 1 å€‹\n        \n        const regHi = (startReg >> 8) & 0xFF;\n        const regLo = startReg & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n        \n        frame = Buffer.from([moduleId, 0x03, regHi, regLo, qtyHi, qtyLo]);\n        \n        debugLog('query', `è®€å–å¯„å­˜å™¨: 0x${startReg.toString(16).padStart(4, '0')}, æ•¸é‡: ${quantity}`);\n    }\n    else if (querySubType === \"relay\") {\n        // æŸ¥è©¢ Relay: Read Coils (0x01)\n        const addr = CHANNEL_COIL_MAP[channel] || 0x0000;\n        const quantity = 4;  // è®€å– 4 å€‹ coils\n        \n        const addrHi = (addr >> 8) & 0xFF;\n        const addrLo = addr & 0xFF;\n        const qtyHi = (quantity >> 8) & 0xFF;\n        const qtyLo = quantity & 0xFF;\n        \n        frame = Buffer.from([moduleId, 0x01, addrHi, addrLo, qtyHi, qtyLo]);\n        \n        debugLog('query', `è®€å–ç·šåœˆ: 0x${addr.toString(16).padStart(4, '0')}, æ•¸é‡: ${quantity}`);\n    }\n    else {\n        debugLog('query', `ä¸æ”¯æ´çš„æŸ¥è©¢é¡å‹: ${querySubType}`);\n        return null;\n    }\n    \n    const cmd = generalCommandBuild(frame);\n    \n    debugLog('modbus', `=== Modbus æŸ¥è©¢æŒ‡ä»¤ ===`);\n    debugLog('modbus', `æŒ‡ä»¤: ${cmd.toString('hex')}`);\n    \n    // å°‡æŸ¥è©¢è³‡è¨Šé™„åŠ åˆ°æ¯å€‹è¨Šæ¯ä¸­ï¼Œä¾› Feedback ä½¿ç”¨\n    const queryMsg = { \n        payload: cmd, \n        deviceType: \"query\", \n        subType: querySubType, \n        moduleId, \n        channel,\n        queryInfo: { type: querySubType, channel: channel }\n    };\n    modbusMessages.push(queryMsg);\n    \n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query ${querySubType} ${moduleId}-${channel}`\n    });\n}\n\n\nelse {\n    debugLog('topic', `ä¸æ”¯æ´çš„è¨­å‚™é¡å‹: ${deviceType}`);\n    return null;\n}\n\n// è¿”å›: [Modbus æŒ‡ä»¤, MQTT ç‹€æ…‹]\nreturn [modbusMessages, mqttMessages];",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "node.warn(\"=== åˆå§‹åŒ–å®Œæ•´æ¸¬è©¦ç³»çµ± ===\");",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 180,
        "wires": [
            [
                "c3642e1b2e281419",
                "7fdc77cd054beb5f",
                "4e57977080ea5596"
            ],
            [
                "a2388fae33290227",
                "1301b4bfabe6d00e"
            ]
        ]
    },
    {
        "id": "c3642e1b2e281419",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "Modbus æŒ‡ä»¤",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 670,
        "y": 120,
        "wires": []
    },
    {
        "id": "7fdc77cd054beb5f",
        "type": "tcp request",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "TCP â†’ Modbus",
        "server": "192.168.1.208",
        "port": "502",
        "out": "time",
        "ret": "buffer",
        "splitc": "0",
        "newline": "",
        "trim": false,
        "tls": "",
        "x": 620,
        "y": 160,
        "wires": [
            [
                "eb35a4f1a8369e28"
            ]
        ]
    },
    {
        "id": "eb35a4f1a8369e28",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "Feedback è™•ç†å™¨ + ç‹€æ…‹è§£æ",
        "func": "// å®Œæ•´ Feedback è™•ç†å™¨ï¼šè§£æ Modbus å›æ‡‰ä¸¦ç™¼å¸ƒ MQTT ç‹€æ…‹\n\n// Debug æ§åˆ¶\nconst debugConfig = global.get('debug_config') || {\n    topic: true,\n    cache: true,\n    modbus: true,\n    mqtt: true,\n    scene: true,\n    query: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nfunction verifyCRC(buf) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buf.length - 2; i++) {\n        crc ^= buf[i];\n        for (let j = 0; j < 8; j++) {\n            crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n        }\n    }\n    const lo = crc & 0xFF;\n    const hi = (crc >> 8) & 0xFF;\n    return lo === buf[buf.length - 2] && hi === buf[buf.length - 1];\n}\n\nconst buf = msg.payload;\n\nif (!Buffer.isBuffer(buf) || buf.length < 5) {\n    debugLog('modbus', \"å›æ‡‰æ ¼å¼éŒ¯èª¤\");\n    return null;\n}\n\nif (!verifyCRC(buf)) {\n    debugLog('modbus', \"CRC é©—è­‰å¤±æ•—\");\n    return null;\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\n\ndebugLog('modbus', `=== Modbus å›æ‡‰ ===`);\ndebugLog('modbus', `æ¨¡çµ„ID: ${moduleId}`);\ndebugLog('modbus', `åŠŸèƒ½ç¢¼: 0x${funcCode.toString(16).padStart(2, '0')}`);\n\nconst CHANNEL_REGISTER_MAP = {\n    0x082A: { type: \"single\", channel: \"1\" },\n    0x082B: { type: \"single\", channel: \"2\" },\n    0x082C: { type: \"single\", channel: \"3\" },\n    0x082D: { type: \"single\", channel: \"4\" }\n};\n\nconst DUAL_REGISTER_MAP = {\n    0x082A: { type: \"dual\", channel: \"a\", attribute: \"brightness\" },\n    0x082B: { type: \"dual\", channel: \"a\", attribute: \"colortemp\" },\n    0x082C: { type: \"dual\", channel: \"b\", attribute: \"brightness\" },\n    0x082D: { type: \"dual\", channel: \"b\", attribute: \"colortemp\" }\n};\n\nconst RELAY_COIL_MAP = {\n    0x0000: { channel: \"1\" },\n    0x0001: { channel: \"2\" },\n    0x0002: { channel: \"3\" },\n    0x0003: { channel: \"4\" }\n};\n\nlet mqttMessages = [];\n\n// ===== 0x06 Write Single Register (Single/Dual Light) =====\nif (funcCode === 0x06) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const speedOrCoil = buf[4];\n    const valueOrCoil = buf[5];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `å¯„å­˜å™¨: 0x${register.toString(16).padStart(4, '0')}, æ•¸å€¼: ${valueOrCoil}`);\n    \n    const registerInfo = CHANNEL_REGISTER_MAP[register] || DUAL_REGISTER_MAP[register];\n    \n    if (registerInfo) {\n        const { type, channel, attribute } = registerInfo;\n        const brightness = valueOrCoil;  // æœ€å¾Œä¸€å€‹ byte æ˜¯äº®åº¦å€¼\n        const state = brightness > 0 ? \"ON\" : \"OFF\";\n        \n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `=== è§£æ ${type.toUpperCase()} ç‡ˆå…‰ ===`);\n        debugLog('modbus', `é€šé“: ${channel}, ç‹€æ…‹: ${state}, äº®åº¦: ${brightness}`);\n        \n        if (type === \"single\") {\n            // Single Light: ç™¼å¸ƒç‹€æ…‹å’Œäº®åº¦\n            mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n            if (state === \"ON\") {\n                mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            }\n            \n            // æ›´æ–°å¿«å–ï¼šOFF æ™‚ä¸æ›´æ–°äº®åº¦å¿«å–ï¼Œä¿ç•™ä¸Šæ¬¡çš„äº®åº¦å€¼\n            flow.set(`single_${moduleId}_${channel}_state`, state);\n            if (brightness > 0) {\n                flow.set(`single_${moduleId}_${channel}_brightness`, brightness);\n                debugLog('cache', `æ›´æ–°äº®åº¦å¿«å–: single_${moduleId}_${channel}_brightness = ${brightness}`);\n            } else {\n                debugLog('cache', `äº®åº¦ç‚º 0ï¼Œä¿ç•™åŸå¿«å–å€¼: ${flow.get(`single_${moduleId}_${channel}_brightness`)}`);\n            }\n            \n            debugLog('mqtt', `ç™¼å¸ƒç‹€æ…‹: ${baseTopic}/state = ${state}`);\n            if (state === \"ON\") {\n                debugLog('mqtt', `ç™¼å¸ƒäº®åº¦: ${baseTopic}/brightness = ${brightness}`);\n            }\n        } else if (type === \"dual\") {\n            // Dual Light: åˆ†åˆ¥è™•ç†äº®åº¦å’Œè‰²æº«\n            if (attribute === \"brightness\") {\n                mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n                if (state === \"ON\") {\n                    mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n                }\n                flow.set(`dual_${moduleId}_${channel}_state`, state);\n                // OFF æ™‚ä¸æ›´æ–°äº®åº¦å¿«å–ï¼Œä¿ç•™ä¸Šæ¬¡çš„äº®åº¦å€¼\n                if (brightness > 0) {\n                    flow.set(`dual_${moduleId}_${channel}_brightness`, brightness);\n                    debugLog('cache', `æ›´æ–°äº®åº¦å¿«å–: dual_${moduleId}_${channel}_brightness = ${brightness}`);\n                } else {\n                    debugLog('cache', `äº®åº¦ç‚º 0ï¼Œä¿ç•™åŸå¿«å–å€¼: ${flow.get(`dual_${moduleId}_${channel}_brightness`)}`);\n                }\n                \n                debugLog('mqtt', `ç™¼å¸ƒç‹€æ…‹: ${baseTopic}/state = ${state}`);\n            } else if (attribute === \"colortemp\") {\n                // è‰²æº«ç™¾åˆ†æ¯”è½‰å› mired\n                const ctPercent = valueOrCoil;\n                const MIN_MIRED = 167;\n                const MAX_MIRED = 333;\n                const colortemp = Math.round(MAX_MIRED - (ctPercent / 100) * (MAX_MIRED - MIN_MIRED));\n                \n                mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n                flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n                \n                debugLog('mqtt', `ç™¼å¸ƒè‰²æº«: ${baseTopic}/colortemp = ${colortemp} mired (${ctPercent}%)`);\n            }\n        }\n        \n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${type} ${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n}\n\n// ===== 0x05 Write Single Coil (Relay) =====\nelse if (funcCode === 0x05) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const speedOrCoil = buf[4];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `Coil: 0x${register.toString(16).padStart(4, '0')}`);\n    \n    const coilInfo = RELAY_COIL_MAP[register];\n    \n    if (coilInfo) {\n        const { channel } = coilInfo;\n        const state = speedOrCoil === 0xFF ? \"ON\" : \"OFF\";  // 0xFF00 = ON, 0x0000 = OFF\n        \n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `=== è§£æ RELAY ===`);\n        debugLog('modbus', `é€šé“: ${channel}, ç‹€æ…‹: ${state}`);\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        debugLog('mqtt', `ç™¼å¸ƒç‹€æ…‹: ${baseTopic}/state = ${state}`);\n        \n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"ring\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n}\n\n// ===== 0x03 Read Holding Registers (æŸ¥è©¢å›æ‡‰) =====\nelse if (funcCode === 0x03) {\n    const byteCount = buf[2];  // å›å‚³çš„ byte æ•¸é‡\n    \n    debugLog('modbus', `=== æŸ¥è©¢å›æ‡‰ (0x03 Read Holding Registers) ===`);\n    debugLog('modbus', `æ¨¡çµ„ID: ${moduleId}, Byte Count: ${byteCount}`);\n    \n    // è§£æå¯„å­˜å™¨æ•¸æ“š (æ ¼å¼: [æ¨¡çµ„ID] [0x03] [Byte Count] [Reg1 Hi] [Reg1 Lo] [Reg2 Hi] [Reg2 Lo] ... [CRC])\n    if (byteCount >= 2) {\n        const reg1Hi = buf[3];\n        const reg1Lo = buf[4];\n        const reg1Value = (reg1Hi << 8) | reg1Lo;\n        const brightness = reg1Lo;  // ä½ä½å…ƒçµ„æ˜¯äº®åº¦å€¼\n        const state = brightness > 0 ? \"ON\" : \"OFF\";\n        \n        debugLog('modbus', `ç¬¬ä¸€å€‹å¯„å­˜å™¨å€¼: 0x${reg1Value.toString(16).padStart(4, '0')} (äº®åº¦: ${brightness})`);\n        \n        // å¾ msg.payload ä¸­å–å¾—åŸå§‹æŸ¥è©¢çš„å¯„å­˜å™¨åœ°å€ï¼ˆéœ€è¦å¾ç™¼é€æ™‚å„²å­˜ï¼‰\n        // æˆ–è€…æˆ‘å€‘å¯ä»¥æ ¹æ“šæ¨¡çµ„IDå’Œé€šé“ä¾†æ¨æ–·\n        // é€™è£¡æˆ‘å€‘å‡è¨­æŸ¥è©¢ single light channel 1 (0x082A)\n        // æ›´å¥½çš„åšæ³•æ˜¯åœ¨ç™¼é€æŸ¥è©¢æ™‚å°‡å¯„å­˜å™¨åœ°å€é™„åŠ åˆ° msg ä¸­\n        \n        // å¾ msg ä¸­å–å¾—æŸ¥è©¢æ™‚çš„è¨­å‚™è³‡è¨Šï¼ˆç”± Full Processor å‚³éï¼‰\n        const queryInfo = msg.queryInfo || {};\n        const type = queryInfo.type || \"single\";\n        const channel = queryInfo.channel || \"1\";\n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `æŸ¥è©¢çµæœ: ${type} ç‡ˆå…‰, é€šé“ ${channel}`);\n        debugLog('modbus', `ç‹€æ…‹: ${state}, äº®åº¦: ${brightness}`);\n        \n        // ç™¼å¸ƒæŸ¥è©¢åˆ°çš„ç‹€æ…‹\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n        \n        // æ›´æ–°å¿«å–ï¼šæŸ¥è©¢æ™‚å¦‚æœäº®åº¦ç‚º 0ï¼Œä¹Ÿä¸æ›´æ–°äº®åº¦å¿«å–\n        flow.set(`${type}_${moduleId}_${channel}_state`, state);\n        if (brightness > 0) {\n            flow.set(`${type}_${moduleId}_${channel}_brightness`, brightness);\n            debugLog('cache', `æŸ¥è©¢æ›´æ–°äº®åº¦å¿«å–: ${type}_${moduleId}_${channel}_brightness = ${brightness}`);\n        } else {\n            debugLog('cache', `æŸ¥è©¢äº®åº¦ç‚º 0ï¼Œä¿ç•™åŸå¿«å–å€¼: ${flow.get(`${type}_${moduleId}_${channel}_brightness`)}`);\n        }\n        \n        debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒ: ${baseTopic}/state = ${state}`);\n        if (state === \"ON\") {\n            debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒäº®åº¦: ${baseTopic}/brightness = ${brightness}`);\n        }\n        \n        // å¦‚æœæœ‰ç¬¬äºŒå€‹å¯„å­˜å™¨ (Dual Light è‰²æº«)\n        if (byteCount >= 4) {\n            const reg2Hi = buf[5];\n            const reg2Lo = buf[6];\n            const reg2Value = (reg2Hi << 8) | reg2Lo;\n            const ctPercent = reg2Lo;\n            \n            debugLog('modbus', `ç¬¬äºŒå€‹å¯„å­˜å™¨å€¼: 0x${reg2Value.toString(16).padStart(4, '0')} (è‰²æº«%: ${ctPercent})`);\n            \n            const MIN_MIRED = 167;\n            const MAX_MIRED = 333;\n            const colortemp = Math.round(MAX_MIRED - (ctPercent / 100) * (MAX_MIRED - MIN_MIRED));\n            \n            // å¦‚æœæ˜¯ dual lightï¼Œç™¼å¸ƒè‰²æº«\n            if (type === \"dual\") {\n                mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n                flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n                debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒè‰²æº«: ${baseTopic}/colortemp = ${colortemp} mired`);\n            }\n        }\n        \n        node.status({\n            fill: state === \"ON\" ? \"cyan\" : \"grey\",\n            shape: \"ring\",\n            text: `Query: ${type} ${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n}\n\n// ===== 0x01 Read Coils (Relay æŸ¥è©¢å›æ‡‰) =====\nelse if (funcCode === 0x01) {\n    const byteCount = buf[2];\n    const coilStatus = buf[3];  // Coil ç‹€æ…‹ (bit mask)\n    \n    debugLog('modbus', `=== æŸ¥è©¢å›æ‡‰ (0x01 Read Coils) ===`);\n    debugLog('modbus', `æ¨¡çµ„ID: ${moduleId}, Coil ç‹€æ…‹: 0b${coilStatus.toString(2).padStart(8, '0')}`);\n    \n    // è§£ææ¯å€‹ Relay çš„ç‹€æ…‹\n    for (let i = 0; i < 4; i++) {\n        const channel = String(i + 1);\n        const state = (coilStatus & (1 << i)) ? \"ON\" : \"OFF\";\n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        debugLog('mqtt', `æŸ¥è©¢ç™¼å¸ƒ Relay: ${baseTopic}/state = ${state}`);\n    }\n    \n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query: Relay ${moduleId} (1-4)`\n    });\n}\n\nmsg.feedback = {\n    moduleId,\n    funcCode,\n    raw: buf.toString('hex')\n};\n\n// è¿”å›: [Feedback è³‡è¨Š, MQTT ç‹€æ…‹]\nreturn [msg, mqttMessages];",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 160,
        "wires": [
            [
                "3405944690501c27"
            ],
            [
                "1301b4bfabe6d00e",
                "a2388fae33290227"
            ]
        ]
    },
    {
        "id": "3405944690501c27",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "Feedback è§£æ",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "feedback",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 100,
        "wires": []
    },
    {
        "id": "1301b4bfabe6d00e",
        "type": "mqtt out",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "MQTT ç™¼å¸ƒç‹€æ…‹",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 640,
        "y": 220,
        "wires": []
    },
    {
        "id": "a2388fae33290227",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "MQTT ç‹€æ…‹å›å ±",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 180,
        "wires": []
    },
    {
        "id": "8ff2c6df0c7984f0",
        "type": "comment",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "å®Œæ•´æ¸¬è©¦ï¼šæ‰€æœ‰è¨­å‚™é¡å‹ (Light: Single/Dual/Relay, Cover, Scene)",
        "info": "æ”¯æ´çš„è¨­å‚™é¡å‹ï¼š\n\nğŸ”† **Light - Single**\n   - Topic: homeassistant/light/single/{module}/{channel}/set\n   - å–®è‰²ç‡ˆæ§åˆ¶ (äº®åº¦)\n\nğŸ”† **Light - Dual**\n   - Topic: homeassistant/light/dual/{module}/{channel}/set\n   - é›™è‰²æº«ç‡ˆæ§åˆ¶ (äº®åº¦ + è‰²æº«)\n\nğŸ”† **Light - Relay**\n   - Topic: homeassistant/light/relay/{module}/{channel}/set\n   - ç¹¼é›»å™¨é–‹é—œ (ON/OFF)\n\nğŸ¬ **Light - Scene**\n   - Topic: homeassistant/light/scene/{type}/{lights}/set\n   - å ´æ™¯æ§åˆ¶ (æ‰¹æ¬¡æ§åˆ¶å¤šå€‹ç‡ˆ)\n   - ä¾‹å¦‚: scene/single/12-1--12-2/set\n\nğŸªŸ **Cover**\n   - Topic: homeassistant/cover/general/{module}/set\n   - Payload: \"1_2/3\" (é–‹å•Ÿ 1,2 é—œé–‰ 3)\n   - çª—ç°¾æ§åˆ¶ (Bit Mask)\n\nâœ… å®Œæ•´æµç¨‹ï¼š\n   MQTT In â†’ è™•ç†å™¨ â†’ Modbus â†’ Feedback â†’ MQTT Out\n\nâŒ ç„¡ Queue ç³»çµ± (ç›´æ¥ç™¼é€)",
        "x": 270,
        "y": 80,
        "wires": []
    },
    {
        "id": "2361f69cb0630c2d",
        "type": "group",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "",
        "style": {
            "label": true
        },
        "nodes": [
            "4c37d4814250e9da",
            "c00d5d9f4f7ca28e",
            "1019794d8762e773",
            "35de024eb5ccfbf6",
            "bf0fc3175525663f",
            "51a56d0fdf8a2c8b"
        ],
        "x": 34,
        "y": 393,
        "w": 898,
        "h": 208
    },
    {
        "id": "4c37d4814250e9da",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "Debug å…¨é–‹",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":true,\"cache\":true,\"modbus\":true,\"mqtt\":true,\"scene\":true,\"query\":true,\"hmi\":true}",
        "payloadType": "json",
        "x": 150,
        "y": 480,
        "wires": [
            [
                "35de024eb5ccfbf6"
            ]
        ]
    },
    {
        "id": "c00d5d9f4f7ca28e",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "Debug å…¨é—œ",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":false,\"cache\":false,\"modbus\":false,\"mqtt\":false,\"scene\":false,\"query\":false,\"hmi\":false}",
        "payloadType": "json",
        "x": 150,
        "y": 520,
        "wires": [
            [
                "35de024eb5ccfbf6"
            ]
        ]
    },
    {
        "id": "1019794d8762e773",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "åªçœ‹ Modbus",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"topic\":false,\"cache\":false,\"modbus\":true,\"mqtt\":false,\"scene\":false,\"query\":false,\"hmi\":false}",
        "payloadType": "json",
        "x": 150,
        "y": 560,
        "wires": [
            [
                "35de024eb5ccfbf6"
            ]
        ]
    },
    {
        "id": "35de024eb5ccfbf6",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "è¨­å®š Debug é…ç½®",
        "func": "const config = msg.payload;\nglobal.set('debug_config', config);\n\nnode.warn('=== Debug é…ç½®å·²æ›´æ–° ===');\nnode.warn(`Topic: ${config.topic ? 'ON' : 'OFF'}`);\nnode.warn(`Cache: ${config.cache ? 'ON' : 'OFF'}`);\nnode.warn(`Modbus: ${config.modbus ? 'ON' : 'OFF'}`);\nnode.warn(`MQTT: ${config.mqtt ? 'ON' : 'OFF'}`);\nnode.warn(`Scene: ${config.scene ? 'ON' : 'OFF'}`);\nnode.warn(`Query: ${config.query ? 'ON' : 'OFF'}`);\nnode.warn(`HMI: ${config.hmi ? 'ON' : 'OFF'}`);\n\nnode.status({\n    fill: 'green',\n    shape: 'dot',\n    text: `å·²æ›´æ–° Debug é…ç½®`\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "bf0fc3175525663f",
        "type": "comment",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "name": "Debug æ§åˆ¶ï¼šå‹•æ…‹åˆ‡æ› debug è¨Šæ¯é¡¯ç¤º",
        "info": "é€é global.debug_config æ§åˆ¶è¦é¡¯ç¤ºå“ªäº› debug è¨Šæ¯\n\nå¯æ§åˆ¶çš„é¡åˆ¥ï¼š\n- topic: é¡¯ç¤ºæ”¶åˆ°çš„ Topic å’Œ Payload\n- cache: é¡¯ç¤ºå¿«å–æ“ä½œ\n- modbus: é¡¯ç¤º Modbus æŒ‡ä»¤è©³æƒ…\n- mqtt: é¡¯ç¤º MQTT ç‹€æ…‹å›å ±\n- scene: é¡¯ç¤º Scene è™•ç†\n\nå¿«é€Ÿåˆ‡æ›ï¼š\n- å…¨é–‹ï¼šæ‰€æœ‰ debug è¨Šæ¯\n- å…¨é—œï¼šé—œé–‰æ‰€æœ‰ debug è¨Šæ¯\n- åªçœ‹ Modbusï¼šåªé¡¯ç¤º Modbus æŒ‡ä»¤",
        "x": 210,
        "y": 440,
        "wires": []
    },
    {
        "id": "51a56d0fdf8a2c8b",
        "type": "group",
        "z": "2489f740882ffd1e",
        "g": "2361f69cb0630c2d",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "542bd36f97c1d4d4",
            "f8b978725dc2372b",
            "4c41b8ab0cd9ced1",
            "22eb6fe245fdde0f"
        ],
        "x": 494,
        "y": 419,
        "w": 412,
        "h": 142
    },
    {
        "id": "542bd36f97c1d4d4",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "æ¸…é™¤å¿«å–",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 600,
        "y": 460,
        "wires": [
            [
                "f8b978725dc2372b"
            ]
        ]
    },
    {
        "id": "f8b978725dc2372b",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "æ¸…é™¤æ‰€æœ‰å¿«å–",
        "func": "const keys = flow.keys();\nlet count = 0;\nkeys.forEach(k => {\n    if (k.startsWith('single_') || k.startsWith('dual_') || k.startsWith('relay_') || k.startsWith('scene_')) {\n        flow.set(k, undefined);\n        node.warn(`æ¸…é™¤: ${k}`);\n        count++;\n    }\n});\nnode.warn(`=== å·²æ¸…é™¤ ${count} ç­†å¿«å– ===`);\nnode.status({\n    fill: \"blue\",\n    shape: \"ring\",\n    text: `å·²æ¸…é™¤ ${count} ç­†`\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "4c41b8ab0cd9ced1",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "é¡¯ç¤ºå¿«å–",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 600,
        "y": 520,
        "wires": [
            [
                "22eb6fe245fdde0f"
            ]
        ]
    },
    {
        "id": "22eb6fe245fdde0f",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "51a56d0fdf8a2c8b",
        "name": "é¡¯ç¤ºæ‰€æœ‰å¿«å–",
        "func": "node.warn(\"=== Flow Context å…§å®¹ ===\");\nconst keys = flow.keys();\nconst filtered = keys.filter(k => \n    k.startsWith('single_') || \n    k.startsWith('dual_') || \n    k.startsWith('relay_') || \n    k.startsWith('scene_')\n);\n\nif (filtered.length === 0) {\n    node.warn(\"ç›®å‰æ²’æœ‰ä»»ä½•å¿«å–è³‡æ–™\");\n} else {\n    // åˆ†é¡é¡¯ç¤º\n    const groups = {\n        single: [],\n        dual: [],\n        relay: [],\n        scene: []\n    };\n    \n    filtered.forEach(k => {\n        const value = flow.get(k);\n        if (k.startsWith('single_')) groups.single.push(`${k}: ${value}`);\n        else if (k.startsWith('dual_')) groups.dual.push(`${k}: ${value}`);\n        else if (k.startsWith('relay_')) groups.relay.push(`${k}: ${value}`);\n        else if (k.startsWith('scene_')) groups.scene.push(`${k}: ${value}`);\n    });\n    \n    if (groups.single.length > 0) {\n        node.warn(\"--- Single ---\");\n        groups.single.forEach(s => node.warn(s));\n    }\n    if (groups.dual.length > 0) {\n        node.warn(\"--- Dual ---\");\n        groups.dual.forEach(s => node.warn(s));\n    }\n    if (groups.relay.length > 0) {\n        node.warn(\"--- Relay ---\");\n        groups.relay.forEach(s => node.warn(s));\n    }\n    if (groups.scene.length > 0) {\n        node.warn(\"--- Scene ---\");\n        groups.scene.forEach(s => node.warn(s));\n    }\n    \n    node.warn(`=== å…± ${filtered.length} ç­†å¿«å– ===`);\n}\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "9506b0dd9dfd9d8c",
        "type": "tcp in",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI è¼¸å…¥ (TCP)",
        "server": "server",
        "host": "0.0.0.0",
        "port": "8888",
        "datamode": "stream",
        "datatype": "buffer",
        "newline": "",
        "topic": "",
        "trim": false,
        "base64": false,
        "tls": "",
        "x": 120,
        "y": 260,
        "wires": [
            [
                "f3fd3b3a44906912"
            ]
        ]
    },
    {
        "id": "f3fd3b3a44906912",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI è™•ç†å™¨",
        "func": "const MIN_MIRED = 167, MAX_MIRED = 333;\n\n// Debug æ§åˆ¶\nconst debugConfig = global.get('debug_config') || {\n    topic: true,\n    cache: true,\n    modbus: true,\n    mqtt: true,\n    scene: true,\n    query: true,\n    hmi: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nconst HMI_pattern = [\n    // çª—ç°¾æ§åˆ¶\n    {\n        name: \"curtain_control\",\n        pattern: [null, 0x06, 0x01, 0x9b, 0x00, null, null, null],\n        parse: (input) => {\n            const curtainId = input[0];\n            const action = input[5];\n\n            const CURTAIN_MAP = {\n                0x15: { topic: \"homeassistant/cover/curtain/21/ocs/set\", type: \"ocs\" },\n                0x16: { topic: \"homeassistant/cover/curtain/22/oc/set\", type: \"oc\" },\n                0x17: { topic: \"homeassistant/cover/curtain/23\", type: \"multi\" }\n            };\n\n            const config = CURTAIN_MAP[curtainId];\n            if (!config) return null;\n\n            let payload, topicSuffix;\n\n            if (config.type === \"ocs\") {\n                const ACTION_MAP_OCS = {\n                    0x01: \"1/2-3\",\n                    0x04: \"2/1-3\",\n                    0x02: \"3/1-2\"\n                };\n                payload = ACTION_MAP_OCS[action];\n                topicSuffix = \"/set\";\n            } else if (config.type === \"oc\") {\n                const ACTION_MAP_OC = {\n                    0x01: \"1/2\",\n                    0x02: \"2/1\",\n                    0x03: \"1-2/\"\n                };\n                payload = ACTION_MAP_OC[action];\n                topicSuffix = \"/set\";\n            } else if (config.type === \"multi\") {\n                const ACTION_MAP_MULTI = {\n                    0x01: { suffix: \"/oc/set\", payload: \"1/2\" },\n                    0x03: { suffix: \"/oc/set\", payload: \"1_2/\" },\n                    0x02: { suffix: \"/oc/set\", payload: \"2/1\" },\n                    0x04: { suffix: \"/oc/set\", payload: \"3/4\" },\n                    0x0C: { suffix: \"/oc/set\", payload: \"3_4/\" },\n                    0x08: { suffix: \"/oc/set\", payload: \"4/3\" },\n                    0x10: { suffix: \"/ocs/set\", payload: \"5/6_7\" },\n                    0x40: { suffix: \"/ocs/set\", payload: \"7/5_6\" },\n                    0x20: { suffix: \"/ocs/set\", payload: \"6/5_7\" }\n                };\n                const actionConfig = ACTION_MAP_MULTI[action];\n                if (!actionConfig) return null;\n                topicSuffix = actionConfig.suffix;\n                payload = actionConfig.payload;\n            }\n\n            if (!payload) return null;\n            return [{ topic: config.topic + topicSuffix, payload: payload }];\n        }\n    },\n    // å ´æ™¯æ§åˆ¶\n    {\n        name: \"scene_unified\",\n        pattern: [0xfe, 0x06, 0x08, 0x20, null, null, null, null],\n        parse: (input) => {\n            const operation = input[4];\n            const sceneId = input[5];\n\n            // è¨˜æ†¶æŒ‡ä»¤è™•ç†\n            if (operation >= 0x81 && operation <= 0x88) {\n                const MEMORY_TO_TEST_MAP = {\n                    0x81: { sceneId: \"0x02\", operation: \"0x01\" },\n                    0x82: { sceneId: \"0x02\", operation: \"0x02\" },\n                    0x83: { sceneId: \"0x03\", operation: \"0x01\" },\n                    0x84: { sceneId: \"0x03\", operation: \"0x02\" },\n                    0x85: { sceneId: \"0x04\", operation: \"0x01\" },\n                    0x86: { sceneId: \"0x04\", operation: \"0x02\" },\n                    0x87: { sceneId: \"0x05\", operation: \"0x01\" },\n                    0x88: { sceneId: \"0x05\", operation: \"0x02\" }\n                };\n\n                const SCENE_MEMORY_MAP = {\n                    \"0x02\": {\n                        name: \"æœƒè­°å®¤\", devices: [\n                            \"homeassistant/light/single/13/1\",\n                            \"homeassistant/light/single/13/2\",\n                            \"homeassistant/light/single/13/3\",\n                            \"homeassistant/light/dual/14/a\",\n                            \"homeassistant/light/dual/14/b\"\n                        ]\n                    },\n                    \"0x03\": {\n                        name: \"å…¬å…±å€\", devices: [\n                            \"homeassistant/light/single/11/1\",\n                            \"homeassistant/light/single/11/2\",\n                            \"homeassistant/light/single/12/1\",\n                            \"homeassistant/light/single/12/2\",\n                            \"homeassistant/light/single/12/3\",\n                            \"homeassistant/light/single/12/4\"\n                        ]\n                    },\n                    \"0x04\": {\n                        name: \"æˆ¶å¤–\", devices: [\n                            \"homeassistant/light/single/18/1\",\n                            \"homeassistant/light/single/18/2\",\n                            \"homeassistant/light/single/19/1\",\n                            \"homeassistant/light/single/19/2\"\n                        ]\n                    },\n                    \"0x05\": {\n                        name: \"H40äºŒæ¨“\", devices: [\n                            \"homeassistant/light/single/15/1\",\n                            \"homeassistant/light/single/15/2\",\n                            \"homeassistant/light/single/16/1\",\n                            \"homeassistant/light/single/16/2\",\n                            \"homeassistant/light/single/17/1\",\n                            \"homeassistant/light/single/17/2\",\n                            \"homeassistant/light/single/18/1\",\n                            \"homeassistant/light/single/18/2\",\n                            \"homeassistant/light/single/19/1\",\n                            \"homeassistant/light/single/19/2\"\n                        ]\n                    }\n                };\n\n                const mapping = MEMORY_TO_TEST_MAP[operation];\n                if (!mapping) return null;\n\n                const targetSceneId = mapping.sceneId;\n                const targetOperation = mapping.operation;\n                const sceneInfo = SCENE_MEMORY_MAP[targetSceneId];\n                if (!sceneInfo) return null;\n\n                const opNames = { \"0x01\": \"ON\", \"0x02\": \"OFF\" };\n                const opName = opNames[targetOperation] || targetOperation;\n                const memoryTopic = `homeassistant/memory/${targetSceneId}/${targetOperation}/save/set`;\n                const buttonNum = operation - 0x80;\n\n                debugLog('hmi', `HMIè¨˜æ†¶æŒ‰éˆ•${buttonNum} â†’ ${sceneInfo.name}_${opName}`);\n\n                return [{\n                    topic: memoryTopic,\n                    payload: JSON.stringify({\n                        scene_name: `${sceneInfo.name}_${opName}`,\n                        devices: sceneInfo.devices,\n                        timestamp: new Date().toISOString()\n                    })\n                }];\n            }\n\n            // æ¸¬è©¦æŒ‰éˆ•è™•ç†\n            const testSceneIds = [0x02, 0x03, 0x04, 0x05];\n            if ((operation === 0x01 || operation === 0x02) && testSceneIds.includes(sceneId)) {\n                const sceneKey = `0x${sceneId.toString(16).padStart(2, '0').toUpperCase()}`;\n                const opKey = `0x${operation.toString(16).padStart(2, '0').toUpperCase()}`;\n                debugLog('hmi', `HMIæ¸¬è©¦æŒ‰éˆ•: å ´æ™¯${sceneKey} æ“ä½œ${opKey}`);\n                return [{\n                    topic: `homeassistant/scene/${sceneKey}/${opKey}/execute/set`,\n                    payload: \"ON\"\n                }];\n            }\n\n            // ä¸€èˆ¬å ´æ™¯æ§åˆ¶\n            const sceneKey = `0x${sceneId.toString(16).toUpperCase()}`;\n            const opKey = `0x${operation.toString(16).padStart(2, '0').toUpperCase()}`;\n            return [{\n                topic: `homeassistant/scene/${sceneKey}/${opKey}/execute/set`,\n                payload: \"ON\"\n            }];\n        }\n    },\n    // ç‡ˆå…‰æ§åˆ¶\n    {\n        name: \"light_control_unified\",\n        pattern: [0xEE, 0xB1, 0x11, 0x00, null, 0x00, null, 0x13, 0x00, 0x00, null, null, 0xFF, 0xFC, 0xFF, 0xFF],\n        parse: (input) => {\n            const sceneId = input[4];\n            const functionId = input[6];\n            const valueHigh = input[10];\n            const valueLow = input[11];\n            const raw = (valueHigh << 8) + valueLow;\n\n            let value = Math.round((raw / 1000) * 100);\n            value = value < 0 ? 0 : value > 100 ? 100 : value;\n            let state = value > 0 ? \"ON\" : \"OFF\";\n\n            const LIGHT_MAP = {\n                \"0x1E-0x0B\": { topic: \"homeassistant/light/scene/single/11-1--11-2\", type: \"brightness\" },\n                \"0x1E-0x0D\": { topic: \"homeassistant/light/scene/single/12-1\", type: \"brightness\" },\n                \"0x1E-0x0F\": { topic: \"homeassistant/light/scene/single/12-2\", type: \"brightness\" },\n                \"0x1E-0x11\": { topic: \"homeassistant/light/scene/single/12-3--12-4\", type: \"brightness\" },\n                \"0x1F-0x0B\": { topic: \"homeassistant/light/dual/14/a\", type: \"brightness\" },\n                \"0x1F-0x0D\": { topic: \"homeassistant/light/dual/14/a\", type: \"colortemp\" },\n                \"0x1F-0x0F\": { topic: \"homeassistant/light/dual/14/b\", type: \"brightness\" },\n                \"0x1F-0x11\": { topic: \"homeassistant/light/dual/14/b\", type: \"colortemp\" }\n            };\n\n            const key = `0x${sceneId.toString(16).toUpperCase()}-0x${functionId.toString(16).toUpperCase()}`;\n            const config = LIGHT_MAP[key];\n            if (!config) return null;\n\n            const baseTopic = config.topic;\n\n            if (config.type === \"brightness\") {\n                debugLog('hmi', `HMIç‡ˆå…‰æ§åˆ¶: ${baseTopic} äº®åº¦=${value}%`);\n                return [\n                    { topic: `${baseTopic}/set/brightness`, payload: value }\n                ];\n            } else if (config.type === \"colortemp\") {\n                const colortemp = Math.round(MAX_MIRED - ((MAX_MIRED - MIN_MIRED) * value / 100));\n                debugLog('hmi', `HMIç‡ˆå…‰æ§åˆ¶: ${baseTopic} è‰²æº«=${colortemp} mired`);\n                return [\n                    { topic: `${baseTopic}/set/colortemp`, payload: colortemp }\n                ];\n            }\n            return null;\n        }\n    },\n    // ç©ºèª¿æ§åˆ¶\n    {\n        name: \"hvac_power_mode\",\n        pattern: [0x01, 0x31, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const powerValue = input[2];\n            const hvacId = input[5];\n            const mode = powerValue === 0x01 ? \"auto\" : \"off\";\n            debugLog('hmi', `HMIç©ºèª¿: ${hvacId} æ¨¡å¼=${mode}`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_temperature\",\n        pattern: [0x01, 0x32, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const tempValue = input[2];\n            const hvacId = input[5];\n            debugLog('hmi', `HMIç©ºèª¿: ${hvacId} æº«åº¦=${tempValue}Â°C`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/temperature/set`, payload: String(tempValue) }];\n        }\n    },\n    {\n        name: \"hvac_mode\",\n        pattern: [0x01, 0x33, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const modeValue = input[2];\n            const hvacId = input[5];\n            const MODE_MAP = {\n                0x00: \"cool\",\n                0x01: \"dry\",\n                0x02: \"fan_only\",\n                0x04: \"heat\"\n            };\n            const mode = MODE_MAP[modeValue];\n            if (!mode) return null;\n            debugLog('hmi', `HMIç©ºèª¿: ${hvacId} æ¨¡å¼=${mode}`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_fan_speed\",\n        pattern: [0x01, 0x34, null, 0x01, 0x01, null],\n        parse: (input) => {\n            const fanValue = input[2];\n            const hvacId = input[5];\n            const FAN_MAP = {\n                0x03: \"medium\",\n                0x04: \"high\",\n                0x07: \"low\"\n            };\n            const fan = FAN_MAP[fanValue];\n            if (!fan) return null;\n            const topicSuffix = hvacId === 1 ? \"fan/set\" : \"mode/fan\";\n            debugLog('hmi', `HMIç©ºèª¿: ${hvacId} é¢¨é‡=${fan}`);\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/${topicSuffix}`, payload: fan }];\n        }\n    }\n];\n\nfunction matchPattern(input, pattern) {\n    if (input.length !== pattern.length) return false;\n    for (let i = 0; i < pattern.length; i++) {\n        if (pattern[i] !== null && pattern[i] !== input[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction bufferToHexArray(buf) {\n    return [...buf].map(v => \"0x\" + v.toString(16).padStart(2, \"0\").toUpperCase());\n}\n\nif (!msg.payload || !Buffer.isBuffer(msg.payload)) {\n    debugLog('hmi', \"HMIæ”¶åˆ°ç„¡æ•ˆçš„ payload\");\n    return null;\n}\n\nlet input = Array.from(msg.payload);\nlet result = null;\n\nfor (const p of HMI_pattern) {\n    if (matchPattern(input, p.pattern)) {\n        result = p.parse(input);\n        break;\n    }\n}\n\nif (result && Array.isArray(result) && result.length > 0) {\n    debugLog('hmi', `HMIæ”¶åˆ°: ${bufferToHexArray(msg.payload)} â†’ ${result.length} å€‹ MQTT æŒ‡ä»¤`);\n    return [result];\n} else {\n    debugLog('hmi', `HMIæ”¶åˆ°: ${bufferToHexArray(msg.payload)} (æœªåŒ¹é…)`);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 260,
        "wires": [
            [
                "cc06f2f568357a28",
                "1301b4bfabe6d00e"
            ]
        ]
    },
    {
        "id": "cc06f2f568357a28",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI æŒ‡ä»¤",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 260,
        "wires": []
    },
    {
        "id": "8a1dcb4d8fb68e37",
        "type": "comment",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "HMI è§¸æ§è¢å¹•ï¼šçª—ç°¾/å ´æ™¯/ç‡ˆå…‰/ç©ºèª¿æ§åˆ¶",
        "info": "HMI è§¸æ§è¢å¹•è¼¸å…¥è™•ç†\n\næ”¯æ´åŠŸèƒ½ï¼š\nğŸªŸ çª—ç°¾æ§åˆ¶ - éµæ²é–€/æœƒè­°å®¤æ²ç°¾/å¸ƒç°¾/ç´—ç°¾/æ’ç…™çª—\nğŸ¬ å ´æ™¯æ§åˆ¶ - å ´æ™¯è¨˜æ†¶/æ¸¬è©¦æŒ‰éˆ•/ä¸€èˆ¬å ´æ™¯\nğŸ’¡ ç‡ˆå…‰æ§åˆ¶ - äº®åº¦/è‰²æº«èª¿ç¯€\nâ„ï¸ ç©ºèª¿æ§åˆ¶ - é–‹é—œ/æº«åº¦/æ¨¡å¼/é¢¨é‡\n\næµç¨‹ï¼š\nTCP In (8888) â†’ HMI è™•ç†å™¨ â†’ MQTT Out",
        "x": 200,
        "y": 320,
        "wires": []
    },
    {
        "id": "a96e5c88474cb10a",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æŸ¥è©¢æ‰€æœ‰è¨˜æ†¶",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "homeassistant/memory/query/all",
        "x": 150,
        "y": 160,
        "wires": [
            [
                "27bd656af41458c7"
            ]
        ]
    },
    {
        "id": "4e57977080ea5596",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¨˜æ†¶æŸ¥è©¢çµæœ",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 700,
        "y": 80,
        "wires": []
    },
    {
        "id": "8128d24c1e30c31b",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æ¸…é™¤æ‰€æœ‰è¨˜æ†¶",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "clear",
        "payloadType": "str",
        "x": 130,
        "y": 360,
        "wires": [
            [
                "bfa31e824ef82cb0"
            ]
        ]
    },
    {
        "id": "bfa31e824ef82cb0",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æ¸…é™¤æ‰€æœ‰è¨˜æ†¶",
        "func": "const keys = flow.keys();\nlet count = 0;\nkeys.forEach(k => {\n    if (k.startsWith('memory_')) {\n        flow.set(k, undefined);\n        node.warn(`æ¸…é™¤: ${k}`);\n        count++;\n    }\n});\nnode.warn(`=== å·²æ¸…é™¤ ${count} ç­†è¨˜æ†¶ ===`);\nnode.status({\n    fill: 'blue',\n    shape: 'ring',\n    text: `å·²æ¸…é™¤ ${count} ç­†`\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 360,
        "wires": [
            [
                "5c78efdf4cc08cdc"
            ]
        ]
    },
    {
        "id": "5c78efdf4cc08cdc",
        "type": "debug",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "æ¸…é™¤è¨˜æ†¶çµæœ",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 360,
        "wires": []
    },
    {
        "id": "748cd437883e26c9",
        "type": "inject",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¨»å†Šè™›æ“¬è£ç½®",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 140,
        "y": 120,
        "wires": [
            [
                "9adead2839ee4cf5"
            ]
        ]
    },
    {
        "id": "9adead2839ee4cf5",
        "type": "function",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "è¨»å†Šè£ç½®",
        "func": "/**\n * general configuration - Home Assistant MQTT é…ç½®ç”Ÿæˆå™¨\n * æ”¯æ´: Lights (å–®è‰²/é›™è‰²), Scenes, Covers (çª—ç°¾/æ²ç°¾), Climate (ç©ºèª¿)\n */\n\n// ============ è¨­å‚™å®šç¾© ============\n\n// 1. ç‡ˆå…‰è¨­å‚™\nlet lights = [\n    // ç›¤A\n    { id: \"single_11_1\", name: \"single-11-1\" },\n    { id: \"single_11_2\", name: \"single-11-2\" },\n    { id: \"single_12_1\", name: \"single-12-1\" },\n    { id: \"single_12_2\", name: \"single-12-2\" },\n    { id: \"single_12_3\", name: \"single-12-3\" },\n    { id: \"single_12_4\", name: \"single-12-4\" },\n    { id: \"single_13_1\", name: \"single-13-1\" },\n    { id: \"single_13_2\", name: \"single-13-2\" },\n    { id: \"single_13_3\", name: \"single-13-3\" },\n    { id: \"single_13_4\", name: \"single-13-4\" },\n    { id: \"dual_14_a\", name: \"dual-14-a\" },\n    { id: \"dual_14_b\", name: \"dual-14-b\" },\n    // ç›¤B\n    { id: \"single_15_1\", name: \"single-15-1\" },\n    { id: \"single_15_2\", name: \"single-15-2\" },\n    { id: \"single_16_1\", name: \"single-16-1\" },\n    { id: \"single_16_2\", name: \"single-16-2\" },\n    { id: \"single_17_1\", name: \"single-17-1\" },\n    { id: \"single_17_2\", name: \"single-17-2\" },\n    { id: \"single_18_1\", name: \"single-18-1\" },\n    { id: \"single_18_2\", name: \"single-18-2\" },\n    { id: \"single_19_1\", name: \"single-19-1\" },\n    { id: \"single_19_2\", name: \"single-19-2\" },\n];\n\n// 2. æƒ…å¢ƒè¨­å‚™\nlet scenes = [\n    { id: \"scene_single_11-1--11-2\", name: \"èµ°å»Šé–“ç…§\" },\n    { id: \"scene_single_12-1\", name: \"æ³¡èŒ¶å€\" },\n    { id: \"scene_single_12-2\", name: \"èµ°é“å´ç‡ˆ\" },\n    { id: \"scene_single_12-3--12-4\", name: \"å±•ç¤ºæ«ƒ\" },\n    { id: \"scene_single_13-1\", name: \"æœƒè­°é–“ç…§\" },\n    { id: \"scene_single_13-2\", name: \"å†·æ°£é–“ç…§\" },\n    { id: \"scene_single_13-3\", name: \"æœƒè­°å´ç‡ˆ\" },\n    { id: \"scene_single_15-1\", name: \"å®¢å»³å‰\" },\n    { id: \"scene_single_15-2\", name: \"å®¢å»³å¾Œ\" },\n    { id: \"scene_single_16-1--16-2\", name: \"èµ°é“é–“ç…§\" },\n    { id: \"scene_single_17-1--17-2\", name: \"å»šæˆ¿\" },\n    { id: \"scene_single_18-1\", name: \"1Få£ç‡ˆ\" },\n    { id: \"scene_single_18-2\", name: \"1Fåœ°ç‡ˆ\" },\n    { id: \"scene_single_19-1\", name: \"2Få£ç‡ˆ\" },\n    { id: \"scene_single_19-2\", name: \"2Fåœ°ç‡ˆ\" },\n    // å ´æ™¯ç‡ˆå…‰ç¾¤çµ„ (ç”¨æ–¼å ´æ™¯æ§åˆ¶)\n    { id: \"scene_single_11-1--11-2--12-1--12-2--12-3--12-4\", name: \"å…¬å…±å€ç‡ˆçµ„\" },\n    { id: \"scene_single_13-1--13-2--13-3\", name: \"æœƒè­°å®¤ç‡ˆçµ„\" },\n    { id: \"scene_dual_14-a--14-b\", name: \"æœƒè­°å®¤é›™è‰²æº«ç‡ˆçµ„\" },\n    { id: \"scene_single_15-1--15-2--16-1--17-1--18-1--18-2--19-1--19-2\", name: \"äºŒæ¨“ç‡ˆçµ„\" },\n    { id: \"scene_single_18-1--18-2--19-1--19-2\", name: \"æˆ¶å¤–ç‡ˆçµ„\" },\n];\n\n// 3. çª—ç°¾/æ²ç°¾è¨­å‚™\nlet covers = [\n    { id: \"curtain_21_1-2-3\", name: \"éµæ²é–€\" },\n    { id: \"curtain_22_1-2\", name: \"æœƒè­°å®¤æ²ç°¾\" },\n    { id: \"curtain_23_1-2\", name: \"å¸ƒç°¾\" },\n    { id: \"curtain_23_3-4\", name: \"æ²™ç°¾\" },\n    { id: \"curtain_23_5-6-7\", name: \"æ’ç…™çª—\" },\n];\n\n// 4. ç©ºèª¿è¨­å‚™\nlet climates = [\n    { id: \"200-1\", name: \"å®¢å»³ç©ºèª¿\" },\n    { id: \"200-2\", name: \"æœƒè­°å®¤ç©ºèª¿\" },\n    { id: \"200-3\", name: \"ç„é—œç©ºèª¿\" },\n    { id: \"200-9\", name: \"è¾¦å…¬å®¤æ¸¬è©¦\" }\n];\n\n// ============ é…ç½®ç”Ÿæˆå‡½æ•¸ ============\n\n// ç”Ÿæˆç‡ˆå…‰é…ç½®\nfunction generateLightConfigs(lights) {\n    return lights.map(light => {\n        let parts = light.id.split(\"_\");\n        let basePayload = {\n            name: light.name,\n            unique_id: light.id,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            optimistic: true,\n            state_topic: `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/state`,\n            command_topic: `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set`,\n        };\n        \n        switch(parts[0]) {\n            case \"single\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/colortemp`;\n                basePayload.color_temp_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"relay\": {\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/light/${light.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆæƒ…å¢ƒé…ç½®\nfunction generateSceneConfigs(scenes) {\n    return scenes.map(scene => {\n        let parts = scene.id.split(\"_\");\n        let prefix = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}`;\n        let basePayload = {\n            name: scene.name,\n            unique_id: scene.id,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            optimistic: true,\n            state_topic: `${prefix}/state`,\n            command_topic: `${prefix}/set`,\n        };\n        \n        switch(parts[1]) {\n            case \"single\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `${prefix}/colortemp`;\n                basePayload.color_temp_command_topic = `${prefix}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"relay\": {\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/light/${scene.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆçª—ç°¾é…ç½®\nfunction generateCoverConfigs(covers) {\n    return covers.map(cover => {\n        let part = cover.id.split(\"_\");\n        let device_type = part[0];\n        let id = part[1];\n        let control = (part[2]).split(\"-\");\n\n        let basePayload = {\n            name: cover.name,\n            unique_id: cover.id,\n            optimistic: true,\n            retain: true\n        };\n\n        let operation_type;\n        switch (control.length) {\n            case 2: {\n                operation_type = \"oc\";\n                basePayload.payload_open = `${control[0]}/${control[1]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}`;\n                basePayload.payload_stop = `${control[0]}_${control[1]}/`;\n                break;\n            }\n            case 3: {\n                operation_type = \"ocs\";\n                basePayload.payload_open = `${control[0]}/${control[1]}_${control[2]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}_${control[2]}`;\n                basePayload.payload_stop = `${control[2]}/${control[0]}_${control[1]}`;\n                break;\n            }\n            default: {\n                node.warn(\"Unknown type of curtain\");\n                break;\n            }\n        }\n        \n        basePayload.command_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/set`;\n        basePayload.state_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/state`;\n\n        return {\n            topic: `homeassistant/cover/${cover.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆç©ºèª¿é…ç½®\nfunction generateClimateConfigs(climates) {\n    let ui_name = \"climate\";\n    let topic_name = \"hvac\";\n\n    return climates.map(ac => {\n        const parts = ac.id.split(\"-\");\n        const s200_id = parts[0];\n        const id = parts[1];\n        const prefix = `homeassistant/${topic_name}/${s200_id}/${id}`;\n\n        const base = {\n            name: ac.name,\n            unique_id: ac.id,\n            optimistic: true,\n            modes: [\"off\", \"cool\", \"heat\", \"dry\", \"fan_only\", \"auto\"],\n            mode_command_topic: `${prefix}/mode/set`,\n            mode_state_topic: `${prefix}/mode/state`,\n            temperature_command_topic: `${prefix}/temperature/set`,\n            temperature_state_topic: `${prefix}/temperature/state`,\n            min_temp: 16,\n            max_temp: 30,\n            temp_step: 1,\n            current_temperature_topic: `${prefix}/current_temperature`,\n            fan_modes: [\"auto\", \"low\", \"medium\", \"high\"],\n            fan_mode_command_topic: `${prefix}/fan/set`,\n            fan_mode_state_topic: `${prefix}/fan/state`,\n            retain: true,\n        };\n\n        return {\n            topic: `homeassistant/${ui_name}/${ac.id}/config`,\n            payload: base,\n            retain: true\n        };\n    });\n}\n\n// ============ ä¸»è¦åŸ·è¡Œ ============\n\n// ç”Ÿæˆæ‰€æœ‰é…ç½®\nlet allMessages = [\n    ...generateLightConfigs(lights),\n    ...generateSceneConfigs(scenes),\n    ...generateCoverConfigs(covers),\n    ...generateClimateConfigs(climates)\n];\n\n// è¿”å›æ‰€æœ‰è¨Šæ¯\nreturn [allMessages];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 120,
        "wires": [
            [
                "9508d90a31f87e7d"
            ]
        ]
    },
    {
        "id": "9508d90a31f87e7d",
        "type": "mqtt out",
        "z": "2489f740882ffd1e",
        "g": "4083c014c4036df7",
        "name": "",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "751ec40a6956d4f9",
        "x": 490,
        "y": 120,
        "wires": []
    },
    {
        "id": "751ec40a6956d4f9",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.1.233",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]