{
    "id": "c543b1d15612a8c6",
    "type": "function",
    "z": "14580213f897af9a",
    "g": "108057c6b0820334",
    "name": "Feedback 處理器 + 狀態解析",
    "func": "// 完整 Feedback 處理器：解析 Modbus 回應並發布 MQTT 狀態\n\n// Debug 控制\nconst debugConfig = global.get('debug_config') || {\n    topic: true,\n    cache: true,\n    modbus: true,\n    mqtt: true,\n    scene: true,\n    query: true\n};\n\nfunction debugLog(category, message) {\n    if (debugConfig[category]) {\n        node.warn(message);\n    }\n}\n\nfunction verifyCRC(buf) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buf.length - 2; i++) {\n        crc ^= buf[i];\n        for (let j = 0; j < 8; j++) {\n            crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n        }\n    }\n    const lo = crc & 0xFF;\n    const hi = (crc >> 8) & 0xFF;\n    return lo === buf[buf.length - 2] && hi === buf[buf.length - 1];\n}\n\nconst buf = msg.payload;\n\nif (!Buffer.isBuffer(buf) || buf.length < 5) {\n    debugLog('modbus', \"回應格式錯誤\");\n    return null;\n}\n\nif (!verifyCRC(buf)) {\n    debugLog('modbus', \"CRC 驗證失敗\");\n    return null;\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\n\ndebugLog('modbus', `=== Modbus 回應 ===`);\ndebugLog('modbus', `模組ID: ${moduleId}`);\ndebugLog('modbus', `功能碼: 0x${funcCode.toString(16).padStart(2, '0')}`);\n\nconst CHANNEL_REGISTER_MAP = {\n    0x082A: { type: \"single\", channel: \"1\" },\n    0x082B: { type: \"single\", channel: \"2\" },\n    0x082C: { type: \"single\", channel: \"3\" },\n    0x082D: { type: \"single\", channel: \"4\" }\n};\n\nconst DUAL_REGISTER_MAP = {\n    0x082A: { type: \"dual\", channel: \"a\", attribute: \"brightness\" },\n    0x082B: { type: \"dual\", channel: \"a\", attribute: \"colortemp\" },\n    0x082C: { type: \"dual\", channel: \"b\", attribute: \"brightness\" },\n    0x082D: { type: \"dual\", channel: \"b\", attribute: \"colortemp\" }\n};\n\nconst RELAY_COIL_MAP = {\n    0x0000: { channel: \"1\" },\n    0x0001: { channel: \"2\" },\n    0x0002: { channel: \"3\" },\n    0x0003: { channel: \"4\" }\n};\n\nlet mqttMessages = [];\n\n// ===== 0x06 Write Single Register (Single/Dual Light) =====\nif (funcCode === 0x06) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const speedOrCoil = buf[4];\n    const valueOrCoil = buf[5];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `寄存器: 0x${register.toString(16).padStart(4, '0')}, 數值: ${valueOrCoil}`);\n    \n    const registerInfo = CHANNEL_REGISTER_MAP[register] || DUAL_REGISTER_MAP[register];\n    \n    if (registerInfo) {\n        const { type, channel, attribute } = registerInfo;\n        const brightness = valueOrCoil;  // 最後一個 byte 是亮度值\n        const state = brightness > 0 ? \"ON\" : \"OFF\";\n        \n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `=== 解析 ${type.toUpperCase()} 燈光 ===`);\n        debugLog('modbus', `通道: ${channel}, 狀態: ${state}, 亮度: ${brightness}`);\n        \n        if (type === \"single\") {\n            // Single Light: 發布狀態和亮度\n            mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n            if (state === \"ON\") {\n                mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            }\n            \n            // 更新快取：OFF 時不更新亮度快取，保留上次的亮度值\n            flow.set(`single_${moduleId}_${channel}_state`, state);\n            if (brightness > 0) {\n                flow.set(`single_${moduleId}_${channel}_brightness`, brightness);\n                debugLog('cache', `更新亮度快取: single_${moduleId}_${channel}_brightness = ${brightness}`);\n            } else {\n                debugLog('cache', `亮度為 0，保留原快取值: ${flow.get(`single_${moduleId}_${channel}_brightness`)}`);\n            }\n            \n            debugLog('mqtt', `發布狀態: ${baseTopic}/state = ${state}`);\n            if (state === \"ON\") {\n                debugLog('mqtt', `發布亮度: ${baseTopic}/brightness = ${brightness}`);\n            }\n        } else if (type === \"dual\") {\n            // Dual Light: 分別處理亮度和色溫\n            if (attribute === \"brightness\") {\n                mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n                if (state === \"ON\") {\n                    mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n                }\n                flow.set(`dual_${moduleId}_${channel}_state`, state);\n                // OFF 時不更新亮度快取，保留上次的亮度值\n                if (brightness > 0) {\n                    flow.set(`dual_${moduleId}_${channel}_brightness`, brightness);\n                    debugLog('cache', `更新亮度快取: dual_${moduleId}_${channel}_brightness = ${brightness}`);\n                } else {\n                    debugLog('cache', `亮度為 0，保留原快取值: ${flow.get(`dual_${moduleId}_${channel}_brightness`)}`);\n                }\n                \n                debugLog('mqtt', `發布狀態: ${baseTopic}/state = ${state}`);\n            } else if (attribute === \"colortemp\") {\n                // 色溫百分比轉回 mired\n                const ctPercent = valueOrCoil;\n                const MIN_MIRED = 167;\n                const MAX_MIRED = 333;\n                const colortemp = Math.round(MAX_MIRED - (ctPercent / 100) * (MAX_MIRED - MIN_MIRED));\n                \n                mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n                flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n                \n                debugLog('mqtt', `發布色溫: ${baseTopic}/colortemp = ${colortemp} mired (${ctPercent}%)`);\n            }\n        }\n        \n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${type} ${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n}\n\n// ===== 0x05 Write Single Coil (Relay) =====\nelse if (funcCode === 0x05) {\n    const regHi = buf[2];\n    const regLo = buf[3];\n    const speedOrCoil = buf[4];\n    const register = (regHi << 8) | regLo;\n    \n    debugLog('modbus', `Coil: 0x${register.toString(16).padStart(4, '0')}`);\n    \n    const coilInfo = RELAY_COIL_MAP[register];\n    \n    if (coilInfo) {\n        const { channel } = coilInfo;\n        const state = speedOrCoil === 0xFF ? \"ON\" : \"OFF\";  // 0xFF00 = ON, 0x0000 = OFF\n        \n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `=== 解析 RELAY ===`);\n        debugLog('modbus', `通道: ${channel}, 狀態: ${state}`);\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        debugLog('mqtt', `發布狀態: ${baseTopic}/state = ${state}`);\n        \n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"ring\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n}\n\n// ===== 0x03 Read Holding Registers (查詢回應) =====\nelse if (funcCode === 0x03) {\n    const byteCount = buf[2];  // 回傳的 byte 數量\n    \n    debugLog('modbus', `=== 查詢回應 (0x03 Read Holding Registers) ===`);\n    debugLog('modbus', `模組ID: ${moduleId}, Byte Count: ${byteCount}`);\n    \n    // 解析寄存器數據 (格式: [模組ID] [0x03] [Byte Count] [Reg1 Hi] [Reg1 Lo] [Reg2 Hi] [Reg2 Lo] ... [CRC])\n    if (byteCount >= 2) {\n        const reg1Hi = buf[3];\n        const reg1Lo = buf[4];\n        const reg1Value = (reg1Hi << 8) | reg1Lo;\n        const brightness = reg1Lo;  // 低位元組是亮度值\n        const state = brightness > 0 ? \"ON\" : \"OFF\";\n        \n        debugLog('modbus', `第一個寄存器值: 0x${reg1Value.toString(16).padStart(4, '0')} (亮度: ${brightness})`);\n        \n        // 從 msg.payload 中取得原始查詢的寄存器地址（需要從發送時儲存）\n        // 或者我們可以根據模組ID和通道來推斷\n        // 這裡我們假設查詢 single light channel 1 (0x082A)\n        // 更好的做法是在發送查詢時將寄存器地址附加到 msg 中\n        \n        // 從 msg 中取得查詢時的設備資訊（由 Full Processor 傳遞）\n        const queryInfo = msg.queryInfo || {};\n        const type = queryInfo.type || \"single\";\n        const channel = queryInfo.channel || \"1\";\n        const baseTopic = `homeassistant/light/${type}/${moduleId}/${channel}`;\n        \n        debugLog('modbus', `查詢結果: ${type} 燈光, 通道 ${channel}`);\n        debugLog('modbus', `狀態: ${state}, 亮度: ${brightness}`);\n        \n        // 發布查詢到的狀態\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n        \n        // 更新快取：查詢時如果亮度為 0，也不更新亮度快取\n        flow.set(`${type}_${moduleId}_${channel}_state`, state);\n        if (brightness > 0) {\n            flow.set(`${type}_${moduleId}_${channel}_brightness`, brightness);\n            debugLog('cache', `查詢更新亮度快取: ${type}_${moduleId}_${channel}_brightness = ${brightness}`);\n        } else {\n            debugLog('cache', `查詢亮度為 0，保留原快取值: ${flow.get(`${type}_${moduleId}_${channel}_brightness`)}`);\n        }\n        \n        debugLog('mqtt', `查詢發布: ${baseTopic}/state = ${state}`);\n        if (state === \"ON\") {\n            debugLog('mqtt', `查詢發布亮度: ${baseTopic}/brightness = ${brightness}`);\n        }\n        \n        // 如果有第二個寄存器 (Dual Light 色溫)\n        if (byteCount >= 4) {\n            const reg2Hi = buf[5];\n            const reg2Lo = buf[6];\n            const reg2Value = (reg2Hi << 8) | reg2Lo;\n            const ctPercent = reg2Lo;\n            \n            debugLog('modbus', `第二個寄存器值: 0x${reg2Value.toString(16).padStart(4, '0')} (色溫%: ${ctPercent})`);\n            \n            const MIN_MIRED = 167;\n            const MAX_MIRED = 333;\n            const colortemp = Math.round(MAX_MIRED - (ctPercent / 100) * (MAX_MIRED - MIN_MIRED));\n            \n            // 如果是 dual light，發布色溫\n            if (type === \"dual\") {\n                mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n                flow.set(`dual_${moduleId}_${channel}_colortemp`, colortemp);\n                debugLog('mqtt', `查詢發布色溫: ${baseTopic}/colortemp = ${colortemp} mired`);\n            }\n        }\n        \n        node.status({\n            fill: state === \"ON\" ? \"cyan\" : \"grey\",\n            shape: \"ring\",\n            text: `Query: ${type} ${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n}\n\n// ===== 0x01 Read Coils (Relay 查詢回應) =====\nelse if (funcCode === 0x01) {\n    const byteCount = buf[2];\n    const coilStatus = buf[3];  // Coil 狀態 (bit mask)\n    \n    debugLog('modbus', `=== 查詢回應 (0x01 Read Coils) ===`);\n    debugLog('modbus', `模組ID: ${moduleId}, Coil 狀態: 0b${coilStatus.toString(2).padStart(8, '0')}`);\n    \n    // 解析每個 Relay 的狀態\n    for (let i = 0; i < 4; i++) {\n        const channel = String(i + 1);\n        const state = (coilStatus & (1 << i)) ? \"ON\" : \"OFF\";\n        const baseTopic = `homeassistant/light/relay/${moduleId}/${channel}`;\n        \n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        flow.set(`relay_${moduleId}_${channel}_state`, state);\n        \n        debugLog('mqtt', `查詢發布 Relay: ${baseTopic}/state = ${state}`);\n    }\n    \n    node.status({\n        fill: \"cyan\",\n        shape: \"ring\",\n        text: `Query: Relay ${moduleId} (1-4)`\n    });\n}\n\nmsg.feedback = {\n    moduleId,\n    funcCode,\n    raw: buf.toString('hex')\n};\n\n// 返回: [Feedback 資訊, MQTT 狀態]\nreturn [msg, mqttMessages];",
    "outputs": 2,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 880,
    "y": 2080,
    "wires": [
        [
            "846a05abdd99da9a"
        ],
        [
            "e67cfaa863dbcbf7",
            "91359a179be62f4c"
        ]
    ]
}