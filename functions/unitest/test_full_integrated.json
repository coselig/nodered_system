[
    {
        "id": "test_group_full",
        "type": "group",
        "z": "e345e003a053a625",
        "name": "ÂÆåÊï¥Êï¥ÂêàÊ∏¨Ë©¶ÔºöLight (Single/Dual/Relay) + Cover + Scene",
        "style": {
            "label": true,
            "stroke": "#7c3aed",
            "fill": "#f3e8ff",
            "fill-opacity": "0.5"
        },
        "nodes": [
            "mqtt_in_all",
            "full_processor",
            "debug_full_command",
            "tcp_full_output",
            "feedback_full_processor",
            "debug_full_feedback",
            "mqtt_out_full_state",
            "debug_full_mqtt_out",
            "comment_full",
            "inject_test_relay",
            "inject_test_cover",
            "inject_test_scene",
            "inject_clear_full_cache",
            "clear_full_cache",
            "inject_show_full_cache",
            "show_full_cache"
        ],
        "x": 14,
        "y": 2719,
        "w": 1172,
        "h": 562
    },
    {
        "id": "mqtt_in_all",
        "type": "mqtt in",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "MQTT Ë®ÇÈñ±ÊâÄÊúâÊéßÂà∂",
        "topic": "homeassistant/+/+/+/+/set/#",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 2820,
        "wires": [
            [
                "full_processor"
            ]
        ]
    },
    {
        "id": "inject_test_relay",
        "type": "inject",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Ê∏¨Ë©¶ Relay ON",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "homeassistant/light/relay/12/1/set",
        "payload": "ON",
        "payloadType": "str",
        "x": 120,
        "y": 2860,
        "wires": [
            [
                "full_processor"
            ]
        ]
    },
    {
        "id": "inject_test_cover",
        "type": "inject",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Ê∏¨Ë©¶ Cover ÈñãÂïü 1_2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "homeassistant/cover/general/12/set",
        "payload": "1_2/3",
        "payloadType": "str",
        "x": 140,
        "y": 2900,
        "wires": [
            [
                "full_processor"
            ]
        ]
    },
    {
        "id": "inject_test_scene",
        "type": "inject",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Ê∏¨Ë©¶ Scene ON",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "homeassistant/light/scene/single/12-1--12-2/set",
        "payload": "ON",
        "payloadType": "str",
        "x": 120,
        "y": 2940,
        "wires": [
            [
                "full_processor"
            ]
        ]
    },
    {
        "id": "full_processor",
        "type": "function",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "ÂÆåÊï¥ËôïÁêÜÂô® (All Devices)",
        "func": "// ÂÆåÊï¥ÁâàËôïÁêÜÂô®ÔºöÊîØÊè¥ Single/Dual/Relay ÁáàÂÖâ„ÄÅCover„ÄÅScene\n\nconst DEFAULT_BRIGHTNESS = 100;\nconst DEFAULT_COLORTEMP = 250;\nconst MIN_MIRED = 167;\nconst MAX_MIRED = 333;\nconst BRIGHTNESS_TIME = 0x05;\nconst CHANNEL_REGISTER_MAP = {\n    \"1\": 0x082A,\n    \"2\": 0x082B,\n    \"3\": 0x082C,\n    \"4\": 0x082D,\n    \"a\": [0x082A, 0x082B],\n    \"b\": [0x082C, 0x082D]\n};\nconst CHANNEL_COIL_MAP = {\n    \"1\": 0x0000,\n    \"2\": 0x0001,\n    \"3\": 0x0002,\n    \"4\": 0x0003\n};\n\nfunction generalCommandBuild(frame) {\n    function crc16(buf) {\n        let crc = 0xFFFF;\n        for (const b of buf) {\n            crc ^= b;\n            for (let i = 0; i < 8; i++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        return crc;\n    }\n    const crc = crc16(frame);\n    return Buffer.concat([frame, Buffer.from([crc & 0xFF, (crc >> 8) & 0xFF])]);\n}\n\nfunction clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\n\nfunction buildCommand(moduleId, reg, value, speed = 0x05) {\n    const hi = (reg >> 8) & 0xFF;\n    const lo = reg & 0xFF;\n    const cmd = Buffer.from([moduleId, 0x06, hi, lo, speed, value]);\n    return generalCommandBuild(cmd);\n}\n\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light, cover\nconst subType = parts[2];        // single, dual, relay, scene, general\nconst moduleId = parseInt(parts[3]);\nconst channel = parts[4];\n\nnode.warn(`=== Êî∂Âà∞Ë®äÊÅØ ===`);\nnode.warn(`Topic: ${msg.topic}`);\nnode.warn(`Payload: ${msg.payload}`);\nnode.warn(`Device: ${deviceType}, SubType: ${subType}, Module: ${moduleId}, Channel: ${channel}`);\n\nlet modbusMessages = [];\nlet mqttMessages = [];\n\n// ========== LIGHT DEVICE ==========\nif (deviceType === \"light\") {\n    const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n\n    // ËôïÁêÜ set/brightness Âíå set/colortemp\n    if (parts.length >= 7 && parts[5] === \"set\") {\n        const attribute = parts[6];\n        const key = `${subType}_${moduleId}_${channel}_${attribute}`;\n        const val = Number(msg.payload);\n\n        if (!isNaN(val)) {\n            flow.set(key, val);\n            node.warn(`ÂÑ≤Â≠ò ${key} = ${val}`);\n        }\n\n        if (attribute === \"brightness\" || attribute === \"colortemp\") {\n            const stateKey = `${subType}_${moduleId}_${channel}_state`;\n            let state;\n            if (attribute === \"brightness\" && val > 0) {\n                state = \"ON\";\n                flow.set(stateKey, \"ON\");\n            } else if (attribute === \"brightness\" && val === 0) {\n                state = \"OFF\";\n                flow.set(stateKey, \"OFF\");\n            } else {\n                state = flow.get(stateKey) || \"ON\";\n            }\n            msg.topic = `homeassistant/light/${subType}/${moduleId}/${channel}/set`;\n            msg.payload = state;\n        } else {\n            return null;\n        }\n    }\n\n    // ===== RELAY =====\n    if (subType === \"relay\") {\n        const addr = CHANNEL_COIL_MAP[channel];\n        if (addr === undefined) {\n            node.warn(`Êâæ‰∏çÂà∞ Relay ÈÄöÈÅì ${channel}`);\n            return null;\n        }\n\n        const state = (msg.payload === \"ON\") ? \"ON\" : \"OFF\";\n        const valHi = (msg.payload === \"ON\") ? 0xFF : 0x00;\n        const valLo = 0x00;\n        const hi = (addr >> 8) & 0xFF;\n        const lo = addr & 0xFF;\n        const frame = Buffer.from([moduleId, 0x05, hi, lo, valHi, valLo]);\n        const cmd = generalCommandBuild(frame);\n\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        node.warn(`=== Modbus Êåá‰ª§ (Relay) ===`);\n        node.warn(`Coil Âú∞ÂùÄ: 0x${addr.toString(16).padStart(4, '0')}`);\n        node.warn(`Êåá‰ª§: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `Relay ${moduleId}-${channel}: ${state}`\n        });\n    }\n\n    // ===== SINGLE =====\n    else if (subType === \"single\") {\n        const reg = CHANNEL_REGISTER_MAP[channel];\n        if (!reg) {\n            node.warn(`Êâæ‰∏çÂà∞ÈÄöÈÅì ${channel} ÁöÑÂØÑÂ≠òÂô®`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const speed = (state === \"OFF\") ? 0x00 : BRIGHTNESS_TIME;\n        const cmd = buildCommand(moduleId, reg, brValue, speed);\n\n        node.warn(`=== Modbus Êåá‰ª§ (Single) ===`);\n        node.warn(`Êåá‰ª§: ${cmd.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmd, subType, moduleId, channel, state, brightness });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}%`\n        });\n    }\n\n    // ===== DUAL =====\n    else if (subType === \"dual\") {\n        const regs = CHANNEL_REGISTER_MAP[channel];\n        if (!regs) {\n            node.warn(`Êâæ‰∏çÂà∞ÈÄöÈÅì ${channel} ÁöÑÂØÑÂ≠òÂô®`);\n            return null;\n        }\n\n        let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        const stateKey = `${subType}_${moduleId}_${channel}_state`;\n        flow.set(stateKey, state);\n\n        let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n        if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n        brightness = clamp(Math.round(brightness), 0, 100);\n\n        let colortemp = flow.get(`${subType}_${moduleId}_${channel}_colortemp`);\n        if (typeof colortemp !== \"number\") colortemp = DEFAULT_COLORTEMP;\n        colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n        const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\n        const brValue = (state === \"ON\") ? brightness : 0;\n        const cmdBrightness = buildCommand(moduleId, regs[0], brValue);\n        const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n        node.warn(`=== Modbus Êåá‰ª§ (Dual) ===`);\n        node.warn(`‰∫ÆÂ∫¶: ${cmdBrightness.toString('hex')}`);\n        node.warn(`Ëâ≤Ê∫´: ${cmdColortemp.toString('hex')}`);\n\n        modbusMessages.push({ payload: cmdBrightness, subType, moduleId, channel, state, brightness, colortemp });\n        modbusMessages.push({ payload: cmdColortemp, subType, moduleId, channel, state, brightness, colortemp });\n        mqttMessages.push({ topic: `${baseTopic}/state`, payload: state });\n        if (state === \"ON\") {\n            mqttMessages.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n            mqttMessages.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n        }\n\n        node.status({\n            fill: state === \"ON\" ? \"green\" : \"grey\",\n            shape: \"dot\",\n            text: `${moduleId}-${channel}: ${state} ${brightness}% ${colortemp}K`\n        });\n    }\n\n    // ===== SCENE =====\n    else if (subType === \"scene\") {\n        const sceneType = parts[3];  // single, dual\n        const lights = parts[4].split(\"--\");  // 12-1--12-2\n        const state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n        \n        const groupBrightnessKey = `${subType}_${sceneType}_${parts[4]}_brightness`;\n        const groupColortempKey = `${subType}_${sceneType}_${parts[4]}_colortemp`;\n        const groupBrightness = flow.get(groupBrightnessKey);\n        const groupColortemp = flow.get(groupColortempKey);\n\n        node.warn(`=== Scene ÊéßÂà∂ ===`);\n        node.warn(`Â†¥ÊôØÈ°ûÂûã: ${sceneType}`);\n        node.warn(`ÁáàÂÖâÂàóË°®: ${lights.join(\", \")}`);\n        node.warn(`ÁãÄÊÖã: ${state}`);\n\n        // ÁôºÈÄÅÊåá‰ª§Âà∞ÊØèÂÄãÁáàÂÖâ\n        for (let light of lights) {\n            const [lightId, lightChannel] = light.split(\"-\");\n            const lightTopic = `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/set`;\n            \n            // Êõ¥Êñ∞ÂÄãÂà•ÁáàÂÖâÁöÑÂø´Âèñ\n            const stateKey = `${sceneType}_${lightId}_${lightChannel}_state`;\n            flow.set(stateKey, state);\n            if (state === \"ON\" && groupBrightness !== undefined) {\n                const brightnessKey = `${sceneType}_${lightId}_${lightChannel}_brightness`;\n                flow.set(brightnessKey, groupBrightness);\n            }\n            if (state === \"ON\" && groupColortemp !== undefined && sceneType === \"dual\") {\n                const colortempKey = `${sceneType}_${lightId}_${lightChannel}_colortemp`;\n                flow.set(colortempKey, groupColortemp);\n            }\n            \n            // ÁôºÈÄÅ MQTT Âà∞ÂÄãÂà•ÁáàÂÖâ\n            mqttMessages.push({ topic: lightTopic, payload: state });\n            mqttMessages.push({ topic: `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/state`, payload: state });\n            \n            if (state === \"ON\" && groupBrightness !== undefined) {\n                mqttMessages.push({ topic: `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/brightness`, payload: groupBrightness });\n            }\n            if (state === \"ON\" && groupColortemp !== undefined && sceneType === \"dual\") {\n                mqttMessages.push({ topic: `homeassistant/light/${sceneType}/${lightId}/${lightChannel}/colortemp`, payload: groupColortemp });\n            }\n        }\n\n        // Êõ¥Êñ∞Â†¥ÊôØÊú¨Ë∫´ÁöÑÁãÄÊÖã\n        mqttMessages.push({ topic: `homeassistant/light/scene/${sceneType}/${parts[4]}/state`, payload: state });\n\n        node.status({\n            fill: state === \"ON\" ? \"yellow\" : \"grey\",\n            shape: \"ring\",\n            text: `Scene: ${lights.length} Ááà ${state}`\n        });\n    }\n}\n\n// ========== COVER DEVICE ==========\nelse if (deviceType === \"cover\") {\n    // Ê†ºÂºè: homeassistant/cover/general/12/set\n    // payload: \"1_2/3\" Ë°®Á§∫ÈñãÂïü relay 1 Âíå 2ÔºåÈóúÈñâ relay 3\n    \n    const relays = msg.payload.split(\"/\");\n    const on_relays = relays[0] ? relays[0].split(\"_\").map(Number) : [];\n    const off_relays = (relays[1] && relays[1].length > 0) ? relays[1].split(\"_\").map(Number) : [];\n\n    let output = 0x00;\n    for (let relay of on_relays) {\n        output |= (1 << (relay - 1));\n    }\n    for (let relay of off_relays) {\n        output &= ~(1 << (relay - 1));\n    }\n\n    const frame = Buffer.from([moduleId, 0x06, 0x01, 0x9b, 0x10, output]);\n    const cmd = generalCommandBuild(frame);\n\n    node.warn(`=== Modbus Êåá‰ª§ (Cover) ===`);\n    node.warn(`ÈñãÂïü Relay: ${on_relays.join(\", \")}`);\n    node.warn(`ÈóúÈñâ Relay: ${off_relays.join(\", \")}`);\n    node.warn(`Bit Mask: 0b${output.toString(2).padStart(8, '0')} (0x${output.toString(16).padStart(2, '0')})`);\n    node.warn(`Êåá‰ª§: ${cmd.toString('hex')}`);\n\n    modbusMessages.push({ payload: cmd, deviceType, moduleId, on_relays, off_relays });\n\n    node.status({\n        fill: \"blue\",\n        shape: \"dot\",\n        text: `Cover: ON[${on_relays}] OFF[${off_relays}]`\n    });\n}\n\nelse {\n    node.warn(`‰∏çÊîØÊè¥ÁöÑË®≠ÂÇôÈ°ûÂûã: ${deviceType}`);\n    return null;\n}\n\n// ËøîÂõû: [Modbus Êåá‰ª§, MQTT ÁãÄÊÖã]\nreturn [modbusMessages, mqttMessages];",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "node.warn(\"=== ÂàùÂßãÂåñÂÆåÊï¥Ê∏¨Ë©¶Á≥ªÁµ± ===\");",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 2880,
        "wires": [
            [
                "debug_full_command",
                "tcp_full_output"
            ],
            [
                "debug_full_mqtt_out",
                "mqtt_out_full_state"
            ]
        ]
    },
    {
        "id": "debug_full_command",
        "type": "debug",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Modbus Êåá‰ª§",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 700,
        "y": 2860,
        "wires": []
    },
    {
        "id": "tcp_full_output",
        "type": "tcp request",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "TCP ‚Üí Modbus",
        "server": "192.168.98.208",
        "port": "502",
        "out": "time",
        "ret": "buffer",
        "splitc": "0",
        "newline": "",
        "trim": false,
        "tls": "",
        "x": 700,
        "y": 2900,
        "wires": [
            [
                "feedback_full_processor"
            ]
        ]
    },
    {
        "id": "feedback_full_processor",
        "type": "function",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Feedback ËôïÁêÜÂô®",
        "func": "// Feedback ËôïÁêÜÂô® (Ëàá‰πãÂâçÁõ∏Âêå)\n\nfunction verifyCRC(buf) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buf.length - 2; i++) {\n        crc ^= buf[i];\n        for (let j = 0; j < 8; j++) {\n            crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n        }\n    }\n    const lo = crc & 0xFF;\n    const hi = (crc >> 8) & 0xFF;\n    return lo === buf[buf.length - 2] && hi === buf[buf.length - 1];\n}\n\nconst buf = msg.payload;\n\nif (!Buffer.isBuffer(buf) || buf.length < 8) {\n    node.warn(\"ÂõûÊáâÊ†ºÂºèÈåØË™§\");\n    return null;\n}\n\nif (!verifyCRC(buf)) {\n    node.warn(\"CRC È©óË≠âÂ§±Êïó\");\n    return null;\n}\n\nconst moduleId = buf[0];\nconst funcCode = buf[1];\nconst regHi = buf[2];\nconst regLo = buf[3];\nconst valueHi = buf[4];\nconst valueLo = buf[5];\n\nconst register = (regHi << 8) | regLo;\nconst value = (valueHi << 8) | valueLo;\n\nnode.warn(`=== Modbus ÂõûÊáâ ===`);\nnode.warn(`Ê®°ÁµÑID: ${moduleId}`);\nnode.warn(`ÂäüËÉΩÁ¢º: 0x${funcCode.toString(16).padStart(2, '0')}`);\nnode.warn(`ÂØÑÂ≠òÂô®: 0x${register.toString(16).padStart(4, '0')}`);\nnode.warn(`Êï∏ÂÄº: ${value} (${valueLo})`);\n\nnode.status({\n    fill: \"blue\",\n    shape: \"ring\",\n    text: `ÂõûÊáâ: Module ${moduleId}, Reg 0x${register.toString(16)}, Val ${valueLo}`\n});\n\nmsg.feedback = {\n    moduleId,\n    register,\n    value: valueLo,\n    raw: buf.toString('hex')\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 2900,
        "wires": [
            [
                "debug_full_feedback"
            ]
        ]
    },
    {
        "id": "debug_full_feedback",
        "type": "debug",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Feedback Ëß£Êûê",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "feedback",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1130,
        "y": 2900,
        "wires": []
    },
    {
        "id": "mqtt_out_full_state",
        "type": "mqtt out",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "MQTT ÁôºÂ∏ÉÁãÄÊÖã",
        "topic": "",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 940,
        "y": 2940,
        "wires": []
    },
    {
        "id": "debug_full_mqtt_out",
        "type": "debug",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "MQTT ÁãÄÊÖãÂõûÂ†±",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 2980,
        "wires": []
    },
    {
        "id": "comment_full",
        "type": "comment",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "ÂÆåÊï¥Ê∏¨Ë©¶ÔºöÊâÄÊúâË®≠ÂÇôÈ°ûÂûã (Light: Single/Dual/Relay, Cover, Scene)",
        "info": "ÊîØÊè¥ÁöÑË®≠ÂÇôÈ°ûÂûãÔºö\n\nüîÜ **Light - Single**\n   - Topic: homeassistant/light/single/{module}/{channel}/set\n   - ÂñÆËâ≤ÁáàÊéßÂà∂ (‰∫ÆÂ∫¶)\n\nüîÜ **Light - Dual**\n   - Topic: homeassistant/light/dual/{module}/{channel}/set\n   - ÈõôËâ≤Ê∫´ÁáàÊéßÂà∂ (‰∫ÆÂ∫¶ + Ëâ≤Ê∫´)\n\nüîÜ **Light - Relay**\n   - Topic: homeassistant/light/relay/{module}/{channel}/set\n   - ÁπºÈõªÂô®ÈñãÈóú (ON/OFF)\n\nüé¨ **Light - Scene**\n   - Topic: homeassistant/light/scene/{type}/{lights}/set\n   - Â†¥ÊôØÊéßÂà∂ (ÊâπÊ¨°ÊéßÂà∂Â§öÂÄãÁáà)\n   - ‰æãÂ¶Ç: scene/single/12-1--12-2/set\n\nü™ü **Cover**\n   - Topic: homeassistant/cover/general/{module}/set\n   - Payload: \"1_2/3\" (ÈñãÂïü 1,2 ÈóúÈñâ 3)\n   - Á™óÁ∞æÊéßÂà∂ (Bit Mask)\n\n‚úÖ ÂÆåÊï¥ÊµÅÁ®ãÔºö\n   MQTT In ‚Üí ËôïÁêÜÂô® ‚Üí Modbus ‚Üí Feedback ‚Üí MQTT Out\n\n‚ùå ÁÑ° Queue Á≥ªÁµ± (Áõ¥Êé•ÁôºÈÄÅ)",
        "x": 280,
        "y": 2780,
        "wires": []
    },
    {
        "id": "inject_clear_full_cache",
        "type": "inject",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Ê∏ÖÈô§Âø´Âèñ",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 90,
        "y": 3160,
        "wires": [
            [
                "clear_full_cache"
            ]
        ]
    },
    {
        "id": "clear_full_cache",
        "type": "function",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "Ê∏ÖÈô§ÊâÄÊúâÂø´Âèñ",
        "func": "const keys = flow.keys();\nlet count = 0;\nkeys.forEach(k => {\n    if (k.startsWith('single_') || k.startsWith('dual_') || k.startsWith('relay_') || k.startsWith('scene_')) {\n        flow.set(k, undefined);\n        node.warn(`Ê∏ÖÈô§: ${k}`);\n        count++;\n    }\n});\nnode.warn(`=== Â∑≤Ê∏ÖÈô§ ${count} Á≠ÜÂø´Âèñ ===`);\nnode.status({\n    fill: \"blue\",\n    shape: \"ring\",\n    text: `Â∑≤Ê∏ÖÈô§ ${count} Á≠Ü`\n});\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 3160,
        "wires": [
            []
        ]
    },
    {
        "id": "inject_show_full_cache",
        "type": "inject",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "È°ØÁ§∫Âø´Âèñ",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 90,
        "y": 3200,
        "wires": [
            [
                "show_full_cache"
            ]
        ]
    },
    {
        "id": "show_full_cache",
        "type": "function",
        "z": "e345e003a053a625",
        "g": "test_group_full",
        "name": "È°ØÁ§∫ÊâÄÊúâÂø´Âèñ",
        "func": "node.warn(\"=== Flow Context ÂÖßÂÆπ ===\");\nconst keys = flow.keys();\nconst filtered = keys.filter(k => \n    k.startsWith('single_') || \n    k.startsWith('dual_') || \n    k.startsWith('relay_') || \n    k.startsWith('scene_')\n);\n\nif (filtered.length === 0) {\n    node.warn(\"ÁõÆÂâçÊ≤íÊúâ‰ªª‰ΩïÂø´ÂèñË≥áÊñô\");\n} else {\n    // ÂàÜÈ°ûÈ°ØÁ§∫\n    const groups = {\n        single: [],\n        dual: [],\n        relay: [],\n        scene: []\n    };\n    \n    filtered.forEach(k => {\n        const value = flow.get(k);\n        if (k.startsWith('single_')) groups.single.push(`${k}: ${value}`);\n        else if (k.startsWith('dual_')) groups.dual.push(`${k}: ${value}`);\n        else if (k.startsWith('relay_')) groups.relay.push(`${k}: ${value}`);\n        else if (k.startsWith('scene_')) groups.scene.push(`${k}: ${value}`);\n    });\n    \n    if (groups.single.length > 0) {\n        node.warn(\"--- Single ---\");\n        groups.single.forEach(s => node.warn(s));\n    }\n    if (groups.dual.length > 0) {\n        node.warn(\"--- Dual ---\");\n        groups.dual.forEach(s => node.warn(s));\n    }\n    if (groups.relay.length > 0) {\n        node.warn(\"--- Relay ---\");\n        groups.relay.forEach(s => node.warn(s));\n    }\n    if (groups.scene.length > 0) {\n        node.warn(\"--- Scene ---\");\n        groups.scene.forEach(s => node.warn(s));\n    }\n    \n    node.warn(`=== ÂÖ± ${filtered.length} Á≠ÜÂø´Âèñ ===`);\n}\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 3200,
        "wires": [
            []
        ]
    }
]
