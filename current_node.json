[{"id":"e345e003a053a625","type":"tab","label":"æ£®é–£","disabled":false,"info":"","env":[]},{"id":"a3d04f6b50124da1","type":"group","z":"e345e003a053a625","name":"æš«æ™‚ä¸ç”¨","style":{"label":true},"nodes":["fac6f44a2b75043c","1197dea47cf89610","fbccf4ec4266d004","a7bca8c4f937337b","dd7dd82faa9524c6","f0144905a6927f4c","e935e9a7f7aa1c5d","ffdf224cf8ee326c","9d2ab15d83556dac","97dc1961a883fa50","cb5abb1aa085ed19","d9cc6387e41666fa","21df20dc6a9c5073","7366103d25a6eee6","d1b6f9c7dea14b84","e2fe8ede81922e66"],"x":734,"y":19,"w":912,"h":362},{"id":"d634068781bfec19","type":"group","z":"e345e003a053a625","name":"æŒ‡ä»¤è™•ç†","style":{"label":true},"nodes":["e830bdf110f44fe3","d75738502c9029fc","bdbab8f3e4311de9","aa8b69945dde9cf2","b31aec75ff90aabb","ae93e63cc2e21005","3da99baa8d84b477","58dd0fac1c7aa46a","4264d0e29a86a022","856c5ad89dfdd04b","cfa9ec9556dfb6d8","847c6ac1944eac57","895ee05a057f6773"],"x":8,"y":393,"w":1324,"h":901.5},{"id":"856c5ad89dfdd04b","type":"group","z":"e345e003a053a625","g":"d634068781bfec19","name":"è£ç½®æŒ‰éˆ•æ³¨å…¥","style":{"label":true,"stroke":"#ffC000","fill":"#ffffbf","fill-opacity":"0.35","color":"#000000"},"nodes":["961c7b6b857e142e","2e98dadaf8e45671","82ceaf2e62b7218a"],"x":34,"y":419,"w":672,"h":82},{"id":"b31aec75ff90aabb","type":"group","z":"e345e003a053a625","g":"d634068781bfec19","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["ead5b3b5565422b1","51cb52c331f4570a","aab64db9eb568cfc","68fad83bf4565fb9","fb70cf11b152edc9","5d523aebb9e9f50b","63117ac4cada3093","97bb94752a7a0fdc"],"x":154,"y":1059,"w":652,"h":209.5},{"id":"3da99baa8d84b477","type":"group","z":"e345e003a053a625","g":"d634068781bfec19","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["aac8603f0be1c33d","468d5430865a74c3","7fd49bd692bbc83d","637cf20b08068b3c","3e3e53d0e771b500","81fab6fcd799f651","5ce9b5afce831e15"],"x":34,"y":539,"w":612,"h":282},{"id":"58dd0fac1c7aa46a","type":"group","z":"e345e003a053a625","g":"d634068781bfec19","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["23cd4e4e4b8df214","69d4aa186ac69ce0","1a53e5aab7fdcab3"],"x":714,"y":559,"w":412,"h":82},{"id":"4264d0e29a86a022","type":"group","z":"e345e003a053a625","g":"d634068781bfec19","style":{"stroke":"#999999","stroke-opacity":"1","fill":"none","fill-opacity":"1","label":true,"label-position":"nw","color":"#a4a4a4"},"nodes":["44bc924468f631dd","d9123b98976ecc27","01056b80c8745ee3","3ea0e6d267edaf7f","8d0f6ac2e83aee8d","885f68f7485a99c1","8134bccef9447b6f"],"x":714,"y":779,"w":592,"h":202},{"id":"fb70cf11b152edc9","type":"junction","z":"e345e003a053a625","g":"b31aec75ff90aabb","x":420,"y":1140,"wires":[["51cb52c331f4570a","aab64db9eb568cfc","97bb94752a7a0fdc"]]},{"id":"8d0f6ac2e83aee8d","type":"junction","z":"e345e003a053a625","g":"4264d0e29a86a022","x":740,"y":880,"wires":[["44bc924468f631dd","d9123b98976ecc27","01056b80c8745ee3","3ea0e6d267edaf7f"]]},{"id":"885f68f7485a99c1","type":"junction","z":"e345e003a053a625","g":"4264d0e29a86a022","x":1100,"y":880,"wires":[["8134bccef9447b6f"]]},{"id":"7366103d25a6eee6","type":"inject","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"åŠ å…¥ Feedback Sensors","props":[{"p":"action","v":"add","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":880,"y":300,"wires":[["21df20dc6a9c5073"]]},{"id":"d1b6f9c7dea14b84","type":"inject","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"æ¸…é™¤ Feedback Sensors","props":[{"p":"action","v":"clear","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":880,"y":340,"wires":[["21df20dc6a9c5073"]]},{"id":"21df20dc6a9c5073","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"è™•ç† Feedback Sensors","func":"// Feedback sensors æ¸…å–®\nlet sensors = [\n    { id: \"fb_single_11_1_brightness\"},\n];\n\nlet msgs = sensors.map(sensor => {\n    let payload;\n\n    if (msg.action === \"clear\") {\n        // æ¸…é™¤ï¼šç©º payload\n        payload = \"\";\n    } else {\n        // åŠ å…¥ï¼šå»ºç«‹ JSON config\n        let parts = sensor.id.split(\"_\"); // [fb, dual, 11, a, brightness]\n        let kind  = parts[4];\n        let stateTopic = `homeassistant/light/${parts[1]}/${parts[2]}/${parts[3]}/set/${parts[4]}`;\n\n        let basePayload = {\n            name: sensor.id,\n            unique_id: sensor.id,\n            object_id: sensor.id,\n            state_topic: stateTopic,\n            state_class: \"measurement\"\n        };\n\n        if (kind === \"brightness\") {\n            basePayload.unit_of_measurement = \"level\"; // æˆ– \"%\" è¦–ä½ çš„å›å ±å–®ä½\n            basePayload.icon = \"mdi:brightness-6\";\n        } else if (kind === \"colortemp\") {\n            basePayload.unit_of_measurement = \"mireds\";\n            basePayload.icon = \"mdi:thermometer\";\n        }\n\n        payload = JSON.stringify(basePayload);\n    }\n\n    return {\n        topic: `homeassistant/sensor/${sensor.id}/config`,\n        payload,\n        retain: true\n    };\n});\n\nreturn [msgs];","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1110,"y":320,"wires":[["e2fe8ede81922e66"]]},{"id":"e2fe8ede81922e66","type":"mqtt out","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"ç™¼é€åˆ° MQTT Broker","topic":"","qos":"","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"751ec40a6956d4f9","x":1340,"y":320,"wires":[]},{"id":"fac6f44a2b75043c","type":"inject","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"Reset","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":1150,"y":60,"wires":[["fbccf4ec4266d004"]]},{"id":"1197dea47cf89610","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"åŠ å…¥ä½‡åˆ—","func":"let queue = global.get(\"commandsQueue\") || [];\nlet cmd = msg.payload;\n\n// åƒ…æ¥å—å­—ä¸²æˆ– Bufferï¼Œå…¶ä»–ç›´æ¥å¿½ç•¥\nif (typeof cmd !== \"string\" && !Buffer.isBuffer(cmd)) {\n    node.warn(\"payload é¡å‹ä¸æ”¯æ´ï¼Œå¿…é ˆæ˜¯ hex å­—ä¸²æˆ– Buffer\");\n    return null;\n}\n\n// è‹¥æ˜¯å­—ä¸²ï¼Œè½‰ Buffer\nif (typeof cmd === \"string\") {\n    cmd = Buffer.from(cmd, \"hex\");\n}\n\n// ä½‡åˆ—ä¸Šé™ 100 ç­†ï¼Œè¶…éå°±ä¸Ÿæ‰æœ€èˆŠä¸€ç­†\nconst MAX_QUEUE = 100;\nif (queue.length >= MAX_QUEUE) {\n    queue.shift();\n}\n\nqueue.push(cmd);\nglobal.set(\"commandsQueue\", queue);\n\n// è‹¥ç›®å‰æ²’æœ‰åœ¨ç­‰å›è¦† â†’ è§¸ç™¼ç™¼é€æµç¨‹\nif (!global.get(\"waitingReply\")) {\n    return { payload: null };\n}\nreturn null;\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1320,"y":160,"wires":[["d9cc6387e41666fa"]]},{"id":"d9cc6387e41666fa","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"ç™¼é€æµç¨‹ + timeout","func":"const TIMEOUT_MS = 800; // å»ºè­°å…ˆ 600~1200ï¼Œä¾å¯¦æ¸¬èª¿\nconst MAX_RETRY  = 2;   // æœ€å¤§é‡é€æ¬¡æ•¸ï¼›ç¸½ç™¼é€ = 1 + MAX_RETRY\n\nconst busy = !!global.get(\"waitingReply\");\nlet queue = global.get(\"commandsQueue\");\nif (!Array.isArray(queue)) { queue = []; global.set(\"commandsQueue\", queue); }\n\nif (busy || queue.length === 0) return [null, null];\n\n// å– FIFO ä¸¦æ¨™è¨˜å¿™ç¢Œ\nconst cmd = queue.shift();\nglobal.set(\"commandsQueue\", queue);\nglobal.set(\"waitingReply\", true);\n\n// æº–å‚™è¨Šæ¯ï¼ˆå«é‡é€è¨ˆæ•¸ï¼‰\nlet outMsg = { payload: cmd, retry: 0 };\nflow.set(\"currentCmd\", outMsg);\n\n// é€¾æ™‚â†’é‡é€ / è¶…é™â†’è§£é–ä¸‹ä¸€ç­†\nfunction armTimeout(cur) {\n  const timer = setTimeout(() => {\n    cur.retry += 1;\n    if (cur.retry <= MAX_RETRY) {\n      flow.set(\"currentCmd\", cur);\n      node.send([cur, null]);      // é‡é€åŒä¸€ç­†åˆ° TCP\n      armTimeout(cur);             // å†æ›ä¸‹ä¸€é¡† timeout\n    } else {\n      global.set(\"waitingReply\", false);\n      flow.set(\"currentCmd\", null);\n      flow.set(\"currentTimeout\", null);\n      node.send([null, { payload: { trigger: true, reason: \"timeout\" } }]); // æ¨é€²ä¸‹ä¸€ç­†\n    }\n  }, TIMEOUT_MS);\n  flow.set(\"currentTimeout\", timer);\n}\n\n// å…ˆæ› timeout å†é€ç¬¬ä¸€æ¬¡\narmTimeout(outMsg);\nreturn [outMsg, null];\n","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1530,"y":160,"wires":[[],[]],"info":"ã€åŠŸèƒ½èªªæ˜ã€‘\næ­¤ç¯€é»è² è²¬ï¼š\n1. å¾ commandsQueue ä½‡åˆ—ä¸­å–å‡ºä¸‹ä¸€ç­†æŒ‡ä»¤\n2. ç™¼é€è‡³ TCP ç¯€é»\n3. å•Ÿå‹• Retry æ©Ÿåˆ¶ï¼ˆé è¨­æœ€å¤šé‡é€ 2 æ¬¡ï¼‰\n4. è‹¥æˆåŠŸå›æ‡‰ â†’ ç”± handle_reply è§£é–ä½‡åˆ—\n5. è‹¥å¤±æ•—è¶…æ™‚ â†’ è‡ªå‹•è§£é–ä¸¦è§¸ç™¼ä¸‹ä¸€ç­†é€å‡º\n"},{"id":"fbccf4ec4266d004","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"é‡ç½®ä½‡åˆ—","func":"// ä¸€éµæ¸…é™¤ + è§£é– + å–šé†’ï¼ˆé›™è¼¸å‡ºï¼‰\n// out[0] â†’ ç‹€æ…‹å›å ±ï¼ˆçµ¦ Debugï¼‰\n// out[1] â†’ {payload:null} å–šé†’ã€Œç™¼é€æµç¨‹ + timeoutã€\n\n// 1) åœæ‰é€¾æ™‚è¨ˆæ™‚å™¨ï¼ˆé¿å…å¹½éˆå›å‘¼ï¼‰\nconst t = flow.get(\"currentTimeout\");\nif (t) { clearTimeout(t); }\n\n// 2) æ¸…é™¤åœ¨é€”ç‹€æ…‹\nflow.set(\"currentTimeout\", null);\nflow.set(\"currentCmd\", null);\nglobal.set(\"waitingReply\", false);\n\n// 3) æ¸…ç©ºä½‡åˆ—\nglobal.set(\"commandsQueue\", []);\n\n// 4) æº–å‚™ç‹€æ…‹å›å ±ï¼ˆæ¸…é™¤å¾Œçš„å³æ™‚ç‹€æ…‹ï¼‰\nconst status = {\n  busy: global.get(\"waitingReply\") || false,\n  queue: (global.get(\"commandsQueue\") || []).length,\n  currentCmd: flow.get(\"currentCmd\") || null\n};\n\n// 5) å›å‚³ï¼šç¬¬ä¸€è·¯çµ¦ Debugã€ç¬¬äºŒè·¯å–šé†’ç™¼é€æµç¨‹\nreturn [\n  { payload: status },   // out[0] â†’ Debug\n  { payload: null }      // out[1] â†’ ç™¼é€æµç¨‹ + timeout\n];\n","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1320,"y":120,"wires":[["cb5abb1aa085ed19"],["d9cc6387e41666fa"]]},{"id":"cb5abb1aa085ed19","type":"debug","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"çµæœ","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1470,"y":120,"wires":[]},{"id":"a7bca8c4f937337b","type":"inject","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"","props":[],"repeat":"5","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":830,"y":180,"wires":[["dd7dd82faa9524c6"]]},{"id":"dd7dd82faa9524c6","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"è¨­å‚™æ¸…å–®","func":"// è¨­å®šè¨­å‚™æ¸…å–®\nvar devices = context.get('devices') || [14,15,16,17]; // é»˜èªè¨­å‚™æ¸…å–®\n// ç‚ºæ¯å€‹è¨­å‚™ç”Ÿæˆä¸€æ¢æ¶ˆæ¯\nvar msgs = devices.map(deviceID => {\n    return {\n        deviceID: deviceID // å°‡è¨­å‚™ ID æ·»åŠ åˆ°æ¶ˆæ¯ä¸­\n    };\n});\n\n// è¿”å›æ‰€æœ‰æ¶ˆæ¯\nreturn [msgs];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":980,"y":180,"wires":[["f0144905a6927f4c"]]},{"id":"f0144905a6927f4c","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"è©¢å•åœ°å€(P404)","func":"// ç²å–ç•¶å‰è¨­å‚™ ID\nvar deviceID = msg.deviceID;\n\n// è¨­å®šåƒæ•¸\nvar functionCode = 0x03;           // åŠŸèƒ½ç¢¼ï¼šè®€å–ä¿æŒæš«å­˜å™¨(Holding Register)\nvar startAddress = 2090;            // èµ·å§‹åœ°å€\nvar quantity = 4;                  // è®€å–æ•¸é‡\n\n// å°‡èµ·å§‹åœ°å€å’Œæ•¸é‡è½‰æ›ç‚ºå…©å€‹å­—ç¯€\nvar startAddressHigh = (startAddress >> 8) & 0xFF; // é«˜ä½\nvar startAddressLow = startAddress & 0xFF;        // ä½ä½\nvar quantityHigh = (quantity >> 8) & 0xFF;        // é«˜ä½\nvar quantityLow = quantity & 0xFF;               // ä½ä½\n\n// çµ„è£æŒ‡ä»¤\nvar message = [\n    deviceID,            // è¨­å‚™åœ°å€\n    functionCode,        // åŠŸèƒ½ç¢¼\n    startAddressHigh,    // èµ·å§‹åœ°å€é«˜ä½\n    startAddressLow,     // èµ·å§‹åœ°å€ä½ä½\n    quantityHigh,        // æ•¸é‡é«˜ä½\n    quantityLow          // æ•¸é‡ä½ä½\n];\n\n// è¨ˆç®— CRC æ ¡é©—\nvar crc = calculateCRC(message);\nmessage.push(crc[0]); // CRC ä½ä½\nmessage.push(crc[1]); // CRC é«˜ä½\n\n// å°‡æŒ‡ä»¤å­˜å…¥ msg.payload\nmsg.payload = Buffer.from(message);\nreturn msg;\n\n// CRC è¨ˆç®—å‡½å¼\nfunction calculateCRC(data) {\n    var crc = 0xFFFF;\n    for (var i = 0; i < data.length; i++) {\n        crc ^= data[i];\n        for (var j = 0; j < 8; j++) {\n            if ((crc & 0x0001) !== 0) {\n                crc >>= 1;\n                crc ^= 0xA001;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return [crc & 0xFF, (crc >> 8) & 0xFF]; // è¿”å› CRC ä½ä½å’Œé«˜ä½\n}","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1140,"y":180,"wires":[["1197dea47cf89610"]]},{"id":"e935e9a7f7aa1c5d","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"è¨­å‚™æ¸…å–®","func":"// è¨­å®šè¨­å‚™æ¸…å–®\nvar devices = context.get('devices') || [11,12,13]; // é»˜èªè¨­å‚™æ¸…å–®\n// ç‚ºæ¯å€‹è¨­å‚™ç”Ÿæˆä¸€æ¢æ¶ˆæ¯\nvar msgs = devices.map(deviceID => {\n    return {\n        deviceID: deviceID // å°‡è¨­å‚™ ID æ·»åŠ åˆ°æ¶ˆæ¯ä¸­\n    };\n});\n\n// è¿”å›æ‰€æœ‰æ¶ˆæ¯\nreturn [msgs];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":980,"y":140,"wires":[["ffdf224cf8ee326c"]]},{"id":"ffdf224cf8ee326c","type":"function","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"è©¢å•åœ°å€(R410)","func":"// ç²å–ç•¶å‰è¨­å‚™ ID\nvar deviceID = msg.deviceID;\n\n// è¨­å®šåƒæ•¸\nconst functionCode = 0x01;   // Read Coils\nconst startAddress = 0x0000; // Coil èµ·å§‹ä½å€ (å°æ‡‰ Relay1)\nconst quantity = 4;          // è®€å– 4 å€‹ç¹¼é›»å™¨ç‹€æ…‹\n\n// å°‡èµ·å§‹åœ°å€å’Œæ•¸é‡è½‰æ›ç‚ºå…©å€‹å­—ç¯€\nvar startAddressHigh = (startAddress >> 8) & 0xFF; // é«˜ä½\nvar startAddressLow = startAddress & 0xFF;        // ä½ä½\nvar quantityHigh = (quantity >> 8) & 0xFF;        // é«˜ä½\nvar quantityLow = quantity & 0xFF;               // ä½ä½\n\n// çµ„è£æŒ‡ä»¤\nvar message = [\n    deviceID,            // è¨­å‚™åœ°å€\n    functionCode,        // åŠŸèƒ½ç¢¼\n    startAddressHigh,    // èµ·å§‹åœ°å€é«˜ä½\n    startAddressLow,     // èµ·å§‹åœ°å€ä½ä½\n    quantityHigh,        // æ•¸é‡é«˜ä½\n    quantityLow          // æ•¸é‡ä½ä½\n];\n\n// è¨ˆç®— CRC æ ¡é©—\nvar crc = calculateCRC(message);\nmessage.push(crc[0]); // CRC ä½ä½\nmessage.push(crc[1]); // CRC é«˜ä½\n\n// å°‡æŒ‡ä»¤å­˜å…¥ msg.payload\nmsg.payload = Buffer.from(message);\nreturn msg;\n\n// CRC è¨ˆç®—å‡½å¼\nfunction calculateCRC(data) {\n    var crc = 0xFFFF;\n    for (var i = 0; i < data.length; i++) {\n        crc ^= data[i];\n        for (var j = 0; j < 8; j++) {\n            if ((crc & 0x0001) !== 0) {\n                crc >>= 1;\n                crc ^= 0xA001;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return [crc & 0xFF, (crc >> 8) & 0xFF]; // è¿”å› CRC ä½ä½å’Œé«˜ä½\n}","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1140,"y":140,"wires":[["1197dea47cf89610"]]},{"id":"9d2ab15d83556dac","type":"inject","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"","props":[],"repeat":"5","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":830,"y":140,"wires":[["e935e9a7f7aa1c5d"]]},{"id":"97dc1961a883fa50","type":"comment","z":"e345e003a053a625","d":true,"g":"a3d04f6b50124da1","name":"è¨­å‚™è¼ªè©¢","info":"","x":820,"y":100,"wires":[]},{"id":"961c7b6b857e142e","type":"inject","z":"e345e003a053a625","g":"856c5ad89dfdd04b","name":"","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":130,"y":460,"wires":[["82ceaf2e62b7218a"]]},{"id":"2e98dadaf8e45671","type":"mqtt out","z":"e345e003a053a625","g":"856c5ad89dfdd04b","name":"ç™¼é€åˆ° MQTT Broker","topic":"","qos":"","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"751ec40a6956d4f9","x":580,"y":460,"wires":[]},{"id":"e830bdf110f44fe3","type":"mqtt in","z":"e345e003a053a625","g":"d634068781bfec19","name":"","topic":"homeassistant/+/+/+/+/set/#","qos":"0","datatype":"auto-detect","broker":"751ec40a6956d4f9","nl":false,"rap":true,"rh":0,"inputs":0,"x":240,"y":940,"wires":[["d75738502c9029fc","bdbab8f3e4311de9"]]},{"id":"d75738502c9029fc","type":"function","z":"e345e003a053a625","g":"d634068781bfec19","name":"command(General)","func":"const DEFAULT_BRIGHTNESS = 100;\nconst DEFAULT_COLORTEMP = 250;\nconst MIN_MIRED = 167, MAX_MIRED = 333;\nconst BRIGHTNESS_TIME = 0x05;\nconst CHANNEL_REGISTER_MAP = {\n    \"1\": 0x082A,\n    \"2\": 0x082B,\n    \"3\": 0x082C,\n    \"4\": 0x082D,\n    \"a\": [0x082A, 0x082B],\n    \"b\": [0x082C, 0x082D],\n};\n\n// CRC é©—è­‰\nfunction verifyCRC(buf) {\n    let crc = 0xFFFF;\n    for (let i = 0; i < buf.length - 2; i++) {\n        crc ^= buf[i];\n        for (let j = 0; j < 8; j++) {\n            crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n        }\n    }\n    const lo = crc & 0xFF;\n    const hi = (crc >> 8) & 0xFF;\n    return lo === buf[buf.length - 2] && hi === buf[buf.length - 1];\n}\n\nfunction printBinary(output) {\n    node.warn(`${output.toString(2).padStart(8, \"0\")}`);\n}\n\nfunction generalCommandBuild(frame) {\n    function crc16(buf) {\n        let crc = 0xFFFF;\n        for (const b of buf) {\n            crc ^= b;\n            for (let i = 0; i < 8; i++) {\n                crc = (crc & 1) ? ((crc >> 1) ^ 0xA001) : (crc >> 1);\n            }\n        }\n        return crc;\n    }\n    const crc = crc16(frame);\n    return Buffer.concat([frame, Buffer.from([crc & 0xFF, (crc >> 8) & 0xFF])]);\n}\n\nfunction clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\n\nfunction getBrightness(subType, moduleId, channel, state) {\n    let brightness = flow.get(`${subType}_${moduleId}_${channel}_brightness`);\n    if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n    // é™åˆ¶äº®åº¦ç¯„åœ\n    brightness = (state === \"ON\") ? clamp(Math.round(brightness), 0, 100) : 0x00;\n    return brightness;\n}\n\n// è‡ªå‹•è™•ç† modbus_queue çš„è¼”åŠ©å‡½æ•¸ï¼ˆç›®å‰æ²’ç”¨åˆ°ï¼Œä½†ä¿ç•™ï¼‰\nfunction triggerModbusQueueProcessor() {\n    node.send([null, { topic: \"trigger_modbus_queue\", payload: \"process\" }]);\n}\n\n// ä¸»æµç¨‹\nconst parts = String(msg.topic || \"\").split(\"/\");\nconst deviceType = parts[1];     // light cover hvac memory scene query\n\nswitch (deviceType) {\n    case \"light\": {\n        const subType = parts[2];           // single, dual, relay, scene\n        const moduleId = parseInt(parts[3]);\n        const channel = parts[4];\n\n        // ğŸ”¹åœ¨ light è£¡è™•ç† set/brightnessã€set/colortemp\n        // ç¯„ä¾‹: homeassistant/light/single/13/1/set/brightness\n        if (parts.length >= 7 && parts[5] === \"set\") {\n            const attribute = parts[6];     // brightness / colortemp ç­‰\n            const key = `${subType}_${moduleId}_${channel}_${attribute}`;\n            const val = Number(msg.payload);\n\n            if (!isNaN(val)) {\n                flow.set(key, val);\n                node.status({\n                    fill: \"green\",\n                    shape: \"ring\",\n                    text: `${key} = ${val}`\n                });\n            }\n\n            // è‹¥ä¸æ˜¯äº®åº¦/è‰²æº«ï¼Œå°±å–®ç´”ç•¶ cache ç”¨ï¼Œä¸å¾€ä¸‹ç™¼æŒ‡ä»¤\n            if (attribute !== \"brightness\" && attribute !== \"colortemp\") {\n                return null;\n            }\n\n            // äº®åº¦ / è‰²æº«ï¼šé †ä¾¿å¹«å¿™è£œä¸€ç™¼ /setï¼Œè®“å®ƒèµ°åŸæœ¬ single/dual çš„é‚è¼¯\n            const stateKey = `${subType}_${moduleId}_${channel}_state`;\n            let state = flow.get(stateKey);\n\n            // ğŸ”§ ä¿®æ­£ï¼šæ”¶åˆ°äº®åº¦/è‰²æº«æŒ‡ä»¤æ™‚ï¼Œæ™ºèƒ½åˆ¤æ–·é–‹é—œç‹€æ…‹\n            if (attribute === \"brightness\") {\n                // äº®åº¦ > 0 è‡ªå‹•é–‹ç‡ˆï¼Œäº®åº¦ = 0 é—œç‡ˆ\n                if (val > 0) {\n                    state = \"ON\";\n                    flow.set(stateKey, \"ON\");\n                } else {\n                    state = \"OFF\";\n                    flow.set(stateKey, \"OFF\");\n                }\n            } else if (attribute === \"colortemp\") {\n                // è‰²æº«èª¿æ•´æ™‚ï¼Œå¦‚æœç‡ˆæ˜¯é—œçš„å°±é–‹ç‡ˆ\n                if (!state || state === \"OFF\") {\n                    state = \"ON\";\n                    flow.set(stateKey, \"ON\");\n                }\n            }\n\n            // å¦‚æœç‹€æ…‹ä»æœªçŸ¥ï¼ˆç†è«–ä¸Šä¸æœƒç™¼ç”Ÿï¼‰ï¼Œé è¨­ç‚º ON\n            if (!state) {\n                state = \"ON\";\n                flow.set(stateKey, \"ON\");\n            }\n\n            msg.topic = `homeassistant/light/${subType}/${moduleId}/${channel}/set`;\n            msg.payload = state;\n            // ä¸ returnï¼Œç¹¼çºŒå¾€ä¸‹è·‘ switch(subType)\n        }\n\n        switch (subType) {\n            case \"relay\": {\n                const CHANNEL_COIL_MAP = {\n                    \"1\": 0x0000,\n                    \"2\": 0x0001,\n                    \"3\": 0x0002,\n                    \"4\": 0x0003,\n                };\n                const addr = CHANNEL_COIL_MAP[channel];\n                if (addr === undefined) return null;\n\n                // Coil å¯«å…¥å€¼ ON ç‚º 0xFF00 OFF ç‚º 0x0000\n                const valHi = (msg.payload === \"ON\") ? 0xFF : 0x00;\n                const valLo = 0x00;\n\n                // é«˜ä½ä½ä½å€\n                const hi = (addr >> 8) & 0xFF;\n                const lo = addr & 0xFF;\n\n                // çµ„ Modbus æŒ‡ä»¤ 0x05 Write Single Coil\n                const frame = Buffer.from([moduleId, 0x05, hi, lo, valHi, valLo]);\n                const state = (msg.payload === \"ON\") ? \"ON\" : \"OFF\";\n\n                // è¨˜éŒ„ç‹€æ…‹åˆ° flow context\n                const stateKey = `${subType}_${moduleId}_${channel}_state`;\n                flow.set(stateKey, state);\n\n                // æ¨å…¥ modbus_queue çµ±ä¸€ç®¡ç†ç™¼é€\n                let modbus_queue = global.get(\"modbus_queue\") || [];\n                modbus_queue.push({ payload: generalCommandBuild(frame) });\n                global.set(\"modbus_queue\", modbus_queue);\n\n                // ç™¼é€ MQTT ç‹€æ…‹æ›´æ–°çµ¦ Home Assistant\n                let mqtt_queue = global.get(\"mqtt_queue\") || [];\n                const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n                mqtt_queue.push({ topic: `${baseTopic}/state`, payload: state });\n                global.set(\"mqtt_queue\", mqtt_queue);\n\n                // ç™¼é€è§¸ç™¼è¨Šæ¯çµ¦ modbus_queue_processor\n                node.send([null, { topic: \"trigger_modbus_queue\", payload: \"process\" }]);\n                return null;\n            }\n            case \"single\": {\n                // ç‹€æ…‹ ON æˆ– OFF\n                let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n\n                // è¨˜éŒ„ç‹€æ…‹åˆ° flow context\n                const stateKey = `${subType}_${moduleId}_${channel}_state`;\n                flow.set(stateKey, state);\n\n                let brightness = getBrightness(subType, moduleId, channel, state);\n                // å–å¾—å°æ‡‰å¯„å­˜å™¨\n                const reg = CHANNEL_REGISTER_MAP[channel];\n                if (!reg) return null;\n                // é«˜ä½ä½å…ƒçµ„\n                const hi = (reg >> 8) & 0xFF;\n                const lo = reg & 0xFF;\n                // OFF ç‹€æ…‹ä½¿ç”¨ speed=0x00 ç«‹å³åŸ·è¡Œï¼ŒON ç‹€æ…‹ä½¿ç”¨ BRIGHTNESS_TIME\n                const speed = (state === \"OFF\") ? 0x00 : BRIGHTNESS_TIME;\n                // çµ„ Modbus æŒ‡ä»¤\n                const cmd = Buffer.from([moduleId, 0x06, hi, lo, speed, brightness]);\n\n                // æ¨å…¥ modbus_queue çµ±ä¸€ç®¡ç†ç™¼é€\n                let modbus_queue = global.get(\"modbus_queue\") || [];\n                modbus_queue.push({ payload: generalCommandBuild(cmd) });\n                global.set(\"modbus_queue\", modbus_queue);\n\n                // ç™¼é€ MQTT ç‹€æ…‹æ›´æ–°çµ¦ Home Assistant\n                let mqtt_queue = global.get(\"mqtt_queue\") || [];\n                const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n                mqtt_queue.push({ topic: `${baseTopic}/state`, payload: state });\n                if (state === \"ON\") {\n                    mqtt_queue.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n                }\n                global.set(\"mqtt_queue\", mqtt_queue);\n\n                // ç™¼é€è§¸ç™¼è¨Šæ¯çµ¦ modbus_queue_processor\n                node.send([null, { topic: \"trigger_modbus_queue\", payload: \"process\" }]);\n                return null;\n            }\n            case \"dual\": {\n                const regs = CHANNEL_REGISTER_MAP[channel];\n                if (!regs) return null;\n\n                let state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n\n                // è¨˜éŒ„ç‹€æ…‹åˆ° flow context\n                const stateKey = `${subType}_${moduleId}_${channel}_state`;\n                flow.set(stateKey, state);\n\n                const brKey = `${subType}_${moduleId}_${channel}_brightness`;\n                const ctKey = `${subType}_${moduleId}_${channel}_colortemp`;\n\n                let brightness = flow.get(brKey);\n                if (typeof brightness !== \"number\") brightness = DEFAULT_BRIGHTNESS;\n                brightness = clamp(Math.round(brightness), 0, 100);\n\n                let colortemp = flow.get(ctKey);\n                if (typeof colortemp !== \"number\") colortemp = DEFAULT_COLORTEMP;\n                colortemp = clamp(Math.round(colortemp), MIN_MIRED, MAX_MIRED);\n                const ctPercent = Math.round(((MAX_MIRED - colortemp) / (MAX_MIRED - MIN_MIRED)) * 100);\n\n                function buildCommand(moduleId, reg, value, speed = 0x05) {\n                    const hi = (reg >> 8) & 0xFF;\n                    const lo = reg & 0xFF;\n                    const cmd = Buffer.from([moduleId, 0x06, hi, lo, speed, value]);\n                    return generalCommandBuild(cmd);\n                }\n\n                const brValue = (state === \"ON\") ? brightness : 0;\n                const cmdBrightness = buildCommand(moduleId, regs[0], brValue);\n                const cmdColortemp = buildCommand(moduleId, regs[1], ctPercent);\n\n                // æ¨å…¥ modbus_queue çµ±ä¸€ç®¡ç†ç™¼é€\n                let modbus_queue = global.get(\"modbus_queue\") || [];\n                modbus_queue.push({ payload: cmdBrightness });\n                modbus_queue.push({ payload: cmdColortemp });\n                global.set(\"modbus_queue\", modbus_queue);\n\n                // ç™¼é€ MQTT ç‹€æ…‹æ›´æ–°çµ¦ Home Assistant\n                let mqtt_queue = global.get(\"mqtt_queue\") || [];\n                const baseTopic = `homeassistant/light/${subType}/${moduleId}/${channel}`;\n                mqtt_queue.push({ topic: `${baseTopic}/state`, payload: state });\n                if (state === \"ON\") {\n                    mqtt_queue.push({ topic: `${baseTopic}/brightness`, payload: brightness });\n                    mqtt_queue.push({ topic: `${baseTopic}/colortemp`, payload: colortemp });\n                }\n                global.set(\"mqtt_queue\", mqtt_queue);\n\n                // ç™¼é€è§¸ç™¼è¨Šæ¯çµ¦ modbus_queue_processor\n                node.send([null, { topic: \"trigger_modbus_queue\", payload: \"process\" }]);\n\n                return null;\n            }\n            case \"wrgb\": {\n                return null;\n            }\n            case \"scene\": {\n                let mqtt_queue = global.get(\"mqtt_queue\");\n                switch (parts[3]) {\n                    case \"single\": {\n                        let lights = (parts[4]).split(\"--\");\n                        let groupBrightness = flow.get(`${subType}_${parts[3]}_${parts[4]}_brightness`);\n                        const state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n\n                        for (let i = 0; i < lights.length; i++) {\n                            let lightId = lights[i].split(\"-\")[0];\n                            let lightChannel = lights[i].split(\"-\")[1];\n\n                            // æ›´æ–° flow context ç‹€æ…‹\n                            const stateKey = `${parts[3]}_${lightId}_${lightChannel}_state`;\n                            flow.set(stateKey, state);\n                            if (state === \"ON\" && groupBrightness !== undefined) {\n                                const brightnessKey = `${parts[3]}_${lightId}_${lightChannel}_brightness`;\n                                flow.set(brightnessKey, groupBrightness);\n                            }\n\n                            // æ›´æ–°å¯¦éš›è¨­å‚™ç‹€æ…‹\n                            let stateMsg = { ...msg };\n                            stateMsg.topic = `homeassistant/light/${parts[3]}/${lightId}/${lightChannel}/state`;\n                            mqtt_queue.push(stateMsg);\n\n                            let brightnessMsg = { ...msg };\n                            brightnessMsg.topic = `homeassistant/light/${parts[3]}/${lightId}/${lightChannel}/set/brightness`;\n                            brightnessMsg.payload = groupBrightness;\n                            mqtt_queue.push(brightnessMsg);\n\n                            let brightnessStateMsg = { ...msg };\n                            brightnessStateMsg.topic = `homeassistant/light/${parts[3]}/${lightId}/${lightChannel}/brightness`;\n                            brightnessStateMsg.payload = groupBrightness;\n                            mqtt_queue.push(brightnessStateMsg);\n\n                            let setMsg = { ...msg };\n                            setMsg.topic = `homeassistant/light/${parts[3]}/${lightId}/${lightChannel}/set`;\n                            mqtt_queue.push(setMsg);\n\n                            // æ›´æ–°å°æ‡‰çš„å ´æ™¯è¨­å‚™UIç‹€æ…‹\n                            let sceneStateMsg = { ...msg };\n                            sceneStateMsg.topic = `homeassistant/light/scene/${parts[3]}/${lightId}-${lightChannel}/state`;\n                            mqtt_queue.push(sceneStateMsg);\n\n                            let sceneBrightnessMsg = { ...msg };\n                            sceneBrightnessMsg.topic = `homeassistant/light/scene/${parts[3]}/${lightId}-${lightChannel}/brightness`;\n                            sceneBrightnessMsg.payload = groupBrightness;\n                            mqtt_queue.push(sceneBrightnessMsg);\n                        }\n\n                        // æ›´æ–°çµ„åˆå‹å ´æ™¯è¨­å‚™UI\n                        const sceneGroups = [\n                            { ids: [\"11-1\", \"11-2\"], sceneId: \"11-1--11-2\" },  // èµ°å»Šé–“ç…§\n                            { ids: [\"12-3\", \"12-4\"], sceneId: \"12-3--12-4\" },  // å±•ç¤ºæ«ƒ\n                            { ids: [\"16-1\", \"16-2\"], sceneId: \"16-1--16-2\" },  // èµ°é“é–“ç…§\n                            { ids: [\"17-1\", \"17-2\"], sceneId: \"17-1--17-2\" },  // å»šæˆ¿\n                            { ids: [\"18-1\", \"18-2\"], sceneId: \"18-1--18-2\" },  // 1Få£ç‡ˆ/åœ°ç‡ˆçµ„åˆ\n                            { ids: [\"19-1\", \"19-2\"], sceneId: \"19-1--19-2\" }   // 2Få£ç‡ˆ/åœ°ç‡ˆçµ„åˆ\n                        ];\n\n                        for (const group of sceneGroups) {\n                            const allIncluded = group.ids.every(id => lights.includes(id));\n                            if (allIncluded) {\n                                let groupSceneStateMsg = { ...msg };\n                                groupSceneStateMsg.topic = `homeassistant/light/scene/${parts[3]}/${group.sceneId}/state`;\n                                mqtt_queue.push(groupSceneStateMsg);\n\n                                let groupSceneBrightnessMsg = { ...msg };\n                                groupSceneBrightnessMsg.topic = `homeassistant/light/scene/${parts[3]}/${group.sceneId}/brightness`;\n                                groupSceneBrightnessMsg.payload = groupBrightness;\n                                mqtt_queue.push(groupSceneBrightnessMsg);\n                            }\n                        }\n\n                        return null;\n                    }\n                    case \"dual\": {\n                        let lights = (parts[4]).split(\"--\");\n                        let groupBrightness = flow.get(`${subType}_${parts[3]}_${parts[4]}_brightness`);\n                        let groupColortemp = flow.get(`${subType}_${parts[3]}_${parts[4]}_colortemp`);\n                        const state = (msg.payload === \"ON\" || msg.payload === true) ? \"ON\" : \"OFF\";\n\n                        for (let i = 0; i < lights.length; i++) {\n                            let lightId = lights[i].split(\"-\")[0];\n                            let lightChannel = lights[i].split(\"-\")[1];\n\n                            // æ›´æ–° flow context ç‹€æ…‹\n                            const stateKey = `${parts[3]}_${lightId}_${lightChannel}_state`;\n                            flow.set(stateKey, state);\n                            if (state === \"ON\") {\n                                if (groupBrightness !== undefined) {\n                                    const brightnessKey = `${parts[3]}_${lightId}_${lightChannel}_brightness`;\n                                    flow.set(brightnessKey, groupBrightness);\n                                }\n                                if (groupColortemp !== undefined) {\n                                    const colortempKey = `${parts[3]}_${lightId}_${lightChannel}_colortemp`;\n                                    flow.set(colortempKey, groupColortemp);\n                                }\n                            }\n\n                            // æ›´æ–°å¯¦éš›è¨­å‚™ç‹€æ…‹\n                            let stateMsg = { ...msg };\n                            stateMsg.topic = `homeassistant/light/dual/${lightId}/${lightChannel}/state`;\n                            mqtt_queue.push(stateMsg);\n\n                            let brightnessMsg = { ...msg };\n                            brightnessMsg.topic = `homeassistant/light/dual/${lightId}/${lightChannel}/set/brightness`;\n                            brightnessMsg.payload = groupBrightness;\n                            mqtt_queue.push(brightnessMsg);\n\n                            let brightnessStateMsg = { ...msg };\n                            brightnessStateMsg.topic = `homeassistant/light/dual/${lightId}/${lightChannel}/brightness`;\n                            brightnessStateMsg.payload = groupBrightness;\n                            mqtt_queue.push(brightnessStateMsg);\n\n                            if (groupColortemp !== undefined) {\n                                let colortempMsg = { ...msg };\n                                colortempMsg.topic = `homeassistant/light/dual/${lightId}/${lightChannel}/set/colortemp`;\n                                colortempMsg.payload = groupColortemp;\n                                mqtt_queue.push(colortempMsg);\n\n                                let colortempStateMsg = { ...msg };\n                                colortempStateMsg.topic = `homeassistant/light/dual/${lightId}/${lightChannel}/colortemp`;\n                                colortempStateMsg.payload = groupColortemp;\n                                mqtt_queue.push(colortempStateMsg);\n                            }\n\n                            let setMsg = { ...msg };\n                            setMsg.topic = `homeassistant/light/dual/${lightId}/${lightChannel}/set`;\n                            mqtt_queue.push(setMsg);\n\n                            // æ›´æ–°å°æ‡‰çš„å ´æ™¯è¨­å‚™UIç‹€æ…‹\n                            let sceneStateMsg = { ...msg };\n                            sceneStateMsg.topic = `homeassistant/light/scene/${parts[3]}/${lightId}-${lightChannel}/state`;\n                            mqtt_queue.push(sceneStateMsg);\n\n                            let sceneBrightnessMsg = { ...msg };\n                            sceneBrightnessMsg.topic = `homeassistant/light/scene/${parts[3]}/${lightId}-${lightChannel}/brightness`;\n                            sceneBrightnessMsg.payload = groupBrightness;\n                            mqtt_queue.push(sceneBrightnessMsg);\n\n                            if (groupColortemp !== undefined) {\n                                let sceneColortempMsg = { ...msg };\n                                sceneColortempMsg.topic = `homeassistant/light/scene/${parts[3]}/${lightId}-${lightChannel}/colortemp`;\n                                sceneColortempMsg.payload = groupColortemp;\n                                mqtt_queue.push(sceneColortempMsg);\n                            }\n                        }\n                        return null;\n                    }\n                    default: {\n                        node.warn(`receive scene:${parts[3]}`);\n                        return null;\n                    }\n                }\n            }\n            default: {\n                node.warn(`unknown light subtype: ${subType}`);\n                return null;\n            }\n        }\n    }\n\n    case \"cover\": {\n        // æ ¼å¼ é–‹å•Ÿçš„relay_é–‹å•Ÿçš„relay/é—œé–‰çš„relay_é—œé–‰çš„relay\n        // payload ç¯„ä¾‹ 1_2/3 è¡¨ç¤ºé–‹å•Ÿ relay 1 å’Œ 2 é—œé–‰ relay 3\n        const moduleId = parseInt(parts[3]);  // æ¨¡çµ„ ID\n\n        let relays = msg.payload.split(\"/\");\n        let on_relays = relays[0] ? relays[0].split(\"_\").map(Number) : [];\n        let off_relays = (relays[1] && relays[1].length > 0) ? relays[1].split(\"_\").map(Number) : [];\n\n        // è¨ˆç®— bit mask\n        let output = 0x00;\n\n        // æ‰“é–‹ on_relays\n        for (let relay of on_relays) {\n            output |= (1 << (relay - 1));  // relay 1 å°æ‡‰ bit 0\n        }\n\n        // æ¸…é™¤ off_relays å°æ‡‰çš„ bit\n        for (let relay of off_relays) {\n            output &= ~(1 << (relay - 1)); // relay 2 å°æ‡‰ bit 1 ç½® 0\n        }\n        const frame = Buffer.from([moduleId, 0x06, 0x01, 0x9b, 0x10, output]);\n        msg.payload = generalCommandBuild(frame);\n        // æ¨å…¥ modbus_queue çµ±ä¸€ç®¡ç†ç™¼é€\n        let modbus_queue = global.get(\"modbus_queue\") || [];\n        modbus_queue.push(msg);\n        global.set(\"modbus_queue\", modbus_queue);\n        // ç™¼é€è§¸ç™¼è¨Šæ¯çµ¦ modbus_queue_processor\n        node.send([null, { topic: \"trigger_modbus_queue\", payload: \"process\" }]);\n        return null;\n    }\n\n    case \"hvac\": {\n        const s200Id = parseInt(parts[2]);      // S200 æ¨¡çµ„ ID\n        const hvacId = parseInt(parts[3]);      // HVAC è¨­å‚™ ID 1 2 3\n        const hvacAction = parts[4];            // mode fan temperature\n        const payload = msg.payload;\n\n        const baseAddress = 0x100;\n        const speed = 0x00; // çµ±ä¸€ transition speed\n\n        const modeMap = {\n            \"cool\": 0,\n            \"heat\": 1,\n            \"dry\": 2,\n            \"fan_only\": 3,\n            \"off\": 4\n        };\n\n        const fanModeMap = {\n            \"auto\": 0,\n            \"low\": 1,\n            \"medium\": 2,\n            \"high\": 3\n        };\n\n        let register, value;\n\n        switch (hvacAction) {\n            case \"mode\":\n                register = baseAddress + hvacId * 8 + 1;\n                value = modeMap[payload];\n                break;\n\n            case \"fan\":\n                register = baseAddress + hvacId * 8 + 2;\n                value = fanModeMap[payload];\n                break;\n\n            case \"temperature\":\n                register = baseAddress + hvacId * 8 + 3;\n                value = parseFloat(payload);\n                break;\n\n            default:\n                node.warn(\"Unknown HVAC action: \" + hvacAction);\n                return null;\n        }\n\n        if (value === undefined || value === null) {\n            node.warn(\"Invalid HVAC value: \" + payload);\n            return null;\n        }\n\n        const regHi = (register >> 8) & 0xFF;\n        const regLo = register & 0xFF;\n\n        // s200Id, 0x06, regHi, regLo, speed, value\n        const frame = Buffer.from([\n            s200Id,\n            0x06,\n            regHi,\n            regLo,\n            speed,\n            value\n        ]);\n\n        msg.payload = generalCommandBuild(frame);\n        // æ¨å…¥ modbus_queue çµ±ä¸€ç®¡ç†ç™¼é€\n        let modbus_queue = global.get(\"modbus_queue\") || [];\n        modbus_queue.push(msg);\n        global.set(\"modbus_queue\", modbus_queue);\n        // ç™¼é€è§¸ç™¼è¨Šæ¯çµ¦ modbus_queue_processor\n        node.send([null, { topic: \"trigger_modbus_queue\", payload: \"process\" }]);\n        return null;\n    }\n\n    case \"memory\": {\n        // è¨˜æ†¶å„²å­˜è™•ç†\n        // ä¸»é¡Œæ ¼å¼ homeassistant/memory/sceneId/operation/save/set\n        const sceneId = parts[2];      // 0x02 0x03 0xFF\n        const operation = parts[3];    // 0x01 0x02 0x03 0x04\n        const action = parts[4];       // save\n\n        if (action === \"save\") {\n            const memoryKey = `homeassistant/memory/${sceneId}/${operation}`;\n\n            // payload å¯èƒ½å·²ç¶“æ˜¯ object æˆ–æ˜¯ string\n            const requestData = typeof msg.payload === 'string' ? JSON.parse(msg.payload) : msg.payload;\n\n            // è®€å–æ¯å€‹è¨­å‚™çš„ç•¶å‰ç‹€æ…‹\n            const devicesWithState = [];\n            node.warn(`=== é–‹å§‹è¨˜æ†¶å„²å­˜ ${memoryKey} ===`);\n\n            for (const deviceTopic of requestData.devices) {\n                // deviceTopic æ ¼å¼: homeassistant/light/single/13/1\n                const deviceParts = deviceTopic.split(\"/\");\n                const subType = deviceParts[2];  // single, dual\n                const moduleId = deviceParts[3];\n                const channel = deviceParts[4];\n\n                // è®€å– flow context ä¸­çš„ç‹€æ…‹\n                const stateKey = `${subType}_${moduleId}_${channel}_state`;\n                const brightnessKey = `${subType}_${moduleId}_${channel}_brightness`;\n                const colortempKey = `${subType}_${moduleId}_${channel}_colortemp`;\n\n                const state = flow.get(stateKey) || \"OFF\";\n                const brightness = flow.get(brightnessKey) || DEFAULT_BRIGHTNESS;\n\n                node.warn(`  è®€å– ${moduleId}-${channel}: state=${state}, brightness=${brightness}`);\n\n                const deviceState = {\n                    topic: deviceTopic,\n                    state: state,\n                    brightness: brightness\n                };\n\n                // å¦‚æœæ˜¯ dual é¡å‹ï¼Œé‚„è¦è¨˜éŒ„è‰²æº«\n                if (subType === \"dual\") {\n                    const colortemp = flow.get(colortempKey) || DEFAULT_COLORTEMP;\n                    deviceState.colortemp = colortemp;\n                    node.warn(`    è‰²æº«=${colortemp}`);\n                }\n\n                devicesWithState.push(deviceState);\n            }\n\n            // å„²å­˜åŒ…å«å¯¦éš›ç‹€æ…‹çš„è³‡æ–™\n            const memoryData = {\n                scene_name: requestData.scene_name,\n                devices: devicesWithState,\n                timestamp: new Date().toISOString()\n            };\n\n            global.set(memoryKey, memoryData);\n\n            // ç™¼é€ç¢ºèªé€šçŸ¥\n            let mqtt_queue = global.get(\"mqtt_queue\") || [];\n            mqtt_queue.push({\n                topic: `homeassistant/memory/${sceneId}/${operation}/saved`,\n                payload: JSON.stringify({\n                    status: \"saved\",\n                    timestamp: memoryData.timestamp,\n                    device_count: devicesWithState.length\n                })\n            });\n            global.set(\"mqtt_queue\", mqtt_queue);\n\n            node.warn(`è¨˜æ†¶å·²å„²å­˜: ${memoryKey} (${devicesWithState.length}å€‹è¨­å‚™)`);\n        }\n        return null;\n    }\n\n    case \"scene\": {\n        // å ´æ™¯åŸ·è¡Œè™•ç†\n        // ä¸»é¡Œæ ¼å¼ homeassistant/scene/sceneId/operation/execute/set\n        const sceneId = parts[2];      // 0x02 0x03 0xFF\n        const operation = parts[3];    // 0x01 0x02 0x03 0x04\n        const action = parts[4];       // execute\n\n        if (action !== \"execute\") return null;\n\n        let mqtt_queue = global.get(\"mqtt_queue\") || [];\n\n        // å„ªå…ˆå¾è¨˜æ†¶è®€å–å ´æ™¯è³‡æ–™\n        const memoryKey = `homeassistant/memory/${sceneId}/${operation}`;\n        const memoryData = global.get(memoryKey);\n\n        if (memoryData && memoryData.devices) {\n            // ä½¿ç”¨è¨˜æ†¶è³‡æ–™åŸ·è¡Œå ´æ™¯\n            node.warn(`=== åŸ·è¡Œè¨˜æ†¶å ´æ™¯: ${memoryKey} (${memoryData.devices.length}å€‹è¨­å‚™) ===`);\n            node.warn(`  è¨˜æ†¶æ™‚é–“: ${memoryData.timestamp}`);\n\n            // æ¢å¾©æ¯å€‹è¨­å‚™çš„è¨˜æ†¶ç‹€æ…‹\n            for (const device of memoryData.devices) {\n                const deviceTopic = device.topic;\n                const deviceParts = deviceTopic.split(\"/\");\n                const subType = deviceParts[2];  // single, dual\n                const moduleId = deviceParts[3];\n                const channel = deviceParts[4];\n\n                node.warn(`  æ¢å¾© ${moduleId}-${channel}: state=${device.state}, brightness=${device.brightness}`);\n\n                // æ ¹æ“šè¨˜æ†¶çš„ç‹€æ…‹è¨­å®šäº®åº¦\n                if (device.state === \"ON\" && device.brightness !== undefined) {\n                    mqtt_queue.push({\n                        topic: `${deviceTopic}/set/brightness`,\n                        payload: device.brightness\n                    });\n                }\n\n                // å¦‚æœæ˜¯ dual é¡å‹ä¸”æœ‰è‰²æº«è³‡æ–™\n                if (subType === \"dual\" && device.colortemp !== undefined) {\n                    mqtt_queue.push({\n                        topic: `${deviceTopic}/set/colortemp`,\n                        payload: device.colortemp\n                    });\n                    node.warn(`    è‰²æº«=${device.colortemp}`);\n                }\n\n                // ç™¼é€é–‹é—œç‹€æ…‹\n                mqtt_queue.push({\n                    topic: `${deviceTopic}/set`,\n                    payload: device.state\n                });\n            }\n        } else {\n            // ä½¿ç”¨é è¨­å ´æ™¯é…ç½®\n            node.warn(`åŸ·è¡Œé è¨­å ´æ™¯: ${sceneId}/${operation}`);\n\n            // å ´æ™¯é è¨­é…ç½® æ ¹æ“šå ´æ™¯è¡¨æ ¼è¨­å®š\n            const SCENE_DEFAULT = {\n                // æœƒè­°å®¤å ´æ™¯ ç¾¤çµ„2\n                \"0x02\": {\n                    \"0x01\": [  // æœƒè­°å®¤ON 60% - ä½¿ç”¨å ´æ™¯ç‡ˆç¾¤çµ„\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set/brightness\", payload: 60 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/brightness\", payload: 50 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/colortemp\", payload: 250 },\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set\", payload: \"ON\" },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set\", payload: \"ON\" }\n                    ],\n                    \"0x02\": [  // æœƒè­°å®¤OFF 0%\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set\", payload: \"OFF\" },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set\", payload: \"OFF\" }\n                    ],\n                    \"0x03\": [  // æœƒè­°å®¤100% 100%\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set/brightness\", payload: 100 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/brightness\", payload: 100 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/colortemp\", payload: 250 },\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set\", payload: \"ON\" },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set\", payload: \"ON\" }\n                    ],\n                    \"0x04\": [  // æœƒè­°å®¤å ´æ™¯2 æ··åˆ\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2/set\", payload: \"OFF\" },\n                        { topic: \"homeassistant/light/scene/single/13-3/set/brightness\", payload: 10 },\n                        { topic: \"homeassistant/light/scene/single/13-3/set\", payload: \"ON\" },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/brightness\", payload: 50 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/colortemp\", payload: 333 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set\", payload: \"ON\" }\n                    ]\n                },\n                // å…¬å…±å€å ´æ™¯ ç¾¤çµ„3\n                \"0x03\": {\n                    \"0x01\": [  // å…¬å…±å€ON 50%\n                        { topic: \"homeassistant/light/scene/single/11-1--11-2--12-1--12-2--12-3--12-4/set/brightness\", payload: 50 },\n                        { topic: \"homeassistant/light/scene/single/11-1--11-2--12-1--12-2--12-3--12-4/set\", payload: \"ON\" }\n                    ],\n                    \"0x02\": [  // å…¬å…±å€OFF 0%\n                        { topic: \"homeassistant/light/scene/single/11-1--11-2--12-1--12-2--12-3--12-4/set\", payload: \"OFF\" }\n                    ]\n                },\n                // æˆ¶å¤–ç‡ˆå ´æ™¯ ç¾¤çµ„4\n                \"0x04\": {\n                    \"0x01\": [  // æˆ¶å¤–ç‡ˆON 50%\n                        { topic: \"homeassistant/light/scene/single/18-1--18-2--19-1--19-2/set/brightness\", payload: 50 },\n                        { topic: \"homeassistant/light/scene/single/18-1--18-2--19-1--19-2/set\", payload: \"ON\" }\n                    ],\n                    \"0x02\": [  // æˆ¶å¤–ç‡ˆOFF 0%\n                        { topic: \"homeassistant/light/scene/single/18-1--18-2--19-1--19-2/set\", payload: \"OFF\" }\n                    ]\n                },\n                // äºŒæ¥¼å ´æ™¯ ç¾¤çµ„5 (H40)\n                \"0x05\": {\n                    \"0x01\": [  // S1 å…¨é–‹ 50%\n                        { topic: \"homeassistant/light/scene/single/15-1--15-2--16-1--16-2--17-1--17-2--18-1--18-2--19-1--19-2/set/brightness\", payload: 50 },\n                        { topic: \"homeassistant/light/scene/single/15-1--15-2--16-1--16-2--17-1--17-2--18-1--18-2--19-1--19-2/set\", payload: \"ON\" }\n                    ],\n                    \"0x02\": [  // S2 å…¨é—œ 0%\n                        { topic: \"homeassistant/light/scene/single/15-1--15-2--16-1--16-2--17-1--17-2--18-1--18-2--19-1--19-2/set\", payload: \"OFF\" }\n                    ],\n                    \"0x03\": [  // S3 èˆ’é€‚ 0% (å…¨å…³)\n                        { topic: \"homeassistant/light/scene/single/15-1--15-2--16-1--16-2--17-1--17-2--18-1--18-2--19-1--19-2/set\", payload: \"OFF\" }\n                    ],\n                    \"0x04\": [  // S4 ç”¨é¤ 0% (å…¨å…³)\n                        { topic: \"homeassistant/light/scene/single/15-1--15-2--16-1--16-2--17-1--17-2--18-1--18-2--19-1--19-2/set\", payload: \"OFF\" }\n                    ],\n                    \"0x05\": [  // S5 å½±éŸ³ 0% (å…¨å…³)\n                        { topic: \"homeassistant/light/scene/single/15-1--15-2--16-1--16-2--17-1--17-2--18-1--18-2--19-1--19-2/set\", payload: \"OFF\" }\n                    ],\n                    \"0x06\": [  // S6 ç¡çœ  0% (å…¨å…³)\n                        { topic: \"homeassistant/light/scene/single/15-1--15-2--16-1--16-2--17-1--17-2--18-1--18-2--19-1--19-2/set\", payload: \"OFF\" }\n                    ]\n                },\n                // å…¨éƒ¨å ´æ™¯ ç¾¤çµ„255\n                \"0xFF\": {\n                    \"0x01\": [  // å…¨é–‹ å„å€é è¨­äº®åº¦\n                        { topic: \"homeassistant/light/scene/single/11-1--11-2--12-1--12-2--12-3--12-4/set/brightness\", payload: 50 },\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set/brightness\", payload: 60 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/brightness\", payload: 50 },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set/colortemp\", payload: 250 },\n                        { topic: \"homeassistant/light/scene/single/11-1--11-2--12-1--12-2--12-3--12-4/set\", payload: \"ON\" },\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set\", payload: \"ON\" },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set\", payload: \"ON\" }\n                    ],\n                    \"0x02\": [  // å…¨é—œ\n                        { topic: \"homeassistant/light/scene/single/11-1--11-2--12-1--12-2--12-3--12-4/set\", payload: \"OFF\" },\n                        { topic: \"homeassistant/light/scene/single/13-1--13-2--13-3/set\", payload: \"OFF\" },\n                        { topic: \"homeassistant/light/scene/dual/14-a--14-b/set\", payload: \"OFF\" }\n                    ]\n                }\n            };\n\n            const commands = SCENE_DEFAULT[sceneId]?.[operation];\n            if (commands) {\n                for (const cmd of commands) {\n                    mqtt_queue.push(cmd);\n                }\n            }\n        }\n\n        global.set(\"mqtt_queue\", mqtt_queue);\n        return null;\n    }\n\n    case \"query\": {\n        const subType = parts[2];      // light cover\n        const moduleId = parseInt(parts[3]);  // æ¨¡çµ„ ID\n        const channel = parts[4];      // é€šé“ ID\n\n        node.warn(`received query topic: ${msg.topic}`);\n        let frame;\n        switch (subType) {\n            case \"light\": {\n                node.warn(`query light: ${msg.topic}`);\n                // light è®€å–ç·šåœˆæˆ–äº®åº¦ç‹€æ…‹\n                const CHANNEL_COIL_MAP = { \"1\": 0x0000, \"2\": 0x0001, \"3\": 0x0002, \"4\": 0x0003 };\n                const addr = CHANNEL_COIL_MAP[channel];\n                node.warn(`channel: ${channel}, addr: ${addr}`);\n                if (addr === undefined) return null;\n\n                const functionCode = 0x01; // Read Coils\n                const quantity = 4;\n                const startHi = (addr >> 8) & 0xFF;\n                const startLo = addr & 0xFF;\n                const quantityHi = (quantity >> 8) & 0xFF;\n                const quantityLo = quantity & 0xFF;\n\n                frame = Buffer.from([moduleId, functionCode, startHi, startLo, quantityHi, quantityLo]);\n                node.warn(`frame: ${[moduleId, functionCode, startHi, startLo, quantityHi, quantityLo]}`);\n                node.warn(`frame:${frame.toString('hex')}`);\n                break;\n            }\n            case \"cover\": {\n                // cover è®€å–ç‹€æ…‹\n                const regHi = 0x01; // èµ·å§‹å¯„å­˜å™¨\n                const regLo = 0x9B;\n                const functionCode = 0x03; // Read Holding Registers\n                const quantityHi = 0x00;\n                const quantityLo = 0x02; // è®€å…©å€‹æš«å­˜\n                frame = Buffer.from([moduleId, functionCode, regHi, regLo, quantityHi, quantityLo]);\n                break;\n            }\n            default: {\n                node.warn(`unknown query subtype: ${subType}`);\n                return null;\n            }\n        }\n        const cmdBuffer = generalCommandBuild(frame);\n\n        // æ”¾å…¥ modbus_queue çµ±ä¸€ç®¡ç†ç™¼é€\n        let modbus_queue = global.get(\"modbus_queue\") || [];\n        modbus_queue.push({ payload: cmdBuffer, deviceID: moduleId, type: \"query\", deviceType: \"query\", subType, channel });\n        global.set(\"modbus_queue\", modbus_queue);\n\n        node.status({ fill: \"blue\", shape: \"dot\", text: `modbus queue length ${modbus_queue.length}` });\n        // ç™¼é€è§¸ç™¼è¨Šæ¯çµ¦ modbus_queue_processor\n        node.send([null, { topic: \"trigger_modbus_queue\", payload: \"process\" }]);\n        return null;\n    }\n\n    default: {\n        node.warn(`unknown device type: ${deviceType}`);\n        return null;\n    }\n}\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":250,"y":880,"wires":[["ae93e63cc2e21005"]]},{"id":"bdbab8f3e4311de9","type":"function","z":"e345e003a053a625","g":"d634068781bfec19","name":"Mqtt Queue","func":"let queue = global.get(\"mqtt_queue\") || [];\n\nif (queue.length > 0) {\n    function sendNext() {\n        // é‡æ–°å¾ global å–æœ€æ–° queueï¼ˆé¿å…åŒæ­¥å•é¡Œï¼‰\n        let q = global.get(\"mqtt_queue\") || [];\n        if (q.length > 0) {\n            // å–å‡ºç¬¬ä¸€ç­†\n            const msgToSend = q.shift();\n            // æ›´æ–° globalï¼ˆç§»é™¤å‰›ç™¼é€çš„é‚£ç­†ï¼‰\n            global.set(\"mqtt_queue\", q);\n            node.status({ fill: \"green\", shape: \"dot\", text: `queue ${q.length} left` });\n            // ç™¼é€\n            node.send(msgToSend);\n            setTimeout(sendNext, 50);  // â† æ”¹é€™è£¡ï¼šå¾ 1ms æ”¹ç‚º 50ms\n        } else {\n            // å…¨éƒ¨é€å®Œ\n            node.status({ fill: \"green\", shape: \"dot\", text: \"queue empty\" });\n        }\n    }\n    sendNext(); // å•Ÿå‹•ç™¼é€\n}\nreturn null;","outputs":1,"timeout":0,"noerr":0,"initialize":"// éƒ¨ç½²ç¯€é»å¾Œï¼Œæ­¤è™•æ·»åŠ çš„ä»£ç¢¼å°‡é‹è¡Œä¸€æ¬¡ã€‚ \nglobal.set(\"mqtt_queue\", []);","finalize":"","libs":[],"x":490,"y":960,"wires":[["aa8b69945dde9cf2"]]},{"id":"aa8b69945dde9cf2","type":"mqtt out","z":"e345e003a053a625","g":"d634068781bfec19","name":"","topic":"","qos":"","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"751ec40a6956d4f9","x":630,"y":960,"wires":[]},{"id":"ead5b3b5565422b1","type":"tcp in","z":"e345e003a053a625","g":"b31aec75ff90aabb","name":"","server":"client","host":"192.168.98.208","port":"502","datamode":"stream","datatype":"buffer","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":280,"y":1100,"wires":[["fb70cf11b152edc9"]]},{"id":"51cb52c331f4570a","type":"function","z":"e345e003a053a625","g":"b31aec75ff90aabb","name":"feedback","func":"let buf = msg.payload;\n/*============================================crc=======================================================*/\n// CRC æ ¡é©—\nfunction calculateCRC(buffer) {\n    let crc = 0xFFFF;\n    for (let pos = 0; pos < buffer.length - 2; pos++) {\n        crc ^= buffer.readUInt8(pos);\n        for (let i = 8; i !== 0; i--) {\n            if ((crc & 0x0001) !== 0) {\n                crc >>= 1;\n                crc ^= 0xA001;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return crc;\n}\n\nfunction isValidCRC(buffer) {\n    let receivedCRC = (buffer.readUInt8(buffer.length - 1) << 8) | buffer.readUInt8(buffer.length - 2);\n    let calculatedCRC = calculateCRC(buffer);\n    return receivedCRC === calculatedCRC;\n}\n\n// åƒ…ç•¶é•·åº¦æ­£ç¢ºä¸”CRCæ ¡é©—æˆåŠŸæ™‚è¿”å›æ¶ˆæ¯\n// node.warn(`crc ${isValidCRC(buf) ? \"pass\" : \"failed\"}`);\n/*========================================================================================================*/\n\nlet length = buf.length;\n\n// node.warn(`raw bytes: `);\n// node.warn({raw: buf});\n// node.warn(`BE: ${buf.readInt16BE(2)}, LE: ${buf.readInt16LE(2)}`);\n\n\nswitch (buf[1]) {\n    case 0x03: {\n        switch (buf.readInt16BE(2)) {\n            case 2090:\n            case 2091:\n            case 2092:\n            case 2093:\n            case 2094: {\n                let id = buf.readInt8(0);\n                let value = buf.readInt8(5);\n                if (value) {\n                    msg.payload = `ON`;\n                }\n                else {\n                    msg.payload = `OFF`;\n                }\n                let channel = buf.readInt16BE(2) - 2090\n                msg.topic = `homeassistant/light/single/${id}/${channel}/brightness`;\n                // node.warn(`å–®è‰²æº«èª¿å…‰ send: ${msg.topic}`);\n                // node.warn({ raw: msg.topic });\n                return null;\n            }\n            default: {\n                // node.warn(`unknown usage: ${buf.readInt16BE(2)}`)\n            }\n        }\n        break;\n    }\n    default: {\n        // node.warn(`Unknown function code: ${buf[1]}`);\n    }\n}\n\n// for (let i =0; i<buf.length;i++) {\n//     node.warn(`${buf[i]}`)\n// }\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":1140,"wires":[["63117ac4cada3093"]]},{"id":"aab64db9eb568cfc","type":"function","z":"e345e003a053a625","g":"b31aec75ff90aabb","name":"feedback_hvac","func":"let buf = msg.payload; // å‡è¨­ buf æ˜¯åŒ…å«æ‰€éœ€æ•¸æ“šçš„ç·©è¡å€\n\n// ç¢ºä¿ç·©è¡å€é•·åº¦æ­£ç¢º\nif (buf.length !== 17) {\n    return null;\n}\n\n// è®€å– 8 ä½å…ƒå’Œ 16 ä½å…ƒæ•¸æ“š\nlet s200_id = buf.readUInt8(0);\nlet fc = buf.readUInt8(1);\nlet len = buf.readUInt8(2);\n\nlet power_state = buf.readUInt16BE(3);\nlet mode_state = buf.readUInt16BE(5);\nlet fan_mode_state = buf.readUInt16BE(7);\nlet temperature_state = buf.readUInt16BE(9);\nlet current_temperature_state = buf.readUInt16BE(11);\n\nlet hvac_id = buf.readUInt8(14) / 8;\n\nlet crc16_lo = buf.readUInt8(15);\nlet crc16_hi = buf.readUInt8(16);\n\n// CRC æ ¡é©—\nfunction calculateCRC(buffer) {\n    let crc = 0xFFFF;\n    for (let pos = 0; pos < buffer.length - 2; pos++) {\n        crc ^= buffer.readUInt8(pos);\n        for (let i = 8; i !== 0; i--) {\n            if ((crc & 0x0001) !== 0) {\n                crc >>= 1;\n                crc ^= 0xA001;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return crc;\n}\n\nfunction isValidCRC(buffer) {\n    let receivedCRC = (buffer.readUInt8(buffer.length - 1) << 8) | buffer.readUInt8(buffer.length - 2);\n    let calculatedCRC = calculateCRC(buffer);\n    return receivedCRC === calculatedCRC;\n}\n\n// åƒ…ç•¶é•·åº¦æ­£ç¢ºä¸”CRCæ ¡é©—æˆåŠŸæ™‚è¿”å›æ¶ˆæ¯\nif (!isValidCRC(buf)) {\n    return null;\n}\n\n// å°æ‡‰æ•¸å­—å’Œå­—ç¬¦ä¸²çš„æ˜ å°„\nconst modeMap = {\n    0: \"cool\",\n    1: \"heat\",\n    2: \"dry\",\n    3: \"fan_only\",\n    4: \"off\"\n};\n\nconst fanModeMap = {\n    0: \"auto\",\n    1: \"low\",\n    2: \"medium\",\n    3: \"high\"\n};\n\n// ç•¶ power_state ç‚º 0 æ™‚ï¼Œå°‡ mode_state è¨­ç‚º \"off\"\nlet mode_state_str = (power_state === 0) ? \"off\" : modeMap[mode_state];\nlet fan_mode_state_str = fanModeMap[fan_mode_state];\n\n// è¿”å›å°æ‡‰çš„MQTTæ¶ˆæ¯\n\nnode.send({ payload: mode_state_str, topic: `homeassistant/hvac/200/${hvac_id}/mode/state` });\nnode.send({ payload: fan_mode_state_str, topic: `homeassistant/hvac/200/${hvac_id}/fan_mode/state` });\nnode.send({ payload: temperature_state, topic: `homeassistant/hvac/200/${hvac_id}/temperature/state` });\nnode.send({ payload: current_temperature_state, topic: `homeassistant/hvac/200/${hvac_id}/current_temperature` });\nreturn;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":560,"y":1180,"wires":[["63117ac4cada3093"]]},{"id":"68fad83bf4565fb9","type":"tcp in","z":"e345e003a053a625","g":"b31aec75ff90aabb","name":"","server":"client","host":"192.168.1.204","port":"502","datamode":"stream","datatype":"buffer","newline":"","topic":"","trim":false,"base64":false,"tls":"","x":280,"y":1160,"wires":[["fb70cf11b152edc9"]]},{"id":"5d523aebb9e9f50b","type":"function","z":"e345e003a053a625","g":"b31aec75ff90aabb","name":"feedback_dimmer","func":"let buf = msg.payload; // å‡è¨­ buf æ˜¯åŒ…å«æ‰€éœ€æ•¸æ“šçš„ç·©è¡å€\n\n// ç¢ºä¿ç·©è¡å€é•·åº¦æ­£ç¢º\nif (buf.length !== 21) {\n    return null;\n}\n\n// è®€å– 8 ä½å…ƒå’Œ 16 ä½å…ƒæ•¸æ“š\nlet id = buf.readUInt8(0);\nlet fc = buf.readUInt8(1);\nlet len = buf.readUInt8(2);\n\nlet ch1_brt = Math.floor(buf.readUInt16BE(3) / 10); // å°‡ ch1_brt é™¤ä»¥ 10 å–æ•´æ•¸\nlet ch2_brt = Math.floor(buf.readUInt16BE(5) / 10); // å°‡ ch2_brt é™¤ä»¥ 10 å–æ•´æ•¸\nlet ch3_brt = Math.floor(buf.readUInt16BE(7) / 10); // å°‡ ch3_brt é™¤ä»¥ 10 å–æ•´æ•¸\nlet ch4_brt = Math.floor(buf.readUInt16BE(9) / 10); // å°‡ ch4_brt é™¤ä»¥ 10 å–æ•´æ•¸\n\nlet ch1_state = buf.readUInt16BE(11);\nlet ch2_state = buf.readUInt16BE(13);\nlet ch3_state = buf.readUInt16BE(15);\nlet ch4_state = buf.readUInt16BE(17);\n\nlet crc16_lo = buf.readUInt8(19);\nlet crc16_hi = buf.readUInt8(20);\n\n// CRC æ ¡é©—\nfunction calculateCRC(buffer) {\n    let crc = 0xFFFF;\n    for (let pos = 0; pos < buffer.length - 2; pos++) {\n        crc ^= buffer.readUInt8(pos);\n        for (let i = 8; i !== 0; i--) {\n            if ((crc & 0x0001) !== 0) {\n                crc >>= 1;\n                crc ^= 0xA001;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n    return crc;\n}\n\nfunction isValidCRC(buffer) {\n    let receivedCRC = (buffer.readUInt8(buffer.length - 1) << 8) | buffer.readUInt8(buffer.length - 2);\n    let calculatedCRC = calculateCRC(buffer);\n    return receivedCRC === calculatedCRC;\n}\n\nif (!isValidCRC(buf)) {\n    return null;\n}\n\n// è™•ç†ç‹€æ…‹å’Œäº®åº¦çš„å‡½æ•¸\nfunction processChannel(id, ch_brt, ch_state, channel) {\n    if (ch_state === 0) {\n        return [\n            { payload: \"OFF\", topic: `homeassistant/light/p404/${id}/${channel}/status` }\n        ];\n    }\n\n    if (ch_state === 1 && ch_brt !== 0) {\n        node.send({ payload: ch_brt, topic: `homeassistant/light/p404/${id}/${channel}/brightness` });\n        node.send({ payload: ch_brt, topic: `homeassistant/light/p404/${id}/${channel}/set/brightness` });\n        node.send({ payload: \"ON\", topic: `homeassistant/light/p404/${id}/${channel}/status` });\n        return;\n    }\n\n    return;\n}\n\nprocessChannel(id, ch1_brt, ch1_state, 1);\nprocessChannel(id, ch2_brt, ch2_state, 2);\nprocessChannel(id, ch3_brt, ch3_state, 3);\nprocessChannel(id, ch4_brt, ch4_state, 4);\nreturn;","outputs":3,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":1220,"wires":[[],[],[]]},{"id":"63117ac4cada3093","type":"mqtt out","z":"e345e003a053a625","g":"b31aec75ff90aabb","name":"feedback","topic":"","qos":"0","retain":"false","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"751ec40a6956d4f9","x":720,"y":1160,"wires":[]},{"id":"97bb94752a7a0fdc","type":"function","z":"e345e003a053a625","g":"b31aec75ff90aabb","name":"HMI processor","func":"const MIN_MIRED = 167, MAX_MIRED = 333;\n\n// å ´æ™¯è¨˜æ†¶åŠŸèƒ½èªªæ˜\n//\n// è¨˜æ†¶æŒ‡ä»¤æ ¼å¼ FE 06 08 20 OP SCENE CRC_L CRC_H\n// æ“ä½œç¢¼ OP\n//   0x81 è¨˜æ†¶ONç‹€æ…‹\n//   0x82 è¨˜æ†¶OFFç‹€æ…‹\n//   0x83 è¨˜æ†¶å ´æ™¯1\n//   0x84 è¨˜æ†¶å ´æ™¯2\n//\n// å ´æ™¯ SCENE\n//   0x02 æœƒè­°å®¤\n//   0x03 å…¬å…±å€\n//   0xFF å…¨éƒ¨\n//\n// MQTT è¨˜æ†¶ä¸»é¡Œæ¶æ§‹\n//   å„²å­˜ homeassistant/scene/memory/sceneId/operation/save\n//   è®€å– homeassistant/scene/memory/sceneId/operation/data\n//\n// ç¯„ä¾‹\n//   å…¨é–‹è¨˜æ†¶   FE 06 08 20 81 FF BE 7F è½‰ç‚º homeassistant/scene/memory/0xFF/0x01/save\n//   æœƒè­°å®¤ON   FE 06 08 20 81 02 7F FE è½‰ç‚º homeassistant/scene/memory/0x02/0x01/save\n//   å…¬å…±å€å ´æ™¯1 FE 06 08 20 83 03 7E XX è½‰ç‚º homeassistant/scene/memory/0x03/0x03/save\n\nconst HMI_project = [\n    // é ç•™çµ¦ç‰¹æ®Šçš„å®Œå…¨åŒ¹é…æŒ‡ä»¤\n]\n\n// å‹•æ…‹ pattern å¯è§£æè®Šæ•¸å€¼\nconst HMI_pattern = [\n    // çª—ç°¾æ§åˆ¶ å‹•æ…‹è§£æ\n    {\n        name: \"curtain_control\",\n        pattern: [null, 0x06, 0x01, 0x9b, 0x00, null, null, null],\n        parse: (input) => {\n            const curtainId = input[0];  // 0x15 éµæ²é–€ 0x16 æœƒè­°å®¤æ²ç°¾ 0x17 å¸ƒç°¾ ç´—ç°¾ æ’ç…™çª—\n            const action = input[5];     // çª—ç°¾å‹•ä½œæŒ‡ä»¤ç¢¼\n\n            const CURTAIN_MAP = {\n                0x15: { topic: \"homeassistant/cover/curtain/21/ocs/set\", type: \"ocs\" },  // éµæ²é–€ ä¸‰æ…‹æ§åˆ¶\n                0x16: { topic: \"homeassistant/cover/curtain/22/oc/set\", type: \"oc\" },    // æœƒè­°å®¤æ²ç°¾ é›™æ…‹æ§åˆ¶\n                0x17: { topic: \"homeassistant/cover/curtain/23\", type: \"multi\" }         // å¸ƒç°¾ ç´—ç°¾ æ’ç…™çª— å¤šé‡æ§åˆ¶\n            };\n\n            const config = CURTAIN_MAP[curtainId];\n            if (!config) return null;\n\n            let payload, topicSuffix;\n\n            if (config.type === \"ocs\") {\n                // éµæ²é–€ ä¸‰æ…‹æ§åˆ¶ é–‹å•Ÿ åœ é—œé–‰\n                const ACTION_MAP_OCS = {\n                    0x01: \"1/2-3\",  // é–‹å•Ÿ\n                    0x04: \"2/1-3\",  // åœ\n                    0x02: \"3/1-2\"   // é—œé–‰\n                };\n                payload = ACTION_MAP_OCS[action];\n                topicSuffix = \"/set\";\n            } else if (config.type === \"oc\") {\n                // æœƒè­°å®¤æ²ç°¾ é›™æ…‹æ§åˆ¶ é–‹å•Ÿ é—œé–‰ åœ\n                const ACTION_MAP_OC = {\n                    0x01: \"1/2\",    // é–‹å•Ÿ\n                    0x02: \"2/1\",    // é—œé–‰\n                    0x03: \"1-2/\"    // åœ\n                };\n                payload = ACTION_MAP_OC[action];\n                topicSuffix = \"/set\";\n            } else if (config.type === \"multi\") {\n                // å¸ƒç°¾ ç´—ç°¾ æ’ç…™çª— å¤šé‡æ§åˆ¶\n                const ACTION_MAP_MULTI = {\n                    // å¸ƒç°¾ é–‹å•Ÿ åœ é—œé–‰\n                    0x01: { suffix: \"/oc/set\", payload: \"1/2\" },\n                    0x03: { suffix: \"/oc/set\", payload: \"1_2/\" },\n                    0x02: { suffix: \"/oc/set\", payload: \"2/1\" },\n                    // ç´—ç°¾ é–‹å•Ÿ åœ é—œé–‰\n                    0x04: { suffix: \"/oc/set\", payload: \"3/4\" },\n                    0x0C: { suffix: \"/oc/set\", payload: \"3_4/\" },\n                    0x08: { suffix: \"/oc/set\", payload: \"4/3\" },\n                    // æ’ç…™çª— é–‹å•Ÿ åœ é—œé–‰\n                    0x10: { suffix: \"/ocs/set\", payload: \"5/6_7\" },\n                    0x40: { suffix: \"/ocs/set\", payload: \"7/5_6\" },\n                    0x20: { suffix: \"/ocs/set\", payload: \"6/5_7\" }\n                };\n                const actionConfig = ACTION_MAP_MULTI[action];\n                if (!actionConfig) return null;\n                topicSuffix = actionConfig.suffix;\n                payload = actionConfig.payload;\n            }\n\n            if (!payload) return null;\n\n            return [{ topic: config.topic + topicSuffix, payload: payload }];\n        }\n    },\n    // å ´æ™¯æ§åˆ¶çµ±ä¸€è™•ç† åŒ…å«è¨˜æ†¶ã€æ¸¬è©¦æŒ‰éˆ•å’Œä¸€èˆ¬å ´æ™¯\n    {\n        name: \"scene_unified\",\n        pattern: [0xfe, 0x06, 0x08, 0x20, null, null, null, null],\n        parse: (input) => {\n            const operation = input[4];  // æ“ä½œç¢¼\n            const sceneId = input[5];    // å ´æ™¯ID\n\n            // === è¨˜æ†¶æŒ‡ä»¤è™•ç† 0x81 åˆ° 0x88 ===\n            if (operation >= 0x81 && operation <= 0x88) {\n\n                // è¨˜æ†¶æŒ‰éˆ•å°æ‡‰è¡¨ï¼šè¨˜æ†¶æŒ‰éˆ• 1-8 å°æ‡‰æ¸¬è©¦æŒ‰éˆ• 1-8\n                // æ³¨æ„ï¼šä¸ä¾è³´ input[5] å› ç‚º HMI å¯èƒ½ç™¼é€éŒ¯èª¤çš„ sceneId\n                // è¨˜æ†¶1(0x81) â†’ æ¸¬è©¦1(0x02/0x01), è¨˜æ†¶2(0x82) â†’ æ¸¬è©¦2(0x02/0x02)\n                // è¨˜æ†¶3(0x83) â†’ æ¸¬è©¦3(0x03/0x01), è¨˜æ†¶4(0x84) â†’ æ¸¬è©¦4(0x03/0x02)\n                // è¨˜æ†¶5(0x85) â†’ æ¸¬è©¦5(0x04/0x01), è¨˜æ†¶6(0x86) â†’ æ¸¬è©¦6(0x04/0x02)\n                // è¨˜æ†¶7(0x87) â†’ æ¸¬è©¦7(0x05/0x01), è¨˜æ†¶8(0x88) â†’ æ¸¬è©¦8(0x05/0x02)\n                const MEMORY_TO_TEST_MAP = {\n                    0x81: { sceneId: \"0x02\", operation: \"0x01\" },  // è¨˜æ†¶1 â†’ æ¸¬è©¦1 æœƒè­°å®¤ON\n                    0x82: { sceneId: \"0x02\", operation: \"0x02\" },  // è¨˜æ†¶2 â†’ æ¸¬è©¦2 æœƒè­°å®¤OFF\n                    0x83: { sceneId: \"0x03\", operation: \"0x01\" },  // è¨˜æ†¶3 â†’ æ¸¬è©¦3 å…¬å…±å€ON\n                    0x84: { sceneId: \"0x03\", operation: \"0x02\" },  // è¨˜æ†¶4 â†’ æ¸¬è©¦4 å…¬å…±å€OFF\n                    0x85: { sceneId: \"0x04\", operation: \"0x01\" },  // è¨˜æ†¶5 â†’ æ¸¬è©¦5 æˆ¶å¤–ON\n                    0x86: { sceneId: \"0x04\", operation: \"0x02\" },  // è¨˜æ†¶6 â†’ æ¸¬è©¦6 æˆ¶å¤–OFF\n                    0x87: { sceneId: \"0x05\", operation: \"0x01\" },  // è¨˜æ†¶7 â†’ æ¸¬è©¦7 H40 S1\n                    0x88: { sceneId: \"0x05\", operation: \"0x02\" }   // è¨˜æ†¶8 â†’ æ¸¬è©¦8 H40 S2\n                };\n\n                const SCENE_MEMORY_MAP = {\n                \"0x02\": {\n                    name: \"æœƒè­°å®¤\", devices: [\n                        \"homeassistant/light/single/13/1\",\n                        \"homeassistant/light/single/13/2\",\n                        \"homeassistant/light/single/13/3\",\n                        \"homeassistant/light/dual/14/a\",\n                        \"homeassistant/light/dual/14/b\"\n                    ]\n                },\n                \"0x03\": {\n                    name: \"å…¬å…±å€\", devices: [\n                        \"homeassistant/light/single/11/1\",\n                        \"homeassistant/light/single/11/2\",\n                        \"homeassistant/light/single/12/1\",\n                        \"homeassistant/light/single/12/2\",\n                        \"homeassistant/light/single/12/3\",\n                        \"homeassistant/light/single/12/4\"\n                    ]\n                },\n                \"0x04\": {\n                    name: \"æˆ¶å¤–\", devices: [\n                        \"homeassistant/light/single/18/1\",\n                        \"homeassistant/light/single/18/2\",\n                        \"homeassistant/light/single/19/1\",\n                        \"homeassistant/light/single/19/2\"\n                    ]\n                },\n                \"0x05\": {\n                    name: \"H40äºŒæ¨“\", devices: [\n                        \"homeassistant/light/single/15/1\",\n                        \"homeassistant/light/single/15/2\",\n                        \"homeassistant/light/single/16/1\",\n                        \"homeassistant/light/single/16/2\",\n                        \"homeassistant/light/single/17/1\",\n                        \"homeassistant/light/single/17/2\",\n                        \"homeassistant/light/single/18/1\",\n                        \"homeassistant/light/single/18/2\",\n                        \"homeassistant/light/single/19/1\",\n                        \"homeassistant/light/single/19/2\"\n                    ]\n                }\n            };\n\n                // ä½¿ç”¨è¨˜æ†¶æŒ‰éˆ•åˆ°æ¸¬è©¦æŒ‰éˆ•çš„å°æ‡‰è¡¨ ç›´æ¥ç”¨æ•¸å­—ä½œç‚º key\n                const mapping = MEMORY_TO_TEST_MAP[operation];\n\n                if (!mapping) {\n                    node.warn(`æœªçŸ¥çš„è¨˜æ†¶æŒ‰éˆ•: 0x${operation.toString(16).padStart(2, '0').toUpperCase()}`);\n                    return null;\n                }\n\n                // ç²å–å°æ‡‰çš„å ´æ™¯å’Œæ“ä½œ\n                const targetSceneId = mapping.sceneId;\n                const targetOperation = mapping.operation;\n                const sceneInfo = SCENE_MEMORY_MAP[targetSceneId]; if (!sceneInfo) {\n                    node.warn(`æœªæ‰¾åˆ°å ´æ™¯é…ç½®: ${targetSceneId}`);\n                    return null;\n                }\n\n            // è¨˜æ†¶æ“ä½œåç¨±å°ç…§\n            const opNames = {\n                \"0x01\": \"ON\",\n                \"0x02\": \"OFF\"\n            };\n\n                const opName = opNames[targetOperation] || targetOperation;\n\n            // ç™¼é€è¨˜æ†¶å„²å­˜è«‹æ±‚åˆ° MQTT ä¸»é¡Œ\n            // æ ¼å¼ homeassistant/memory/sceneId/operation/save/set\n            // å¯¦éš›å„²å­˜è™•ç†ç”± general command çš„ global.set å®Œæˆ\n                const memoryTopic = `homeassistant/memory/${targetSceneId}/${targetOperation}/save/set`;\n\n                const buttonNum = operation - 0x80; // è¨ˆç®—æŒ‰éˆ•ç·¨è™Ÿ 1-8\n                node.warn(`è¨˜æ†¶æŒ‰éˆ•${buttonNum} â†’ æ¸¬è©¦æŒ‰éˆ•: ${sceneInfo.name}_${opName} (${targetSceneId}/${targetOperation})`);\n\n            return [{\n                topic: memoryTopic,\n                payload: JSON.stringify({\n                    scene_name: `${sceneInfo.name}_${opName}`,\n                    devices: sceneInfo.devices,\n                    timestamp: new Date().toISOString(),\n                    command: bufferToHexArray(input)\n                })\n            }];\n            }\n\n            // === H70æ¸¬è©¦æŒ‰éˆ•è™•ç† 0x01-0x02 é…åˆç‰¹å®šå ´æ™¯ID ===\n            // æª¢æŸ¥æ˜¯å¦ç‚ºæ¸¬è©¦æŒ‰éˆ•å ´æ™¯ (æœƒè­°å®¤0x02, å…¬å…±å€0x03, æˆ¶å¤–0x04, H40äºŒæ¨“0x05)\n            const testSceneIds = [0x02, 0x03, 0x04, 0x05];\n            if ((operation === 0x01 || operation === 0x02) && testSceneIds.includes(sceneId)) {\n                const sceneKey = `0x${sceneId.toString(16).padStart(2, '0').toUpperCase()}`;\n                const opKey = `0x${operation.toString(16).padStart(2, '0').toUpperCase()}`;\n\n                // å ´æ™¯åç¨±å°ç…§\n                const sceneNames = {\n                    \"0x02\": \"æœƒè­°å®¤\",\n                    \"0x03\": \"å…¬å…±å€\",\n                    \"0x04\": \"æˆ¶å¤–ç‡ˆ\",\n                    \"0x05\": \"H40äºŒæ¨“\"\n                };\n                const opNames = {\n                    \"0x01\": \"ON\",\n                    \"0x02\": \"OFF\"\n                };\n\n                const sceneName = sceneNames[sceneKey] || `æœªçŸ¥å ´æ™¯${sceneKey}`;\n                const opName = opNames[opKey] || `æœªçŸ¥æ“ä½œ${opKey}`;\n\n                node.warn(`H70æ¸¬è©¦æŒ‰éˆ•: ${sceneName} ${opName} (${sceneKey}/${opKey})`);\n\n                return [{\n                    topic: `homeassistant/scene/${sceneKey}/${opKey}/execute/set`,\n                    payload: \"ON\"\n                }];\n            }\n\n            // === ä¸€èˆ¬å ´æ™¯æ§åˆ¶ ===\n            // è½‰æ›ç‚º MQTT ä¸»é¡Œ å¯¦éš›å ´æ™¯åŸ·è¡Œç”± general_command è™•ç†\n            const sceneKey = `0x${sceneId.toString(16).toUpperCase()}`;\n            const opKey = `0x${operation.toString(16).padStart(2, '0').toUpperCase()}`;\n\n            return [{\n                topic: `homeassistant/scene/${sceneKey}/${opKey}/execute/set`,\n                payload: \"ON\"\n            }];\n        }\n    },\n    {\n        name: \"light_control_unified\",\n        pattern: [\n            0xEE, 0xB1, 0x11, 0x00,\n            null,       // byte 4 å ´æ™¯ID 0x1E å…¬å…±å€ 0x1F æœƒè­°å®¤ 0x20 æœƒè­°å®¤2\n            0x00,\n            null,       // byte 6 åŠŸèƒ½ID 0x0B 0x0D 0x0F 0x11\n            0x13, 0x00, 0x00,\n            null, null, // bytes 10-11 æ•¸å€¼ 0x0000 åˆ° 0x03E8\n            0xFF, 0xFC, 0xFF, 0xFF\n        ],\n        parse: (input) => {\n            const sceneId = input[4];    // å ´æ™¯ID\n            const functionId = input[6]; // åŠŸèƒ½ID\n            const valueHigh = input[10];\n            const valueLow = input[11];\n            const raw = (valueHigh << 8) + valueLow;\n\n            // è½‰æ›æ•¸å€¼ 0 åˆ° 1000 å°æ‡‰ 0 åˆ° 100\n            let value = Math.round((raw / 1000) * 100);\n            value = clamp(value, 0, 100);\n            let state = value > 0 ? \"ON\" : \"OFF\";\n\n            // å ´æ™¯èˆ‡åŠŸèƒ½æ˜ å°„è¡¨\n            const LIGHT_MAP = {\n                // å…¬å…±å€ 0x1E\n                \"0x1E-0x0B\": { topic: \"homeassistant/light/scene/single/11-1--11-2\", type: \"brightness\" },\n                \"0x1E-0x0D\": { topic: \"homeassistant/light/scene/single/12-1\", type: \"brightness\" },\n                \"0x1E-0x0F\": { topic: \"homeassistant/light/scene/single/12-2\", type: \"brightness\" },\n                \"0x1E-0x11\": { topic: \"homeassistant/light/scene/single/12-3--12-4\", type: \"brightness\" },\n\n                // æœƒè­°å®¤ 0x1F\n                \"0x1F-0x0B\": { topic: \"homeassistant/light/scene/single/14/a\", type: \"brightness\" },\n                \"0x1F-0x0D\": { topic: \"homeassistant/light/scene/single/14/a\", type: \"colortemp\" },\n                \"0x1F-0x0F\": { topic: \"homeassistant/light/scene/single/14/b\", type: \"brightness\" },\n                \"0x1F-0x11\": { topic: \"homeassistant/light/scene/single/14/b\", type: \"colortemp\" },\n\n                // æœƒè­°å®¤2 0x20\n                \"0x20-0x0B\": { topic: \"homeassistant/light/scene/single/14/a\", type: \"brightness\" },\n                \"0x20-0x0D\": { topic: \"homeassistant/light/scene/single/14/a\", type: \"colortemp\" },\n                \"0x20-0x0F\": { topic: \"homeassistant/light/scene/single/14/b\", type: \"brightness\" },\n                \"0x20-0x11\": { topic: \"homeassistant/light/scene/single/14/b\", type: \"colortemp\" },\n            };\n\n            const key = `0x${sceneId.toString(16).toUpperCase()}-0x${functionId.toString(16).toUpperCase()}`;\n            const config = LIGHT_MAP[key];\n\n            if (!config) return null;\n\n            const baseTopic = config.topic;\n            const controlType = config.type;\n\n            if (controlType === \"brightness\") {\n                return [\n                    { topic: `${baseTopic}/set`, payload: state },\n                    { topic: `${baseTopic}/set/brightness`, payload: value },\n                    { topic: `${baseTopic}/state`, payload: state },\n                    { topic: `${baseTopic}/brightness`, payload: value }\n                ];\n            } else if (controlType === \"colortemp\") {\n                // è‰²æº«æ§åˆ¶\n                const colortemp = percentToColortemp(value);\n                return [\n                    { topic: `${baseTopic}/set`, payload: state },\n                    { topic: `${baseTopic}/set/colortemp`, payload: colortemp },\n                    { topic: `${baseTopic}/state`, payload: state },\n                    { topic: `${baseTopic}/colortemp`, payload: colortemp }\n                ];\n            }\n\n            return null;\n        }\n    },\n    // ç©ºèª¿ç³»çµ± å‹•æ…‹è§£æ\n    {\n        name: \"hvac_power_mode\",\n        pattern: [0x01, 0x31, null, 0x01, 0x01, null], // é–‹é—œ\n        parse: (input) => {\n            const powerValue = input[2]; // 0 é—œ 1 é–‹\n            const hvacId = input[5];     // ç©ºèª¿ID 1 2 3\n            const mode = powerValue === 0x01 ? \"auto\" : \"off\";\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_temperature\",\n        pattern: [0x01, 0x32, null, 0x01, 0x01, null], // æº«åº¦\n        parse: (input) => {\n            const tempValue = input[2];  // HEX å€¼ç›´æ¥ç­‰æ–¼æº«åº¦\n            const hvacId = input[5];\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/temperature/set`, payload: String(tempValue) }];\n        }\n    },\n    {\n        name: \"hvac_mode\",\n        pattern: [0x01, 0x33, null, 0x01, 0x01, null], // æ¨¡å¼ å†·æš–é™¤æ¿•é€é¢¨\n        parse: (input) => {\n            const modeValue = input[2];\n            const hvacId = input[5];\n            const MODE_MAP = {\n                0x00: \"cool\",      // å†·æ°£\n                0x01: \"dry\",       // é™¤æ¿•\n                0x02: \"fan_only\",  // é€é¢¨\n                0x04: \"heat\"       // æš–æ°£\n            };\n            const mode = MODE_MAP[modeValue];\n            if (!mode) return null;\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/mode/set`, payload: mode }];\n        }\n    },\n    {\n        name: \"hvac_fan_speed\",\n        pattern: [0x01, 0x34, null, 0x01, 0x01, null], // é¢¨é‡\n        parse: (input) => {\n            const fanValue = input[2];\n            const hvacId = input[5];\n            const FAN_MAP = {\n                0x03: \"medium\",  // ä¸­\n                0x04: \"high\",    // å¼· æˆ–è‡ªå‹• éœ€æ ¹æ“šç©ºèª¿IDåˆ¤æ–·\n                0x07: \"low\"      // å¼±\n            };\n            const fan = FAN_MAP[fanValue];\n            if (!fan) return null;\n\n            // ç©ºèª¿1 ç”¨ fan/set ç©ºèª¿2 å’Œ3 ç”¨ mode/fan\n            const topicSuffix = hvacId === 1 ? \"fan/set\" : \"mode/fan\";\n            return [{ topic: `homeassistant/hvac/200/${hvacId}/${topicSuffix}`, payload: fan }];\n        }\n    }\n];\n\nfunction clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\n\nfunction percentToColortemp(percent, minMired = MIN_MIRED, maxMired = MAX_MIRED) {\n    percent = clamp(Math.round(percent), 0, 100);\n    return Math.round(maxMired - ((maxMired - minMired) * percent / 100));\n}\n\nfunction bufferToHexArray(buf) {\n    return [...buf].map(v => \"0x\" + v.toString(16).padStart(2, \"0\"));\n}\n\n// å ´æ™¯ MQTT æŒ‡ä»¤ç”Ÿæˆè¼”åŠ©å‡½æ•¸\nfunction genLight(base, state, brightness = null, colortemp = null) {\n    const cmds = [\n        { topic: `${base}/set`, payload: state },\n        { topic: `${base}/state`, payload: state }\n    ];\n    if (state === \"ON\" && brightness !== null) {\n        cmds.push(\n            { topic: `${base}/set/brightness`, payload: brightness },\n            { topic: `${base}/brightness`, payload: brightness }\n        );\n    }\n    if (state === \"ON\" && colortemp !== null) {\n        cmds.push(\n            { topic: `${base}/set/colortemp`, payload: colortemp },\n            { topic: `${base}/colortemp`, payload: colortemp }\n        );\n    }\n    return cmds;\n}\n\nconst SCENE_MAP = {\n    0x0B: \"homeassistant/light/scene/single/11-1--11-2\",\n    0x0D: \"homeassistant/light/scene/single/13-1--13-2\",\n    0x0F: \"homeassistant/light/scene/single/15-1--15-2\",\n    0x11: \"homeassistant/light/scene/single/17-1--17-2\"\n};\n\nfunction matchPattern(input, pattern) {\n    if (input.length !== pattern.length) return false;\n\n    for (let i = 0; i < pattern.length; i++) {\n        if (pattern[i] !== null && pattern[i] !== input[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nfunction arrayEqual(a, b) {\n    if (!a || !b) return false;\n    if (a.length !== b.length) return false;\n    return a.every((v, i) => v === b[i]);\n}\n\n// ä¸»ç¨‹å¼é‚è¼¯\n// éŒ¯èª¤è™•ç† æª¢æŸ¥ payload æ˜¯å¦å­˜åœ¨\nif (!msg.payload || !Buffer.isBuffer(msg.payload)) {\n    node.warn(\"æ”¶åˆ°ç„¡æ•ˆçš„ payloadï¼Œå¿…é ˆæ˜¯ Buffer\");\n    return msg;\n}\n\nlet input = Array.from(msg.payload);\nlet result = null;\n\n// æ­¥é©Ÿ1 å®Œå…¨æ¯”å°\nfor (const item of HMI_project) {\n    if (arrayEqual(input, item.in)) {\n        result = item.out;\n        break;\n    }\n}\n\n// æ­¥é©Ÿ2 pattern æ¯”å°\nif (!result) {\n    for (const p of HMI_pattern) {\n        if (matchPattern(input, p.pattern)) {\n            result = p.parse(input);\n            break;\n        }\n    }\n}\n\n// æ­¥é©Ÿ3 æ¨å…¥ queue é¿å…æ¨å…¥ç©ºé™£åˆ—\nif (result && Array.isArray(result) && result.length > 0) {\n    let mqtt_queue = global.get(\"mqtt_queue\") || [];\n    mqtt_queue.push(...result);\n    global.set(\"mqtt_queue\", mqtt_queue);\n\n    // é™¤éŒ¯æ—¥èªŒ\n    node.warn(`æ”¶åˆ°è³‡æ–™: ${bufferToHexArray(msg.payload)}`);\n    node.warn(`ä½‡åˆ—ç›®å‰å…±æœ‰ ${mqtt_queue.length} å€‹å¾…é€ MQTT æŒ‡ä»¤`);\n} else if (result && !Array.isArray(result)) {\n    let mqtt_queue = global.get(\"mqtt_queue\") || [];\n    mqtt_queue.push(result);\n    global.set(\"mqtt_queue\", mqtt_queue);\n\n    node.warn(`æ”¶åˆ°è³‡æ–™: ${bufferToHexArray(msg.payload)}`);\n    node.warn(`ä½‡åˆ—ç›®å‰å…±æœ‰ ${mqtt_queue.length} å€‹å¾…é€ MQTT æŒ‡ä»¤`);\n} else {\n    node.warn(`æ”¶åˆ°è³‡æ–™: ${bufferToHexArray(msg.payload)} æœªåŒ¹é…ä»»ä½•è¦å‰‡`);\n}\n\n// å›å‚³åŸè¨Šæ¯\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":560,"y":1100,"wires":[["bdbab8f3e4311de9"]]},{"id":"69d4aa186ac69ce0","type":"inject","z":"e345e003a053a625","g":"58dd0fac1c7aa46a","name":"","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":810,"y":600,"wires":[["1a53e5aab7fdcab3"]]},{"id":"1a53e5aab7fdcab3","type":"function","z":"e345e003a053a625","g":"58dd0fac1c7aa46a","name":"m","func":"msg.payload = \"\"\nmsg.topic = `homeassistant/query/light/11/1/set`\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":930,"y":600,"wires":[["23cd4e4e4b8df214"]]},{"id":"23cd4e4e4b8df214","type":"mqtt out","z":"e345e003a053a625","g":"58dd0fac1c7aa46a","name":"","topic":"","qos":"","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"751ec40a6956d4f9","x":1050,"y":600,"wires":[]},{"id":"8134bccef9447b6f","type":"debug","z":"e345e003a053a625","g":"4264d0e29a86a022","name":"debug 1","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":1200,"y":880,"wires":[]},{"id":"ae93e63cc2e21005","type":"function","z":"e345e003a053a625","g":"d634068781bfec19","name":"Modbus Queue","func":"// Modbus Queue Processor\n// ç•¶æœ‰è¨Šæ¯é€²å…¥æ™‚ï¼Œæª¢æŸ¥ modbus_queue ä¸¦é–‹å§‹è™•ç†\n\n// æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰è™•ç†ç¨‹åºåœ¨é‹è¡Œ\nlet isProcessing = global.get(\"modbus_queue_processing\") || false;\n\nif (!isProcessing) {\n    let queue = global.get(\"modbus_queue\") || [];\n    \n    if (queue.length > 0) {\n        // æ¨™è¨˜ç‚ºè™•ç†ä¸­\n        global.set(\"modbus_queue_processing\", true);\n        \n        function sendNext() {\n            // é‡æ–°å¾ global å–æœ€æ–° queueï¼ˆé¿å…åŒæ­¥å•é¡Œï¼‰\n            let q = global.get(\"modbus_queue\") || [];\n            if (q.length > 0) {\n                // å–å‡ºç¬¬ä¸€ç­†\n                const msgToSend = q.shift();\n                // æ›´æ–° globalï¼ˆç§»é™¤å‰›ç™¼é€çš„é‚£ç­†ï¼‰\n                global.set(\"modbus_queue\", q);\n                node.status({ fill: \"green\", shape: \"dot\", text: `modbus queue ${q.length} left` });\n                // ç™¼é€\n                node.send(msgToSend);\n                // è¨­å®šå»¶é² 50ms é¿å… Modbus è¨­å‚™ä¾†ä¸åŠè™•ç†\n                setTimeout(sendNext, 1000);  // â† é—œéµï¼š50ms å»¶é²\n            } else {\n                // å…¨éƒ¨é€å®Œï¼Œæ¸…é™¤è™•ç†æ¨™è¨˜\n                global.set(\"modbus_queue_processing\", false);\n                node.status({ fill: \"green\", shape: \"ring\", text: \"modbus queue empty\" });\n            }\n        }\n        sendNext(); // å•Ÿå‹•ç™¼é€\n    }\n}\n\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"// Modbus Queue Processor - Initialize Script\n// éƒ¨ç½²ç¯€é»å¾Œï¼Œæ­¤è™•æ·»åŠ çš„ä»£ç¢¼å°‡é‹è¡Œä¸€æ¬¡\nglobal.set(\"modbus_queue\", []);\n","finalize":"","libs":[],"x":440,"y":880,"wires":[["8d0f6ac2e83aee8d"]]},{"id":"aac8603f0be1c33d","type":"function","z":"e345e003a053a625","g":"3da99baa8d84b477","name":"é€šç”¨è³‡æ–™debug","func":"switch (msg.command) {\n    case \"clear_flow_cache\": {\n        const keys = flow.keys();\n        keys.forEach(k => flow.set(k, undefined));\n        node.warn(`Flow context cleared: ${keys.length} keys removed.`);\n        return;\n    }\n    case \"show_flow_cache\": {\n        const keys = flow.keys();\n        keys.forEach(k => {\n            node.warn(`${k}:${flow.get(k)}`);\n        });}\n        return;\n    case \"clear_mqtt_queue\":{\n        let queue = global.get(\"mqtt_queue\") || [];\n        node.warn(`clear mqtt_queue of ${queue.length} data`);\n        global.set(\"mqtt_queue\",[]);\n        return;\n    }\n    case \"show_mqtt_queue\": {\n        let queue = global.get(\"mqtt_queue\") || [];\n        queue.forEach((item, index) => {\n            node.warn(`ç¬¬ ${index + 1} ç­†: ${JSON.stringify(item)}`);\n        });\n        return;\n    }\n    case \"show_modbus_queue\": {\n        let queue = global.get(\"modbus_queue\") || [];\n        node.warn(`modbus_queue å…±æœ‰ ${queue.length} ç­†è³‡æ–™`);\n        queue.forEach((item, index) => {\n            if (item.payload && Buffer.isBuffer(item.payload)) {\n                node.warn(`ç¬¬ ${index + 1} ç­†: Buffer ${item.payload.toString('hex')}`);\n            } else {\n                node.warn(`ç¬¬ ${index + 1} ç­†: ${JSON.stringify(item)}`);\n            }\n        });\n        return;\n    }\n    case \"clear_modbus_queue\": {\n        let queue = global.get(\"modbus_queue\") || [];\n        node.warn(`clear modbus_queue of ${queue.length} data`);\n        global.set(\"modbus_queue\", []);\n        return;\n    }\n    default: {\n        node.error(\"Unknown command\", msg.command);\n        return;\n    }\n}","outputs":0,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":540,"y":680,"wires":[]},{"id":"468d5430865a74c3","type":"inject","z":"e345e003a053a625","g":"3da99baa8d84b477","name":"æ¸…ç©º flow cache","props":[{"p":"command","v":"clear_flow_cache","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":160,"y":580,"wires":[["aac8603f0be1c33d"]],"icon":"font-awesome/fa-refresh"},{"id":"7fd49bd692bbc83d","type":"inject","z":"e345e003a053a625","g":"3da99baa8d84b477","name":"æ¸…ç©º mqtt_queue","props":[{"p":"command","v":"clear_mqtt_queue","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":160,"y":660,"wires":[["aac8603f0be1c33d"]],"icon":"font-awesome/fa-refresh"},{"id":"637cf20b08068b3c","type":"inject","z":"e345e003a053a625","g":"3da99baa8d84b477","name":"é¡¯ç¤º flow cache","props":[{"p":"command","v":"show_flow_cache","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":160,"y":620,"wires":[["aac8603f0be1c33d"]],"icon":"font-awesome/fa-refresh"},{"id":"3e3e53d0e771b500","type":"inject","z":"e345e003a053a625","g":"3da99baa8d84b477","name":"é¡¯ç¤º mqtt_queue","props":[{"p":"command","v":"show_mqtt_queue","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":160,"y":700,"wires":[["aac8603f0be1c33d"]],"icon":"font-awesome/fa-refresh"},{"id":"81fab6fcd799f651","type":"inject","z":"e345e003a053a625","g":"3da99baa8d84b477","name":"show_modbus_queue","props":[{"p":"command","v":"show_modbus_queue","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":180,"y":740,"wires":[["aac8603f0be1c33d"]],"icon":"font-awesome/fa-refresh"},{"id":"5ce9b5afce831e15","type":"inject","z":"e345e003a053a625","g":"3da99baa8d84b477","name":"clear_modbus_queue","props":[{"p":"command","v":"clear_modbus_queue","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":180,"y":780,"wires":[["aac8603f0be1c33d"]],"icon":"font-awesome/fa-refresh"},{"id":"44bc924468f631dd","type":"tcp request","z":"e345e003a053a625","g":"4264d0e29a86a022","name":"","server":"192.168.1.204","port":"502","out":"time","ret":"buffer","splitc":"0","newline":"","trim":false,"tls":"","x":900,"y":900,"wires":[["885f68f7485a99c1"]]},{"id":"d9123b98976ecc27","type":"tcp request","z":"e345e003a053a625","g":"4264d0e29a86a022","name":"","server":"192.168.98.208","port":"502","out":"time","ret":"buffer","splitc":"0","newline":"","trim":false,"tls":"","x":910,"y":940,"wires":[["885f68f7485a99c1"]]},{"id":"01056b80c8745ee3","type":"tcp request","z":"e345e003a053a625","d":true,"g":"4264d0e29a86a022","name":"","server":"192.168.1.222","port":"1030","out":"time","ret":"buffer","splitc":"0","newline":"","trim":false,"tls":"","x":910,"y":860,"wires":[["885f68f7485a99c1"]]},{"id":"3ea0e6d267edaf7f","type":"tcp request","z":"e345e003a053a625","d":true,"g":"4264d0e29a86a022","name":"","server":"192.168.1.211","port":"1030","out":"time","ret":"buffer","splitc":"0","newline":"","trim":false,"tls":"","x":910,"y":820,"wires":[["885f68f7485a99c1"]]},{"id":"82ceaf2e62b7218a","type":"function","z":"e345e003a053a625","g":"856c5ad89dfdd04b","name":"general cofiguration","func":"// æ•´åˆçš„ Home Assistant MQTT é…ç½®ç”Ÿæˆå™¨\n// æ”¯æ´: Lights (å–®è‰²/é›™è‰²), Scenes, Covers (çª—ç°¾/æ²ç°¾), Climate (ç©ºèª¿)\n\n// ============ è¨­å‚™å®šç¾© ============\n\n// 1. ç‡ˆå…‰è¨­å‚™\nlet lights = [\n    // ç›¤A\n    { id: \"single_11_1\", name: \"single-11-1\" },\n    { id: \"single_11_2\", name: \"single-11-2\" },\n    { id: \"single_12_1\", name: \"single-12-1\" },\n    { id: \"single_12_2\", name: \"single-12-2\" },\n    { id: \"single_12_3\", name: \"single-12-3\" },\n    { id: \"single_12_4\", name: \"single-12-4\" },\n    { id: \"single_13_1\", name: \"single-13-1\" },\n    { id: \"single_13_2\", name: \"single-13-2\" },\n    { id: \"single_13_3\", name: \"single-13-3\" },\n    { id: \"single_13_4\", name: \"single-13-4\" },\n    { id: \"dual_14_a\", name: \"dual-14-a\" },\n    { id: \"dual_14_b\", name: \"dual-14-b\" },\n    // ç›¤B\n    { id: \"single_15_1\", name: \"single-15-1\" },\n    { id: \"single_15_2\", name: \"single-15-2\" },\n    { id: \"single_16_1\", name: \"single-16-1\" },\n    { id: \"single_16_2\", name: \"single-16-2\" },\n    { id: \"single_17_1\", name: \"single-17-1\" },\n    { id: \"single_17_2\", name: \"single-17-2\" },\n    { id: \"single_18_1\", name: \"single-18-1\" },\n    { id: \"single_18_2\", name: \"single-18-2\" },\n    { id: \"single_19_1\", name: \"single-19-1\" },\n    { id: \"single_19_2\", name: \"single-19-2\" },\n];\n\n// 2. æƒ…å¢ƒè¨­å‚™\nlet scenes = [\n    { id: \"scene_single_11-1--11-2\", name: \"èµ°å»Šé–“ç…§\" },\n    { id: \"scene_single_12-1\", name: \"æ³¡èŒ¶å€\" },\n    { id: \"scene_single_12-2\", name: \"èµ°é“å´ç‡ˆ\" },\n    { id: \"scene_single_12-3--12-4\", name: \"å±•ç¤ºæ«ƒ\" },\n    { id: \"scene_single_13-1\", name: \"æœƒè­°é–“ç…§\" },\n    { id: \"scene_single_13-2\", name: \"å†·æ°£é–“ç…§\" },\n    { id: \"scene_single_13-3\", name: \"æœƒè­°å´ç‡ˆ\" },\n    { id: \"scene_single_15-1\", name: \"å®¢å»³å‰\" },\n    { id: \"scene_single_15-2\", name: \"å®¢å»³å¾Œ\" },\n    { id: \"scene_single_16-1--16-2\", name: \"èµ°é“é–“ç…§\" },\n    { id: \"scene_single_17-1--17-2\", name: \"å»šæˆ¿\" },\n    { id: \"scene_single_18-1\", name: \"1Få£ç‡ˆ\" },\n    { id: \"scene_single_18-2\", name: \"1Fåœ°ç‡ˆ\" },\n    { id: \"scene_single_19-1\", name: \"2Få£ç‡ˆ\" },\n    { id: \"scene_single_19-2\", name: \"2Fåœ°ç‡ˆ\" },\n    // å ´æ™¯ç‡ˆå…‰ç¾¤çµ„ (ç”¨æ–¼å ´æ™¯æ§åˆ¶)\n    { id: \"scene_single_11-1--11-2--12-1--12-2--12-3--12-4\", name: \"å…¬å…±å€ç‡ˆçµ„\" },\n    { id: \"scene_single_13-1--13-2--13-3\", name: \"æœƒè­°å®¤ç‡ˆçµ„\" },\n    { id: \"scene_dual_14-a--14-b\", name: \"æœƒè­°å®¤é›™è‰²æº«ç‡ˆçµ„\" },\n    { id: \"scene_single_15-1--15-2--16-1--17-1--18-1--18-2--19-1--19-2\", name: \"äºŒæ¨“ç‡ˆçµ„\" },\n    { id: \"scene_single_18-1--18-2--19-1--19-2\", name: \"æˆ¶å¤–ç‡ˆçµ„\" },\n];\n\n// 3. çª—ç°¾/æ²ç°¾è¨­å‚™\nlet covers = [\n    { id: \"curtain_21_1-2-3\", name: \"éµæ²é–€\" },\n    { id: \"curtain_22_1-2\", name: \"æœƒè­°å®¤æ²ç°¾\" },\n    { id: \"curtain_23_1-2\", name: \"å¸ƒç°¾\" },\n    { id: \"curtain_23_3-4\", name: \"æ²™ç°¾\" },\n    { id: \"curtain_23_5-6-7\", name: \"æ’ç…™çª—\" },\n];\n\n// 4. ç©ºèª¿è¨­å‚™\nlet climates = [\n    { id: \"200-1\", name: \"å®¢å»³ç©ºèª¿\" },\n    { id: \"200-2\", name: \"æœƒè­°å®¤ç©ºèª¿\" },\n    { id: \"200-3\", name: \"ç„é—œç©ºèª¿\" },\n    { id: \"200-9\", name: \"è¾¦å…¬å®¤æ¸¬è©¦\" }\n];\n\n// ============ é…ç½®ç”Ÿæˆå‡½æ•¸ ============\n\n// ç”Ÿæˆç‡ˆå…‰é…ç½®\nfunction generateLightConfigs(lights) {\n    return lights.map(light => {\n        let parts = light.id.split(\"_\");\n        let basePayload = {\n            name: light.name,\n            unique_id: light.id,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            optimistic: true,\n            state_topic: `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/state`,\n            command_topic: `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set`,\n        };\n        \n        switch(parts[0]) {\n            case \"single\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/brightness`;\n                basePayload.brightness_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/colortemp`;\n                basePayload.color_temp_command_topic = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"relay\": {\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/light/${light.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆæƒ…å¢ƒé…ç½®\nfunction generateSceneConfigs(scenes) {\n    return scenes.map(scene => {\n        let parts = scene.id.split(\"_\");\n        let prefix = `homeassistant/light/${parts[0]}/${parts[1]}/${parts[2]}`;\n        let basePayload = {\n            name: scene.name,\n            unique_id: scene.id,\n            payload_on: \"ON\",\n            payload_off: \"OFF\",\n            optimistic: true,\n            state_topic: `${prefix}/state`,\n            command_topic: `${prefix}/set`,\n        };\n        \n        switch(parts[1]) {\n            case \"single\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                break;\n            }\n            case \"dual\": {\n                basePayload.brightness = true;\n                basePayload.brightness_state_topic = `${prefix}/brightness`;\n                basePayload.brightness_command_topic = `${prefix}/set/brightness`;\n                basePayload.brightness_scale = 100;\n                basePayload.color_temp_state_topic = `${prefix}/colortemp`;\n                basePayload.color_temp_command_topic = `${prefix}/set/colortemp`;\n                basePayload.min_mireds = 154; // 6500K\n                basePayload.max_mireds = 370; // 2700K\n                break;\n            }\n            case \"relay\": {\n                break;\n            }\n        }\n\n        return {\n            topic: `homeassistant/light/${scene.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆçª—ç°¾é…ç½®\nfunction generateCoverConfigs(covers) {\n    return covers.map(cover => {\n        let part = cover.id.split(\"_\");\n        let device_type = part[0];\n        let id = part[1];\n        let control = (part[2]).split(\"-\");\n\n        let basePayload = {\n            name: cover.name,\n            unique_id: cover.id,\n            optimistic: true,\n            retain: true\n        };\n\n        let operation_type;\n        switch (control.length) {\n            case 2: {\n                operation_type = \"oc\";\n                basePayload.payload_open = `${control[0]}/${control[1]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}`;\n                basePayload.payload_stop = `${control[0]}_${control[1]}/`;\n                break;\n            }\n            case 3: {\n                operation_type = \"ocs\";\n                basePayload.payload_open = `${control[0]}/${control[1]}_${control[2]}`;\n                basePayload.payload_close = `${control[1]}/${control[0]}_${control[2]}`;\n                basePayload.payload_stop = `${control[2]}/${control[0]}_${control[1]}`;\n                break;\n            }\n            default: {\n                node.warn(\"Unknown type of curtain\");\n                break;\n            }\n        }\n        \n        basePayload.command_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/set`;\n        basePayload.state_topic = `homeassistant/cover/${device_type}/${id}/${operation_type}/state`;\n\n        return {\n            topic: `homeassistant/cover/${cover.id}/config`,\n            payload: basePayload,\n            retain: true\n        };\n    });\n}\n\n// ç”Ÿæˆç©ºèª¿é…ç½®\nfunction generateClimateConfigs(climates) {\n    let ui_name = \"climate\";\n    let topic_name = \"hvac\";\n\n    return climates.map(ac => {\n        const parts = ac.id.split(\"-\");\n        const s200_id = parts[0];\n        const id = parts[1];\n        const prefix = `homeassistant/${topic_name}/${s200_id}/${id}`;\n\n        const base = {\n            name: ac.name,\n            unique_id: ac.id,\n            optimistic: true,\n            modes: [\"off\", \"cool\", \"heat\", \"dry\", \"fan_only\", \"auto\"],\n            mode_command_topic: `${prefix}/mode/set`,\n            mode_state_topic: `${prefix}/mode/state`,\n            temperature_command_topic: `${prefix}/temperature/set`,\n            temperature_state_topic: `${prefix}/temperature/state`,\n            min_temp: 16,\n            max_temp: 30,\n            temp_step: 1,\n            current_temperature_topic: `${prefix}/current_temperature`,\n            fan_modes: [\"auto\", \"low\", \"medium\", \"high\"],\n            fan_mode_command_topic: `${prefix}/fan/set`,\n            fan_mode_state_topic: `${prefix}/fan/state`,\n            retain: true,\n        };\n\n        return {\n            topic: `homeassistant/${ui_name}/${ac.id}/config`,\n            payload: base,\n            retain: true\n        };\n    });\n}\n\n// ============ ä¸»è¦åŸ·è¡Œ ============\n\n// ç”Ÿæˆæ‰€æœ‰é…ç½®\nlet allMessages = [\n    ...generateLightConfigs(lights),\n    ...generateSceneConfigs(scenes),\n    ...generateCoverConfigs(covers),\n    ...generateClimateConfigs(climates)\n];\n\n// è¿”å›æ‰€æœ‰è¨Šæ¯\nreturn [allMessages];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":310,"y":460,"wires":[["2e98dadaf8e45671"]]},{"id":"895ee05a057f6773","type":"inject","z":"e345e003a053a625","g":"d634068781bfec19","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":850,"y":1040,"wires":[["cfa9ec9556dfb6d8"]]},{"id":"cfa9ec9556dfb6d8","type":"function","z":"e345e003a053a625","g":"d634068781bfec19","name":"function 2","func":"// å¯« single-12-1 äº®åº¦ 50% çš„ Modbus RTU æŒ‡ä»¤\nmsg.payload = Buffer.from(\"0c06082a053229fa\", \"hex\");\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1000,"y":1040,"wires":[["847c6ac1944eac57"]]},{"id":"847c6ac1944eac57","type":"tcp request","z":"e345e003a053a625","g":"d634068781bfec19","name":"","server":"192.168.98.208","port":"502","out":"time","ret":"buffer","splitc":"0","newline":"","trim":false,"tls":"","x":1110,"y":1180,"wires":[[]]},{"id":"751ec40a6956d4f9","type":"mqtt-broker","name":"","broker":"192.168.1.233","port":"1883","clientid":"","autoConnect":true,"usetls":false,"protocolVersion":"4","keepalive":"60","cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""}]